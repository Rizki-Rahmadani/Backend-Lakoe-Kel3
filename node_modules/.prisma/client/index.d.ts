
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profiles
 * 
 */
export type Profiles = $Result.DefaultSelection<Prisma.$ProfilesPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Stores
 * 
 */
export type Stores = $Result.DefaultSelection<Prisma.$StoresPayload>
/**
 * Model bank_accounts
 * 
 */
export type bank_accounts = $Result.DefaultSelection<Prisma.$bank_accountsPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Variant_option_values
 * 
 */
export type Variant_option_values = $Result.DefaultSelection<Prisma.$Variant_option_valuesPayload>
/**
 * Model Variant_options
 * 
 */
export type Variant_options = $Result.DefaultSelection<Prisma.$Variant_optionsPayload>
/**
 * Model Variants
 * 
 */
export type Variants = $Result.DefaultSelection<Prisma.$VariantsPayload>
/**
 * Model Categories
 * 
 */
export type Categories = $Result.DefaultSelection<Prisma.$CategoriesPayload>
/**
 * Model Carts
 * 
 */
export type Carts = $Result.DefaultSelection<Prisma.$CartsPayload>
/**
 * Model Cart_items
 * 
 */
export type Cart_items = $Result.DefaultSelection<Prisma.$Cart_itemsPayload>
/**
 * Model Invoices
 * 
 */
export type Invoices = $Result.DefaultSelection<Prisma.$InvoicesPayload>
/**
 * Model Confirmation_payment
 * 
 */
export type Confirmation_payment = $Result.DefaultSelection<Prisma.$Confirmation_paymentPayload>
/**
 * Model Invoice_histories
 * 
 */
export type Invoice_histories = $Result.DefaultSelection<Prisma.$Invoice_historiesPayload>
/**
 * Model Payments
 * 
 */
export type Payments = $Result.DefaultSelection<Prisma.$PaymentsPayload>
/**
 * Model Couriers
 * 
 */
export type Couriers = $Result.DefaultSelection<Prisma.$CouriersPayload>
/**
 * Model Decoration
 * 
 */
export type Decoration = $Result.DefaultSelection<Prisma.$DecorationPayload>
/**
 * Model Stores_on_decorations
 * 
 */
export type Stores_on_decorations = $Result.DefaultSelection<Prisma.$Stores_on_decorationsPayload>
/**
 * Model Operation_hours
 * 
 */
export type Operation_hours = $Result.DefaultSelection<Prisma.$Operation_hoursPayload>
/**
 * Model Message_templates
 * 
 */
export type Message_templates = $Result.DefaultSelection<Prisma.$Message_templatesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profiles`: Exposes CRUD operations for the **Profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profiles.findMany()
    * ```
    */
  get profiles(): Prisma.ProfilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stores`: Exposes CRUD operations for the **Stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.StoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bank_accounts`: Exposes CRUD operations for the **bank_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bank_accounts
    * const bank_accounts = await prisma.bank_accounts.findMany()
    * ```
    */
  get bank_accounts(): Prisma.bank_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variant_option_values`: Exposes CRUD operations for the **Variant_option_values** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variant_option_values
    * const variant_option_values = await prisma.variant_option_values.findMany()
    * ```
    */
  get variant_option_values(): Prisma.Variant_option_valuesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variant_options`: Exposes CRUD operations for the **Variant_options** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variant_options
    * const variant_options = await prisma.variant_options.findMany()
    * ```
    */
  get variant_options(): Prisma.Variant_optionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variants`: Exposes CRUD operations for the **Variants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variants
    * const variants = await prisma.variants.findMany()
    * ```
    */
  get variants(): Prisma.VariantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **Categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.CategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carts`: Exposes CRUD operations for the **Carts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.carts.findMany()
    * ```
    */
  get carts(): Prisma.CartsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart_items`: Exposes CRUD operations for the **Cart_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cart_items
    * const cart_items = await prisma.cart_items.findMany()
    * ```
    */
  get cart_items(): Prisma.Cart_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **Invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.InvoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.confirmation_payment`: Exposes CRUD operations for the **Confirmation_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Confirmation_payments
    * const confirmation_payments = await prisma.confirmation_payment.findMany()
    * ```
    */
  get confirmation_payment(): Prisma.Confirmation_paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice_histories`: Exposes CRUD operations for the **Invoice_histories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoice_histories
    * const invoice_histories = await prisma.invoice_histories.findMany()
    * ```
    */
  get invoice_histories(): Prisma.Invoice_historiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **Payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.PaymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.couriers`: Exposes CRUD operations for the **Couriers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Couriers
    * const couriers = await prisma.couriers.findMany()
    * ```
    */
  get couriers(): Prisma.CouriersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decoration`: Exposes CRUD operations for the **Decoration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Decorations
    * const decorations = await prisma.decoration.findMany()
    * ```
    */
  get decoration(): Prisma.DecorationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stores_on_decorations`: Exposes CRUD operations for the **Stores_on_decorations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores_on_decorations
    * const stores_on_decorations = await prisma.stores_on_decorations.findMany()
    * ```
    */
  get stores_on_decorations(): Prisma.Stores_on_decorationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operation_hours`: Exposes CRUD operations for the **Operation_hours** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operation_hours
    * const operation_hours = await prisma.operation_hours.findMany()
    * ```
    */
  get operation_hours(): Prisma.Operation_hoursDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message_templates`: Exposes CRUD operations for the **Message_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Message_templates
    * const message_templates = await prisma.message_templates.findMany()
    * ```
    */
  get message_templates(): Prisma.Message_templatesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profiles: 'Profiles',
    Roles: 'Roles',
    Product: 'Product',
    Stores: 'Stores',
    bank_accounts: 'bank_accounts',
    Location: 'Location',
    Variant_option_values: 'Variant_option_values',
    Variant_options: 'Variant_options',
    Variants: 'Variants',
    Categories: 'Categories',
    Carts: 'Carts',
    Cart_items: 'Cart_items',
    Invoices: 'Invoices',
    Confirmation_payment: 'Confirmation_payment',
    Invoice_histories: 'Invoice_histories',
    Payments: 'Payments',
    Couriers: 'Couriers',
    Decoration: 'Decoration',
    Stores_on_decorations: 'Stores_on_decorations',
    Operation_hours: 'Operation_hours',
    Message_templates: 'Message_templates'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "profiles" | "roles" | "product" | "stores" | "bank_accounts" | "location" | "variant_option_values" | "variant_options" | "variants" | "categories" | "carts" | "cart_items" | "invoices" | "confirmation_payment" | "invoice_histories" | "payments" | "couriers" | "decoration" | "stores_on_decorations" | "operation_hours" | "message_templates"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profiles: {
        payload: Prisma.$ProfilesPayload<ExtArgs>
        fields: Prisma.ProfilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>
          }
          findFirst: {
            args: Prisma.ProfilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>
          }
          findMany: {
            args: Prisma.ProfilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>[]
          }
          create: {
            args: Prisma.ProfilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>
          }
          createMany: {
            args: Prisma.ProfilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfilesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>[]
          }
          delete: {
            args: Prisma.ProfilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>
          }
          update: {
            args: Prisma.ProfilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>
          }
          deleteMany: {
            args: Prisma.ProfilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfilesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>[]
          }
          upsert: {
            args: Prisma.ProfilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilesPayload>
          }
          aggregate: {
            args: Prisma.ProfilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfiles>
          }
          groupBy: {
            args: Prisma.ProfilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfilesCountArgs<ExtArgs>
            result: $Utils.Optional<ProfilesCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Stores: {
        payload: Prisma.$StoresPayload<ExtArgs>
        fields: Prisma.StoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findFirst: {
            args: Prisma.StoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findMany: {
            args: Prisma.StoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          create: {
            args: Prisma.StoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          createMany: {
            args: Prisma.StoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          delete: {
            args: Prisma.StoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          update: {
            args: Prisma.StoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          deleteMany: {
            args: Prisma.StoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          upsert: {
            args: Prisma.StoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          aggregate: {
            args: Prisma.StoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores>
          }
          groupBy: {
            args: Prisma.StoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoresCountArgs<ExtArgs>
            result: $Utils.Optional<StoresCountAggregateOutputType> | number
          }
        }
      }
      bank_accounts: {
        payload: Prisma.$bank_accountsPayload<ExtArgs>
        fields: Prisma.bank_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bank_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bank_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          findFirst: {
            args: Prisma.bank_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bank_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          findMany: {
            args: Prisma.bank_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>[]
          }
          create: {
            args: Prisma.bank_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          createMany: {
            args: Prisma.bank_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bank_accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>[]
          }
          delete: {
            args: Prisma.bank_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          update: {
            args: Prisma.bank_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          deleteMany: {
            args: Prisma.bank_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bank_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bank_accountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>[]
          }
          upsert: {
            args: Prisma.bank_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_accountsPayload>
          }
          aggregate: {
            args: Prisma.Bank_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank_accounts>
          }
          groupBy: {
            args: Prisma.bank_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bank_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bank_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Bank_accountsCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Variant_option_values: {
        payload: Prisma.$Variant_option_valuesPayload<ExtArgs>
        fields: Prisma.Variant_option_valuesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Variant_option_valuesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Variant_option_valuesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>
          }
          findFirst: {
            args: Prisma.Variant_option_valuesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Variant_option_valuesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>
          }
          findMany: {
            args: Prisma.Variant_option_valuesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>[]
          }
          create: {
            args: Prisma.Variant_option_valuesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>
          }
          createMany: {
            args: Prisma.Variant_option_valuesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Variant_option_valuesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>[]
          }
          delete: {
            args: Prisma.Variant_option_valuesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>
          }
          update: {
            args: Prisma.Variant_option_valuesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>
          }
          deleteMany: {
            args: Prisma.Variant_option_valuesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Variant_option_valuesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Variant_option_valuesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>[]
          }
          upsert: {
            args: Prisma.Variant_option_valuesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_option_valuesPayload>
          }
          aggregate: {
            args: Prisma.Variant_option_valuesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariant_option_values>
          }
          groupBy: {
            args: Prisma.Variant_option_valuesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Variant_option_valuesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Variant_option_valuesCountArgs<ExtArgs>
            result: $Utils.Optional<Variant_option_valuesCountAggregateOutputType> | number
          }
        }
      }
      Variant_options: {
        payload: Prisma.$Variant_optionsPayload<ExtArgs>
        fields: Prisma.Variant_optionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Variant_optionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Variant_optionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>
          }
          findFirst: {
            args: Prisma.Variant_optionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Variant_optionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>
          }
          findMany: {
            args: Prisma.Variant_optionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>[]
          }
          create: {
            args: Prisma.Variant_optionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>
          }
          createMany: {
            args: Prisma.Variant_optionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Variant_optionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>[]
          }
          delete: {
            args: Prisma.Variant_optionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>
          }
          update: {
            args: Prisma.Variant_optionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>
          }
          deleteMany: {
            args: Prisma.Variant_optionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Variant_optionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Variant_optionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>[]
          }
          upsert: {
            args: Prisma.Variant_optionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Variant_optionsPayload>
          }
          aggregate: {
            args: Prisma.Variant_optionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariant_options>
          }
          groupBy: {
            args: Prisma.Variant_optionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Variant_optionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Variant_optionsCountArgs<ExtArgs>
            result: $Utils.Optional<Variant_optionsCountAggregateOutputType> | number
          }
        }
      }
      Variants: {
        payload: Prisma.$VariantsPayload<ExtArgs>
        fields: Prisma.VariantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>
          }
          findFirst: {
            args: Prisma.VariantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>
          }
          findMany: {
            args: Prisma.VariantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>[]
          }
          create: {
            args: Prisma.VariantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>
          }
          createMany: {
            args: Prisma.VariantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>[]
          }
          delete: {
            args: Prisma.VariantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>
          }
          update: {
            args: Prisma.VariantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>
          }
          deleteMany: {
            args: Prisma.VariantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>[]
          }
          upsert: {
            args: Prisma.VariantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantsPayload>
          }
          aggregate: {
            args: Prisma.VariantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariants>
          }
          groupBy: {
            args: Prisma.VariantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantsCountArgs<ExtArgs>
            result: $Utils.Optional<VariantsCountAggregateOutputType> | number
          }
        }
      }
      Categories: {
        payload: Prisma.$CategoriesPayload<ExtArgs>
        fields: Prisma.CategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findFirst: {
            args: Prisma.CategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          findMany: {
            args: Prisma.CategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          create: {
            args: Prisma.CategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          createMany: {
            args: Prisma.CategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          delete: {
            args: Prisma.CategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          update: {
            args: Prisma.CategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          deleteMany: {
            args: Prisma.CategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>[]
          }
          upsert: {
            args: Prisma.CategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.CategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      Carts: {
        payload: Prisma.$CartsPayload<ExtArgs>
        fields: Prisma.CartsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>
          }
          findFirst: {
            args: Prisma.CartsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>
          }
          findMany: {
            args: Prisma.CartsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>[]
          }
          create: {
            args: Prisma.CartsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>
          }
          createMany: {
            args: Prisma.CartsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>[]
          }
          delete: {
            args: Prisma.CartsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>
          }
          update: {
            args: Prisma.CartsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>
          }
          deleteMany: {
            args: Prisma.CartsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>[]
          }
          upsert: {
            args: Prisma.CartsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartsPayload>
          }
          aggregate: {
            args: Prisma.CartsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarts>
          }
          groupBy: {
            args: Prisma.CartsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartsCountArgs<ExtArgs>
            result: $Utils.Optional<CartsCountAggregateOutputType> | number
          }
        }
      }
      Cart_items: {
        payload: Prisma.$Cart_itemsPayload<ExtArgs>
        fields: Prisma.Cart_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Cart_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Cart_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>
          }
          findFirst: {
            args: Prisma.Cart_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Cart_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>
          }
          findMany: {
            args: Prisma.Cart_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>[]
          }
          create: {
            args: Prisma.Cart_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>
          }
          createMany: {
            args: Prisma.Cart_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Cart_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>[]
          }
          delete: {
            args: Prisma.Cart_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>
          }
          update: {
            args: Prisma.Cart_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>
          }
          deleteMany: {
            args: Prisma.Cart_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Cart_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Cart_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>[]
          }
          upsert: {
            args: Prisma.Cart_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Cart_itemsPayload>
          }
          aggregate: {
            args: Prisma.Cart_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart_items>
          }
          groupBy: {
            args: Prisma.Cart_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cart_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Cart_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Cart_itemsCountAggregateOutputType> | number
          }
        }
      }
      Invoices: {
        payload: Prisma.$InvoicesPayload<ExtArgs>
        fields: Prisma.InvoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          findFirst: {
            args: Prisma.InvoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          findMany: {
            args: Prisma.InvoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>[]
          }
          create: {
            args: Prisma.InvoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          createMany: {
            args: Prisma.InvoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>[]
          }
          delete: {
            args: Prisma.InvoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          update: {
            args: Prisma.InvoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          deleteMany: {
            args: Prisma.InvoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>[]
          }
          upsert: {
            args: Prisma.InvoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicesPayload>
          }
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoices>
          }
          groupBy: {
            args: Prisma.InvoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoicesCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number
          }
        }
      }
      Confirmation_payment: {
        payload: Prisma.$Confirmation_paymentPayload<ExtArgs>
        fields: Prisma.Confirmation_paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Confirmation_paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Confirmation_paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>
          }
          findFirst: {
            args: Prisma.Confirmation_paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Confirmation_paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>
          }
          findMany: {
            args: Prisma.Confirmation_paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>[]
          }
          create: {
            args: Prisma.Confirmation_paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>
          }
          createMany: {
            args: Prisma.Confirmation_paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Confirmation_paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>[]
          }
          delete: {
            args: Prisma.Confirmation_paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>
          }
          update: {
            args: Prisma.Confirmation_paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>
          }
          deleteMany: {
            args: Prisma.Confirmation_paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Confirmation_paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Confirmation_paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>[]
          }
          upsert: {
            args: Prisma.Confirmation_paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Confirmation_paymentPayload>
          }
          aggregate: {
            args: Prisma.Confirmation_paymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfirmation_payment>
          }
          groupBy: {
            args: Prisma.Confirmation_paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Confirmation_paymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.Confirmation_paymentCountArgs<ExtArgs>
            result: $Utils.Optional<Confirmation_paymentCountAggregateOutputType> | number
          }
        }
      }
      Invoice_histories: {
        payload: Prisma.$Invoice_historiesPayload<ExtArgs>
        fields: Prisma.Invoice_historiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Invoice_historiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Invoice_historiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>
          }
          findFirst: {
            args: Prisma.Invoice_historiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Invoice_historiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>
          }
          findMany: {
            args: Prisma.Invoice_historiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>[]
          }
          create: {
            args: Prisma.Invoice_historiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>
          }
          createMany: {
            args: Prisma.Invoice_historiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Invoice_historiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>[]
          }
          delete: {
            args: Prisma.Invoice_historiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>
          }
          update: {
            args: Prisma.Invoice_historiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>
          }
          deleteMany: {
            args: Prisma.Invoice_historiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Invoice_historiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Invoice_historiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>[]
          }
          upsert: {
            args: Prisma.Invoice_historiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Invoice_historiesPayload>
          }
          aggregate: {
            args: Prisma.Invoice_historiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice_histories>
          }
          groupBy: {
            args: Prisma.Invoice_historiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invoice_historiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Invoice_historiesCountArgs<ExtArgs>
            result: $Utils.Optional<Invoice_historiesCountAggregateOutputType> | number
          }
        }
      }
      Payments: {
        payload: Prisma.$PaymentsPayload<ExtArgs>
        fields: Prisma.PaymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findFirst: {
            args: Prisma.PaymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          findMany: {
            args: Prisma.PaymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          create: {
            args: Prisma.PaymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          createMany: {
            args: Prisma.PaymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          delete: {
            args: Prisma.PaymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          update: {
            args: Prisma.PaymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>[]
          }
          upsert: {
            args: Prisma.PaymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.PaymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      Couriers: {
        payload: Prisma.$CouriersPayload<ExtArgs>
        fields: Prisma.CouriersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouriersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouriersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>
          }
          findFirst: {
            args: Prisma.CouriersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouriersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>
          }
          findMany: {
            args: Prisma.CouriersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>[]
          }
          create: {
            args: Prisma.CouriersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>
          }
          createMany: {
            args: Prisma.CouriersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouriersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>[]
          }
          delete: {
            args: Prisma.CouriersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>
          }
          update: {
            args: Prisma.CouriersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>
          }
          deleteMany: {
            args: Prisma.CouriersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouriersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouriersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>[]
          }
          upsert: {
            args: Prisma.CouriersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouriersPayload>
          }
          aggregate: {
            args: Prisma.CouriersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouriers>
          }
          groupBy: {
            args: Prisma.CouriersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouriersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouriersCountArgs<ExtArgs>
            result: $Utils.Optional<CouriersCountAggregateOutputType> | number
          }
        }
      }
      Decoration: {
        payload: Prisma.$DecorationPayload<ExtArgs>
        fields: Prisma.DecorationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecorationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecorationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          findFirst: {
            args: Prisma.DecorationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecorationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          findMany: {
            args: Prisma.DecorationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>[]
          }
          create: {
            args: Prisma.DecorationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          createMany: {
            args: Prisma.DecorationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecorationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>[]
          }
          delete: {
            args: Prisma.DecorationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          update: {
            args: Prisma.DecorationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          deleteMany: {
            args: Prisma.DecorationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecorationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DecorationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>[]
          }
          upsert: {
            args: Prisma.DecorationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          aggregate: {
            args: Prisma.DecorationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecoration>
          }
          groupBy: {
            args: Prisma.DecorationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecorationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecorationCountArgs<ExtArgs>
            result: $Utils.Optional<DecorationCountAggregateOutputType> | number
          }
        }
      }
      Stores_on_decorations: {
        payload: Prisma.$Stores_on_decorationsPayload<ExtArgs>
        fields: Prisma.Stores_on_decorationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Stores_on_decorationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Stores_on_decorationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>
          }
          findFirst: {
            args: Prisma.Stores_on_decorationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Stores_on_decorationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>
          }
          findMany: {
            args: Prisma.Stores_on_decorationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>[]
          }
          create: {
            args: Prisma.Stores_on_decorationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>
          }
          createMany: {
            args: Prisma.Stores_on_decorationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Stores_on_decorationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>[]
          }
          delete: {
            args: Prisma.Stores_on_decorationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>
          }
          update: {
            args: Prisma.Stores_on_decorationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>
          }
          deleteMany: {
            args: Prisma.Stores_on_decorationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Stores_on_decorationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Stores_on_decorationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>[]
          }
          upsert: {
            args: Prisma.Stores_on_decorationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Stores_on_decorationsPayload>
          }
          aggregate: {
            args: Prisma.Stores_on_decorationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores_on_decorations>
          }
          groupBy: {
            args: Prisma.Stores_on_decorationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Stores_on_decorationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Stores_on_decorationsCountArgs<ExtArgs>
            result: $Utils.Optional<Stores_on_decorationsCountAggregateOutputType> | number
          }
        }
      }
      Operation_hours: {
        payload: Prisma.$Operation_hoursPayload<ExtArgs>
        fields: Prisma.Operation_hoursFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Operation_hoursFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Operation_hoursFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>
          }
          findFirst: {
            args: Prisma.Operation_hoursFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Operation_hoursFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>
          }
          findMany: {
            args: Prisma.Operation_hoursFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>[]
          }
          create: {
            args: Prisma.Operation_hoursCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>
          }
          createMany: {
            args: Prisma.Operation_hoursCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Operation_hoursCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>[]
          }
          delete: {
            args: Prisma.Operation_hoursDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>
          }
          update: {
            args: Prisma.Operation_hoursUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>
          }
          deleteMany: {
            args: Prisma.Operation_hoursDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Operation_hoursUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Operation_hoursUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>[]
          }
          upsert: {
            args: Prisma.Operation_hoursUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Operation_hoursPayload>
          }
          aggregate: {
            args: Prisma.Operation_hoursAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperation_hours>
          }
          groupBy: {
            args: Prisma.Operation_hoursGroupByArgs<ExtArgs>
            result: $Utils.Optional<Operation_hoursGroupByOutputType>[]
          }
          count: {
            args: Prisma.Operation_hoursCountArgs<ExtArgs>
            result: $Utils.Optional<Operation_hoursCountAggregateOutputType> | number
          }
        }
      }
      Message_templates: {
        payload: Prisma.$Message_templatesPayload<ExtArgs>
        fields: Prisma.Message_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Message_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Message_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>
          }
          findFirst: {
            args: Prisma.Message_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Message_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>
          }
          findMany: {
            args: Prisma.Message_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>[]
          }
          create: {
            args: Prisma.Message_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>
          }
          createMany: {
            args: Prisma.Message_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Message_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>[]
          }
          delete: {
            args: Prisma.Message_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>
          }
          update: {
            args: Prisma.Message_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>
          }
          deleteMany: {
            args: Prisma.Message_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Message_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Message_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>[]
          }
          upsert: {
            args: Prisma.Message_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Message_templatesPayload>
          }
          aggregate: {
            args: Prisma.Message_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage_templates>
          }
          groupBy: {
            args: Prisma.Message_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Message_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Message_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Message_templatesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profiles?: ProfilesOmit
    roles?: RolesOmit
    product?: ProductOmit
    stores?: StoresOmit
    bank_accounts?: bank_accountsOmit
    location?: LocationOmit
    variant_option_values?: Variant_option_valuesOmit
    variant_options?: Variant_optionsOmit
    variants?: VariantsOmit
    categories?: CategoriesOmit
    carts?: CartsOmit
    cart_items?: Cart_itemsOmit
    invoices?: InvoicesOmit
    confirmation_payment?: Confirmation_paymentOmit
    invoice_histories?: Invoice_historiesOmit
    payments?: PaymentsOmit
    couriers?: CouriersOmit
    decoration?: DecorationOmit
    stores_on_decorations?: Stores_on_decorationsOmit
    operation_hours?: Operation_hoursOmit
    message_templates?: Message_templatesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Carts: number
    Cart_items: number
    Invoices: number
    Payments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Carts?: boolean | UserCountOutputTypeCountCartsArgs
    Cart_items?: boolean | UserCountOutputTypeCountCart_itemsArgs
    Invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    Payments?: boolean | UserCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Cart_itemsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
  }


  /**
   * Count Type ProfilesCountOutputType
   */

  export type ProfilesCountOutputType = {
    User: number
  }

  export type ProfilesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProfilesCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * ProfilesCountOutputType without action
   */
  export type ProfilesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfilesCountOutputType
     */
    select?: ProfilesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfilesCountOutputType without action
   */
  export type ProfilesCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    User: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | RolesCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    Categories: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
  }


  /**
   * Count Type StoresCountOutputType
   */

  export type StoresCountOutputType = {
    Product: number
    bank_accounts: number
    Location: number
    Carts: number
    Cart_items: number
    Stores_on_decorations: number
    Operation_hours: number
    Message_templates: number
  }

  export type StoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | StoresCountOutputTypeCountProductArgs
    bank_accounts?: boolean | StoresCountOutputTypeCountBank_accountsArgs
    Location?: boolean | StoresCountOutputTypeCountLocationArgs
    Carts?: boolean | StoresCountOutputTypeCountCartsArgs
    Cart_items?: boolean | StoresCountOutputTypeCountCart_itemsArgs
    Stores_on_decorations?: boolean | StoresCountOutputTypeCountStores_on_decorationsArgs
    Operation_hours?: boolean | StoresCountOutputTypeCountOperation_hoursArgs
    Message_templates?: boolean | StoresCountOutputTypeCountMessage_templatesArgs
  }

  // Custom InputTypes
  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountBank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_accountsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Cart_itemsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountStores_on_decorationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Stores_on_decorationsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountOperation_hoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Operation_hoursWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountMessage_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Message_templatesWhereInput
  }


  /**
   * Count Type Variant_option_valuesCountOutputType
   */

  export type Variant_option_valuesCountOutputType = {
    Cart_items: number
  }

  export type Variant_option_valuesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cart_items?: boolean | Variant_option_valuesCountOutputTypeCountCart_itemsArgs
  }

  // Custom InputTypes
  /**
   * Variant_option_valuesCountOutputType without action
   */
  export type Variant_option_valuesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_valuesCountOutputType
     */
    select?: Variant_option_valuesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Variant_option_valuesCountOutputType without action
   */
  export type Variant_option_valuesCountOutputTypeCountCart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Cart_itemsWhereInput
  }


  /**
   * Count Type Variant_optionsCountOutputType
   */

  export type Variant_optionsCountOutputType = {
    Variant_option_values: number
  }

  export type Variant_optionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Variant_option_values?: boolean | Variant_optionsCountOutputTypeCountVariant_option_valuesArgs
  }

  // Custom InputTypes
  /**
   * Variant_optionsCountOutputType without action
   */
  export type Variant_optionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_optionsCountOutputType
     */
    select?: Variant_optionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Variant_optionsCountOutputType without action
   */
  export type Variant_optionsCountOutputTypeCountVariant_option_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Variant_option_valuesWhereInput
  }


  /**
   * Count Type VariantsCountOutputType
   */

  export type VariantsCountOutputType = {
    Variant_options: number
  }

  export type VariantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Variant_options?: boolean | VariantsCountOutputTypeCountVariant_optionsArgs
  }

  // Custom InputTypes
  /**
   * VariantsCountOutputType without action
   */
  export type VariantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantsCountOutputType
     */
    select?: VariantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariantsCountOutputType without action
   */
  export type VariantsCountOutputTypeCountVariant_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Variant_optionsWhereInput
  }


  /**
   * Count Type CartsCountOutputType
   */

  export type CartsCountOutputType = {
    Cart_items: number
    Invoices: number
  }

  export type CartsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Cart_items?: boolean | CartsCountOutputTypeCountCart_itemsArgs
    Invoices?: boolean | CartsCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * CartsCountOutputType without action
   */
  export type CartsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartsCountOutputType
     */
    select?: CartsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartsCountOutputType without action
   */
  export type CartsCountOutputTypeCountCart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Cart_itemsWhereInput
  }

  /**
   * CartsCountOutputType without action
   */
  export type CartsCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicesWhereInput
  }


  /**
   * Count Type InvoicesCountOutputType
   */

  export type InvoicesCountOutputType = {
    Confirmation_payment: number
    Invoice_histories: number
  }

  export type InvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Confirmation_payment?: boolean | InvoicesCountOutputTypeCountConfirmation_paymentArgs
    Invoice_histories?: boolean | InvoicesCountOutputTypeCountInvoice_historiesArgs
  }

  // Custom InputTypes
  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     */
    select?: InvoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountConfirmation_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Confirmation_paymentWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountInvoice_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Invoice_historiesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone_number: string | null
    fullname: string | null
    password: string | null
    profilesId: string | null
    rolesId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone_number: string | null
    fullname: string | null
    password: string | null
    profilesId: string | null
    rolesId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone_number: number
    fullname: number
    password: number
    profilesId: number
    rolesId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone_number?: true
    fullname?: true
    password?: true
    profilesId?: true
    rolesId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone_number?: true
    fullname?: true
    password?: true
    profilesId?: true
    rolesId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone_number?: true
    fullname?: true
    password?: true
    profilesId?: true
    rolesId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId: string | null
    rolesId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone_number?: boolean
    fullname?: boolean
    password?: boolean
    profilesId?: boolean
    rolesId?: boolean
    profile_id?: boolean | User$profile_idArgs<ExtArgs>
    role_id?: boolean | User$role_idArgs<ExtArgs>
    Carts?: boolean | User$CartsArgs<ExtArgs>
    Cart_items?: boolean | User$Cart_itemsArgs<ExtArgs>
    Invoices?: boolean | User$InvoicesArgs<ExtArgs>
    Payments?: boolean | User$PaymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone_number?: boolean
    fullname?: boolean
    password?: boolean
    profilesId?: boolean
    rolesId?: boolean
    profile_id?: boolean | User$profile_idArgs<ExtArgs>
    role_id?: boolean | User$role_idArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone_number?: boolean
    fullname?: boolean
    password?: boolean
    profilesId?: boolean
    rolesId?: boolean
    profile_id?: boolean | User$profile_idArgs<ExtArgs>
    role_id?: boolean | User$role_idArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone_number?: boolean
    fullname?: boolean
    password?: boolean
    profilesId?: boolean
    rolesId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone_number" | "fullname" | "password" | "profilesId" | "rolesId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile_id?: boolean | User$profile_idArgs<ExtArgs>
    role_id?: boolean | User$role_idArgs<ExtArgs>
    Carts?: boolean | User$CartsArgs<ExtArgs>
    Cart_items?: boolean | User$Cart_itemsArgs<ExtArgs>
    Invoices?: boolean | User$InvoicesArgs<ExtArgs>
    Payments?: boolean | User$PaymentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile_id?: boolean | User$profile_idArgs<ExtArgs>
    role_id?: boolean | User$role_idArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile_id?: boolean | User$profile_idArgs<ExtArgs>
    role_id?: boolean | User$role_idArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile_id: Prisma.$ProfilesPayload<ExtArgs> | null
      role_id: Prisma.$RolesPayload<ExtArgs> | null
      Carts: Prisma.$CartsPayload<ExtArgs>[]
      Cart_items: Prisma.$Cart_itemsPayload<ExtArgs>[]
      Invoices: Prisma.$InvoicesPayload<ExtArgs>[]
      Payments: Prisma.$PaymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      phone_number: string
      fullname: string
      password: string
      profilesId: string | null
      rolesId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile_id<T extends User$profile_idArgs<ExtArgs> = {}>(args?: Subset<T, User$profile_idArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    role_id<T extends User$role_idArgs<ExtArgs> = {}>(args?: Subset<T, User$role_idArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Carts<T extends User$CartsArgs<ExtArgs> = {}>(args?: Subset<T, User$CartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Cart_items<T extends User$Cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, User$Cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Invoices<T extends User$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$InvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Payments<T extends User$PaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$PaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly profilesId: FieldRef<"User", 'String'>
    readonly rolesId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile_id
   */
  export type User$profile_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    where?: ProfilesWhereInput
  }

  /**
   * User.role_id
   */
  export type User$role_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    where?: RolesWhereInput
  }

  /**
   * User.Carts
   */
  export type User$CartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    where?: CartsWhereInput
    orderBy?: CartsOrderByWithRelationInput | CartsOrderByWithRelationInput[]
    cursor?: CartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartsScalarFieldEnum | CartsScalarFieldEnum[]
  }

  /**
   * User.Cart_items
   */
  export type User$Cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    where?: Cart_itemsWhereInput
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    cursor?: Cart_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * User.Invoices
   */
  export type User$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    where?: InvoicesWhereInput
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    cursor?: InvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * User.Payments
   */
  export type User$PaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    cursor?: PaymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profiles
   */

  export type AggregateProfiles = {
    _count: ProfilesCountAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  export type ProfilesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    locationId: string | null
  }

  export type ProfilesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    locationId: string | null
  }

  export type ProfilesCountAggregateOutputType = {
    id: number
    user_id: number
    locationId: number
    _all: number
  }


  export type ProfilesMinAggregateInputType = {
    id?: true
    user_id?: true
    locationId?: true
  }

  export type ProfilesMaxAggregateInputType = {
    id?: true
    user_id?: true
    locationId?: true
  }

  export type ProfilesCountAggregateInputType = {
    id?: true
    user_id?: true
    locationId?: true
    _all?: true
  }

  export type ProfilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to aggregate.
     */
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfilesOrderByWithRelationInput | ProfilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfilesMaxAggregateInputType
  }

  export type GetProfilesAggregateType<T extends ProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfiles[P]>
      : GetScalarType<T[P], AggregateProfiles[P]>
  }




  export type ProfilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfilesWhereInput
    orderBy?: ProfilesOrderByWithAggregationInput | ProfilesOrderByWithAggregationInput[]
    by: ProfilesScalarFieldEnum[] | ProfilesScalarFieldEnum
    having?: ProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfilesCountAggregateInputType | true
    _min?: ProfilesMinAggregateInputType
    _max?: ProfilesMaxAggregateInputType
  }

  export type ProfilesGroupByOutputType = {
    id: string
    user_id: string | null
    locationId: string
    _count: ProfilesCountAggregateOutputType | null
    _min: ProfilesMinAggregateOutputType | null
    _max: ProfilesMaxAggregateOutputType | null
  }

  type GetProfilesGroupByPayload<T extends ProfilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], ProfilesGroupByOutputType[P]>
        }
      >
    >


  export type ProfilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    locationId?: boolean
    locations?: boolean | LocationDefaultArgs<ExtArgs>
    User?: boolean | Profiles$UserArgs<ExtArgs>
    _count?: boolean | ProfilesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profiles"]>

  export type ProfilesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    locationId?: boolean
    locations?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profiles"]>

  export type ProfilesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    locationId?: boolean
    locations?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profiles"]>

  export type ProfilesSelectScalar = {
    id?: boolean
    user_id?: boolean
    locationId?: boolean
  }

  export type ProfilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "locationId", ExtArgs["result"]["profiles"]>
  export type ProfilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | LocationDefaultArgs<ExtArgs>
    User?: boolean | Profiles$UserArgs<ExtArgs>
    _count?: boolean | ProfilesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfilesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ProfilesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ProfilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profiles"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      locationId: string
    }, ExtArgs["result"]["profiles"]>
    composites: {}
  }

  type ProfilesGetPayload<S extends boolean | null | undefined | ProfilesDefaultArgs> = $Result.GetResult<Prisma.$ProfilesPayload, S>

  type ProfilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfilesCountAggregateInputType | true
    }

  export interface ProfilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profiles'], meta: { name: 'Profiles' } }
    /**
     * Find zero or one Profiles that matches the filter.
     * @param {ProfilesFindUniqueArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfilesFindUniqueArgs>(args: SelectSubset<T, ProfilesFindUniqueArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Profiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfilesFindUniqueOrThrowArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfilesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesFindFirstArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfilesFindFirstArgs>(args?: SelectSubset<T, ProfilesFindFirstArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Profiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesFindFirstOrThrowArgs} args - Arguments to find a Profiles
     * @example
     * // Get one Profiles
     * const profiles = await prisma.profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfilesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profiles.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profilesWithIdOnly = await prisma.profiles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfilesFindManyArgs>(args?: SelectSubset<T, ProfilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Profiles.
     * @param {ProfilesCreateArgs} args - Arguments to create a Profiles.
     * @example
     * // Create one Profiles
     * const Profiles = await prisma.profiles.create({
     *   data: {
     *     // ... data to create a Profiles
     *   }
     * })
     * 
     */
    create<T extends ProfilesCreateArgs>(args: SelectSubset<T, ProfilesCreateArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Profiles.
     * @param {ProfilesCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profiles = await prisma.profiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfilesCreateManyArgs>(args?: SelectSubset<T, ProfilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfilesCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profiles = await prisma.profiles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profilesWithIdOnly = await prisma.profiles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfilesCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfilesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Profiles.
     * @param {ProfilesDeleteArgs} args - Arguments to delete one Profiles.
     * @example
     * // Delete one Profiles
     * const Profiles = await prisma.profiles.delete({
     *   where: {
     *     // ... filter to delete one Profiles
     *   }
     * })
     * 
     */
    delete<T extends ProfilesDeleteArgs>(args: SelectSubset<T, ProfilesDeleteArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Profiles.
     * @param {ProfilesUpdateArgs} args - Arguments to update one Profiles.
     * @example
     * // Update one Profiles
     * const profiles = await prisma.profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfilesUpdateArgs>(args: SelectSubset<T, ProfilesUpdateArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfilesDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfilesDeleteManyArgs>(args?: SelectSubset<T, ProfilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfilesUpdateManyArgs>(args: SelectSubset<T, ProfilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfilesUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profiles = await prisma.profiles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profilesWithIdOnly = await prisma.profiles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfilesUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfilesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Profiles.
     * @param {ProfilesUpsertArgs} args - Arguments to update or create a Profiles.
     * @example
     * // Update or create a Profiles
     * const profiles = await prisma.profiles.upsert({
     *   create: {
     *     // ... data to create a Profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profiles we want to update
     *   }
     * })
     */
    upsert<T extends ProfilesUpsertArgs>(args: SelectSubset<T, ProfilesUpsertArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profiles.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfilesCountArgs>(
      args?: Subset<T, ProfilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfilesAggregateArgs>(args: Subset<T, ProfilesAggregateArgs>): Prisma.PrismaPromise<GetProfilesAggregateType<T>>

    /**
     * Group by Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfilesGroupByArgs['orderBy'] }
        : { orderBy?: ProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profiles model
   */
  readonly fields: ProfilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends Profiles$UserArgs<ExtArgs> = {}>(args?: Subset<T, Profiles$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profiles model
   */ 
  interface ProfilesFieldRefs {
    readonly id: FieldRef<"Profiles", 'String'>
    readonly user_id: FieldRef<"Profiles", 'String'>
    readonly locationId: FieldRef<"Profiles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profiles findUnique
   */
  export type ProfilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where: ProfilesWhereUniqueInput
  }

  /**
   * Profiles findUniqueOrThrow
   */
  export type ProfilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where: ProfilesWhereUniqueInput
  }

  /**
   * Profiles findFirst
   */
  export type ProfilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfilesOrderByWithRelationInput | ProfilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * Profiles findFirstOrThrow
   */
  export type ProfilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfilesOrderByWithRelationInput | ProfilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * Profiles findMany
   */
  export type ProfilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfilesOrderByWithRelationInput | ProfilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfilesScalarFieldEnum | ProfilesScalarFieldEnum[]
  }

  /**
   * Profiles create
   */
  export type ProfilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * The data needed to create a Profiles.
     */
    data: XOR<ProfilesCreateInput, ProfilesUncheckedCreateInput>
  }

  /**
   * Profiles createMany
   */
  export type ProfilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfilesCreateManyInput | ProfilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profiles createManyAndReturn
   */
  export type ProfilesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfilesCreateManyInput | ProfilesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profiles update
   */
  export type ProfilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * The data needed to update a Profiles.
     */
    data: XOR<ProfilesUpdateInput, ProfilesUncheckedUpdateInput>
    /**
     * Choose, which Profiles to update.
     */
    where: ProfilesWhereUniqueInput
  }

  /**
   * Profiles updateMany
   */
  export type ProfilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfilesUpdateManyMutationInput, ProfilesUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfilesWhereInput
  }

  /**
   * Profiles updateManyAndReturn
   */
  export type ProfilesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfilesUpdateManyMutationInput, ProfilesUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfilesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profiles upsert
   */
  export type ProfilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * The filter to search for the Profiles to update in case it exists.
     */
    where: ProfilesWhereUniqueInput
    /**
     * In case the Profiles found by the `where` argument doesn't exist, create a new Profiles with this data.
     */
    create: XOR<ProfilesCreateInput, ProfilesUncheckedCreateInput>
    /**
     * In case the Profiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfilesUpdateInput, ProfilesUncheckedUpdateInput>
  }

  /**
   * Profiles delete
   */
  export type ProfilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    /**
     * Filter which Profiles to delete.
     */
    where: ProfilesWhereUniqueInput
  }

  /**
   * Profiles deleteMany
   */
  export type ProfilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfilesWhereInput
  }

  /**
   * Profiles.User
   */
  export type Profiles$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Profiles without action
   */
  export type ProfilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: string
    name: string | null
    _count: RolesCountAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    User?: boolean | Roles$UserArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["roles"]>
  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Roles$UserArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Roles$UserArgs<ExtArgs> = {}>(args?: Subset<T, Roles$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */ 
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'String'>
    readonly name: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data?: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }

  /**
   * Roles updateManyAndReturn
   */
  export type RolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
  }

  /**
   * Roles.User
   */
  export type Roles$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    minimum_order: number | null
  }

  export type ProductSumAggregateOutputType = {
    minimum_order: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    attachments: string | null
    is_active: boolean | null
    size: string | null
    minimum_order: number | null
    storesId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    attachments: string | null
    is_active: boolean | null
    size: string | null
    minimum_order: number | null
    storesId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    attachments: number
    is_active: number
    size: number
    minimum_order: number
    storesId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    minimum_order?: true
  }

  export type ProductSumAggregateInputType = {
    minimum_order?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attachments?: true
    is_active?: true
    size?: true
    minimum_order?: true
    storesId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attachments?: true
    is_active?: true
    size?: true
    minimum_order?: true
    storesId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attachments?: true
    is_active?: true
    size?: true
    minimum_order?: true
    storesId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    attachments: string
    is_active: boolean | null
    size: string | null
    minimum_order: number | null
    storesId: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attachments?: boolean
    is_active?: boolean
    size?: boolean
    minimum_order?: boolean
    storesId?: boolean
    variants?: boolean | Product$variantsArgs<ExtArgs>
    store_id?: boolean | Product$store_idArgs<ExtArgs>
    Categories?: boolean | Product$CategoriesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attachments?: boolean
    is_active?: boolean
    size?: boolean
    minimum_order?: boolean
    storesId?: boolean
    store_id?: boolean | Product$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attachments?: boolean
    is_active?: boolean
    size?: boolean
    minimum_order?: boolean
    storesId?: boolean
    store_id?: boolean | Product$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    attachments?: boolean
    is_active?: boolean
    size?: boolean
    minimum_order?: boolean
    storesId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "attachments" | "is_active" | "size" | "minimum_order" | "storesId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | Product$variantsArgs<ExtArgs>
    store_id?: boolean | Product$store_idArgs<ExtArgs>
    Categories?: boolean | Product$CategoriesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | Product$store_idArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | Product$store_idArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      variants: Prisma.$VariantsPayload<ExtArgs> | null
      store_id: Prisma.$StoresPayload<ExtArgs> | null
      Categories: Prisma.$CategoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      attachments: string
      is_active: boolean | null
      size: string | null
      minimum_order: number | null
      storesId: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    store_id<T extends Product$store_idArgs<ExtArgs> = {}>(args?: Subset<T, Product$store_idArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Categories<T extends Product$CategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$CategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly attachments: FieldRef<"Product", 'String'>
    readonly is_active: FieldRef<"Product", 'Boolean'>
    readonly size: FieldRef<"Product", 'String'>
    readonly minimum_order: FieldRef<"Product", 'Int'>
    readonly storesId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    where?: VariantsWhereInput
  }

  /**
   * Product.store_id
   */
  export type Product$store_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * Product.Categories
   */
  export type Product$CategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    cursor?: CategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Stores
   */

  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresMinAggregateOutputType = {
    id: string | null
    name: string | null
    slogan: string | null
    description: string | null
    domain: string | null
    logo_attachment: string | null
    banner_attachment: string | null
  }

  export type StoresMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slogan: string | null
    description: string | null
    domain: string | null
    logo_attachment: string | null
    banner_attachment: string | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    name: number
    slogan: number
    description: number
    domain: number
    logo_attachment: number
    banner_attachment: number
    _all: number
  }


  export type StoresMinAggregateInputType = {
    id?: true
    name?: true
    slogan?: true
    description?: true
    domain?: true
    logo_attachment?: true
    banner_attachment?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    name?: true
    slogan?: true
    description?: true
    domain?: true
    logo_attachment?: true
    banner_attachment?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    name?: true
    slogan?: true
    description?: true
    domain?: true
    logo_attachment?: true
    banner_attachment?: true
    _all?: true
  }

  export type StoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to aggregate.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type StoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoresWhereInput
    orderBy?: StoresOrderByWithAggregationInput | StoresOrderByWithAggregationInput[]
    by: StoresScalarFieldEnum[] | StoresScalarFieldEnum
    having?: StoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }

  export type StoresGroupByOutputType = {
    id: string
    name: string
    slogan: string | null
    description: string | null
    domain: string | null
    logo_attachment: string | null
    banner_attachment: string | null
    _count: StoresCountAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends StoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type StoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slogan?: boolean
    description?: boolean
    domain?: boolean
    logo_attachment?: boolean
    banner_attachment?: boolean
    Product?: boolean | Stores$ProductArgs<ExtArgs>
    bank_accounts?: boolean | Stores$bank_accountsArgs<ExtArgs>
    Location?: boolean | Stores$LocationArgs<ExtArgs>
    Carts?: boolean | Stores$CartsArgs<ExtArgs>
    Cart_items?: boolean | Stores$Cart_itemsArgs<ExtArgs>
    Stores_on_decorations?: boolean | Stores$Stores_on_decorationsArgs<ExtArgs>
    Operation_hours?: boolean | Stores$Operation_hoursArgs<ExtArgs>
    Message_templates?: boolean | Stores$Message_templatesArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>

  export type StoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slogan?: boolean
    description?: boolean
    domain?: boolean
    logo_attachment?: boolean
    banner_attachment?: boolean
  }, ExtArgs["result"]["stores"]>

  export type StoresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slogan?: boolean
    description?: boolean
    domain?: boolean
    logo_attachment?: boolean
    banner_attachment?: boolean
  }, ExtArgs["result"]["stores"]>

  export type StoresSelectScalar = {
    id?: boolean
    name?: boolean
    slogan?: boolean
    description?: boolean
    domain?: boolean
    logo_attachment?: boolean
    banner_attachment?: boolean
  }

  export type StoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slogan" | "description" | "domain" | "logo_attachment" | "banner_attachment", ExtArgs["result"]["stores"]>
  export type StoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Stores$ProductArgs<ExtArgs>
    bank_accounts?: boolean | Stores$bank_accountsArgs<ExtArgs>
    Location?: boolean | Stores$LocationArgs<ExtArgs>
    Carts?: boolean | Stores$CartsArgs<ExtArgs>
    Cart_items?: boolean | Stores$Cart_itemsArgs<ExtArgs>
    Stores_on_decorations?: boolean | Stores$Stores_on_decorationsArgs<ExtArgs>
    Operation_hours?: boolean | Stores$Operation_hoursArgs<ExtArgs>
    Message_templates?: boolean | Stores$Message_templatesArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StoresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stores"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>[]
      bank_accounts: Prisma.$bank_accountsPayload<ExtArgs>[]
      Location: Prisma.$LocationPayload<ExtArgs>[]
      Carts: Prisma.$CartsPayload<ExtArgs>[]
      Cart_items: Prisma.$Cart_itemsPayload<ExtArgs>[]
      Stores_on_decorations: Prisma.$Stores_on_decorationsPayload<ExtArgs>[]
      Operation_hours: Prisma.$Operation_hoursPayload<ExtArgs>[]
      Message_templates: Prisma.$Message_templatesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slogan: string | null
      description: string | null
      domain: string | null
      logo_attachment: string | null
      banner_attachment: string | null
    }, ExtArgs["result"]["stores"]>
    composites: {}
  }

  type StoresGetPayload<S extends boolean | null | undefined | StoresDefaultArgs> = $Result.GetResult<Prisma.$StoresPayload, S>

  type StoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface StoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stores'], meta: { name: 'Stores' } }
    /**
     * Find zero or one Stores that matches the filter.
     * @param {StoresFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoresFindUniqueArgs>(args: SelectSubset<T, StoresFindUniqueArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoresFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoresFindUniqueOrThrowArgs>(args: SelectSubset<T, StoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoresFindFirstArgs>(args?: SelectSubset<T, StoresFindFirstArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoresFindFirstOrThrowArgs>(args?: SelectSubset<T, StoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoresFindManyArgs>(args?: SelectSubset<T, StoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stores.
     * @param {StoresCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
     */
    create<T extends StoresCreateArgs>(args: SelectSubset<T, StoresCreateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stores.
     * @param {StoresCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoresCreateManyArgs>(args?: SelectSubset<T, StoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoresCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storesWithIdOnly = await prisma.stores.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoresCreateManyAndReturnArgs>(args?: SelectSubset<T, StoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stores.
     * @param {StoresDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
     */
    delete<T extends StoresDeleteArgs>(args: SelectSubset<T, StoresDeleteArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stores.
     * @param {StoresUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoresUpdateArgs>(args: SelectSubset<T, StoresUpdateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoresDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoresDeleteManyArgs>(args?: SelectSubset<T, StoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoresUpdateManyArgs>(args: SelectSubset<T, StoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoresUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storesWithIdOnly = await prisma.stores.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoresUpdateManyAndReturnArgs>(args: SelectSubset<T, StoresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Stores.
     * @param {StoresUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
     */
    upsert<T extends StoresUpsertArgs>(args: SelectSubset<T, StoresUpsertArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoresCountArgs>(
      args?: Subset<T, StoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoresGroupByArgs['orderBy'] }
        : { orderBy?: StoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stores model
   */
  readonly fields: StoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Stores$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Stores$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    bank_accounts<T extends Stores$bank_accountsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$bank_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Location<T extends Stores$LocationArgs<ExtArgs> = {}>(args?: Subset<T, Stores$LocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Carts<T extends Stores$CartsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$CartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Cart_items<T extends Stores$Cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$Cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Stores_on_decorations<T extends Stores$Stores_on_decorationsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$Stores_on_decorationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Operation_hours<T extends Stores$Operation_hoursArgs<ExtArgs> = {}>(args?: Subset<T, Stores$Operation_hoursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Message_templates<T extends Stores$Message_templatesArgs<ExtArgs> = {}>(args?: Subset<T, Stores$Message_templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stores model
   */ 
  interface StoresFieldRefs {
    readonly id: FieldRef<"Stores", 'String'>
    readonly name: FieldRef<"Stores", 'String'>
    readonly slogan: FieldRef<"Stores", 'String'>
    readonly description: FieldRef<"Stores", 'String'>
    readonly domain: FieldRef<"Stores", 'String'>
    readonly logo_attachment: FieldRef<"Stores", 'String'>
    readonly banner_attachment: FieldRef<"Stores", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Stores findUnique
   */
  export type StoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findUniqueOrThrow
   */
  export type StoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findFirst
   */
  export type StoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findFirstOrThrow
   */
  export type StoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findMany
   */
  export type StoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores create
   */
  export type StoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Stores.
     */
    data: XOR<StoresCreateInput, StoresUncheckedCreateInput>
  }

  /**
   * Stores createMany
   */
  export type StoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoresCreateManyInput | StoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores createManyAndReturn
   */
  export type StoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoresCreateManyInput | StoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores update
   */
  export type StoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Stores.
     */
    data: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
    /**
     * Choose, which Stores to update.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores updateMany
   */
  export type StoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoresUpdateManyMutationInput, StoresUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoresWhereInput
  }

  /**
   * Stores updateManyAndReturn
   */
  export type StoresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoresUpdateManyMutationInput, StoresUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoresWhereInput
  }

  /**
   * Stores upsert
   */
  export type StoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Stores to update in case it exists.
     */
    where: StoresWhereUniqueInput
    /**
     * In case the Stores found by the `where` argument doesn't exist, create a new Stores with this data.
     */
    create: XOR<StoresCreateInput, StoresUncheckedCreateInput>
    /**
     * In case the Stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
  }

  /**
   * Stores delete
   */
  export type StoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter which Stores to delete.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores deleteMany
   */
  export type StoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoresWhereInput
  }

  /**
   * Stores.Product
   */
  export type Stores$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Stores.bank_accounts
   */
  export type Stores$bank_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    where?: bank_accountsWhereInput
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    cursor?: bank_accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * Stores.Location
   */
  export type Stores$LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Stores.Carts
   */
  export type Stores$CartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    where?: CartsWhereInput
    orderBy?: CartsOrderByWithRelationInput | CartsOrderByWithRelationInput[]
    cursor?: CartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartsScalarFieldEnum | CartsScalarFieldEnum[]
  }

  /**
   * Stores.Cart_items
   */
  export type Stores$Cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    where?: Cart_itemsWhereInput
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    cursor?: Cart_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * Stores.Stores_on_decorations
   */
  export type Stores$Stores_on_decorationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    where?: Stores_on_decorationsWhereInput
    orderBy?: Stores_on_decorationsOrderByWithRelationInput | Stores_on_decorationsOrderByWithRelationInput[]
    cursor?: Stores_on_decorationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Stores_on_decorationsScalarFieldEnum | Stores_on_decorationsScalarFieldEnum[]
  }

  /**
   * Stores.Operation_hours
   */
  export type Stores$Operation_hoursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    where?: Operation_hoursWhereInput
    orderBy?: Operation_hoursOrderByWithRelationInput | Operation_hoursOrderByWithRelationInput[]
    cursor?: Operation_hoursWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Operation_hoursScalarFieldEnum | Operation_hoursScalarFieldEnum[]
  }

  /**
   * Stores.Message_templates
   */
  export type Stores$Message_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    where?: Message_templatesWhereInput
    orderBy?: Message_templatesOrderByWithRelationInput | Message_templatesOrderByWithRelationInput[]
    cursor?: Message_templatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Message_templatesScalarFieldEnum | Message_templatesScalarFieldEnum[]
  }

  /**
   * Stores without action
   */
  export type StoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
  }


  /**
   * Model bank_accounts
   */

  export type AggregateBank_accounts = {
    _count: Bank_accountsCountAggregateOutputType | null
    _min: Bank_accountsMinAggregateOutputType | null
    _max: Bank_accountsMaxAggregateOutputType | null
  }

  export type Bank_accountsMinAggregateOutputType = {
    id: string | null
    bank: string | null
    acc_number: string | null
    acc_name: string | null
    storesId: string | null
  }

  export type Bank_accountsMaxAggregateOutputType = {
    id: string | null
    bank: string | null
    acc_number: string | null
    acc_name: string | null
    storesId: string | null
  }

  export type Bank_accountsCountAggregateOutputType = {
    id: number
    bank: number
    acc_number: number
    acc_name: number
    storesId: number
    _all: number
  }


  export type Bank_accountsMinAggregateInputType = {
    id?: true
    bank?: true
    acc_number?: true
    acc_name?: true
    storesId?: true
  }

  export type Bank_accountsMaxAggregateInputType = {
    id?: true
    bank?: true
    acc_number?: true
    acc_name?: true
    storesId?: true
  }

  export type Bank_accountsCountAggregateInputType = {
    id?: true
    bank?: true
    acc_number?: true
    acc_name?: true
    storesId?: true
    _all?: true
  }

  export type Bank_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_accounts to aggregate.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bank_accounts
    **/
    _count?: true | Bank_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bank_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bank_accountsMaxAggregateInputType
  }

  export type GetBank_accountsAggregateType<T extends Bank_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateBank_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank_accounts[P]>
      : GetScalarType<T[P], AggregateBank_accounts[P]>
  }




  export type bank_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_accountsWhereInput
    orderBy?: bank_accountsOrderByWithAggregationInput | bank_accountsOrderByWithAggregationInput[]
    by: Bank_accountsScalarFieldEnum[] | Bank_accountsScalarFieldEnum
    having?: bank_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bank_accountsCountAggregateInputType | true
    _min?: Bank_accountsMinAggregateInputType
    _max?: Bank_accountsMaxAggregateInputType
  }

  export type Bank_accountsGroupByOutputType = {
    id: string
    bank: string
    acc_number: string
    acc_name: string
    storesId: string | null
    _count: Bank_accountsCountAggregateOutputType | null
    _min: Bank_accountsMinAggregateOutputType | null
    _max: Bank_accountsMaxAggregateOutputType | null
  }

  type GetBank_accountsGroupByPayload<T extends bank_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bank_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bank_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bank_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Bank_accountsGroupByOutputType[P]>
        }
      >
    >


  export type bank_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank?: boolean
    acc_number?: boolean
    acc_name?: boolean
    storesId?: boolean
    store_id?: boolean | bank_accounts$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["bank_accounts"]>

  export type bank_accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank?: boolean
    acc_number?: boolean
    acc_name?: boolean
    storesId?: boolean
    store_id?: boolean | bank_accounts$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["bank_accounts"]>

  export type bank_accountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank?: boolean
    acc_number?: boolean
    acc_name?: boolean
    storesId?: boolean
    store_id?: boolean | bank_accounts$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["bank_accounts"]>

  export type bank_accountsSelectScalar = {
    id?: boolean
    bank?: boolean
    acc_number?: boolean
    acc_name?: boolean
    storesId?: boolean
  }

  export type bank_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bank" | "acc_number" | "acc_name" | "storesId", ExtArgs["result"]["bank_accounts"]>
  export type bank_accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | bank_accounts$store_idArgs<ExtArgs>
  }
  export type bank_accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | bank_accounts$store_idArgs<ExtArgs>
  }
  export type bank_accountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | bank_accounts$store_idArgs<ExtArgs>
  }

  export type $bank_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank_accounts"
    objects: {
      store_id: Prisma.$StoresPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bank: string
      acc_number: string
      acc_name: string
      storesId: string | null
    }, ExtArgs["result"]["bank_accounts"]>
    composites: {}
  }

  type bank_accountsGetPayload<S extends boolean | null | undefined | bank_accountsDefaultArgs> = $Result.GetResult<Prisma.$bank_accountsPayload, S>

  type bank_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bank_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bank_accountsCountAggregateInputType | true
    }

  export interface bank_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank_accounts'], meta: { name: 'bank_accounts' } }
    /**
     * Find zero or one Bank_accounts that matches the filter.
     * @param {bank_accountsFindUniqueArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bank_accountsFindUniqueArgs>(args: SelectSubset<T, bank_accountsFindUniqueArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Bank_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bank_accountsFindUniqueOrThrowArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bank_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, bank_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Bank_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsFindFirstArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bank_accountsFindFirstArgs>(args?: SelectSubset<T, bank_accountsFindFirstArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Bank_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsFindFirstOrThrowArgs} args - Arguments to find a Bank_accounts
     * @example
     * // Get one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bank_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, bank_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Bank_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findMany()
     * 
     * // Get first 10 Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bank_accountsWithIdOnly = await prisma.bank_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bank_accountsFindManyArgs>(args?: SelectSubset<T, bank_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Bank_accounts.
     * @param {bank_accountsCreateArgs} args - Arguments to create a Bank_accounts.
     * @example
     * // Create one Bank_accounts
     * const Bank_accounts = await prisma.bank_accounts.create({
     *   data: {
     *     // ... data to create a Bank_accounts
     *   }
     * })
     * 
     */
    create<T extends bank_accountsCreateArgs>(args: SelectSubset<T, bank_accountsCreateArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Bank_accounts.
     * @param {bank_accountsCreateManyArgs} args - Arguments to create many Bank_accounts.
     * @example
     * // Create many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bank_accountsCreateManyArgs>(args?: SelectSubset<T, bank_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bank_accounts and returns the data saved in the database.
     * @param {bank_accountsCreateManyAndReturnArgs} args - Arguments to create many Bank_accounts.
     * @example
     * // Create many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bank_accounts and only return the `id`
     * const bank_accountsWithIdOnly = await prisma.bank_accounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bank_accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, bank_accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Bank_accounts.
     * @param {bank_accountsDeleteArgs} args - Arguments to delete one Bank_accounts.
     * @example
     * // Delete one Bank_accounts
     * const Bank_accounts = await prisma.bank_accounts.delete({
     *   where: {
     *     // ... filter to delete one Bank_accounts
     *   }
     * })
     * 
     */
    delete<T extends bank_accountsDeleteArgs>(args: SelectSubset<T, bank_accountsDeleteArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Bank_accounts.
     * @param {bank_accountsUpdateArgs} args - Arguments to update one Bank_accounts.
     * @example
     * // Update one Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bank_accountsUpdateArgs>(args: SelectSubset<T, bank_accountsUpdateArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Bank_accounts.
     * @param {bank_accountsDeleteManyArgs} args - Arguments to filter Bank_accounts to delete.
     * @example
     * // Delete a few Bank_accounts
     * const { count } = await prisma.bank_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bank_accountsDeleteManyArgs>(args?: SelectSubset<T, bank_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bank_accountsUpdateManyArgs>(args: SelectSubset<T, bank_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_accounts and returns the data updated in the database.
     * @param {bank_accountsUpdateManyAndReturnArgs} args - Arguments to update many Bank_accounts.
     * @example
     * // Update many Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bank_accounts and only return the `id`
     * const bank_accountsWithIdOnly = await prisma.bank_accounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bank_accountsUpdateManyAndReturnArgs>(args: SelectSubset<T, bank_accountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Bank_accounts.
     * @param {bank_accountsUpsertArgs} args - Arguments to update or create a Bank_accounts.
     * @example
     * // Update or create a Bank_accounts
     * const bank_accounts = await prisma.bank_accounts.upsert({
     *   create: {
     *     // ... data to create a Bank_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank_accounts we want to update
     *   }
     * })
     */
    upsert<T extends bank_accountsUpsertArgs>(args: SelectSubset<T, bank_accountsUpsertArgs<ExtArgs>>): Prisma__bank_accountsClient<$Result.GetResult<Prisma.$bank_accountsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsCountArgs} args - Arguments to filter Bank_accounts to count.
     * @example
     * // Count the number of Bank_accounts
     * const count = await prisma.bank_accounts.count({
     *   where: {
     *     // ... the filter for the Bank_accounts we want to count
     *   }
     * })
    **/
    count<T extends bank_accountsCountArgs>(
      args?: Subset<T, bank_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bank_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bank_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bank_accountsAggregateArgs>(args: Subset<T, Bank_accountsAggregateArgs>): Prisma.PrismaPromise<GetBank_accountsAggregateType<T>>

    /**
     * Group by Bank_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bank_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bank_accountsGroupByArgs['orderBy'] }
        : { orderBy?: bank_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bank_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBank_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank_accounts model
   */
  readonly fields: bank_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bank_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store_id<T extends bank_accounts$store_idArgs<ExtArgs> = {}>(args?: Subset<T, bank_accounts$store_idArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank_accounts model
   */ 
  interface bank_accountsFieldRefs {
    readonly id: FieldRef<"bank_accounts", 'String'>
    readonly bank: FieldRef<"bank_accounts", 'String'>
    readonly acc_number: FieldRef<"bank_accounts", 'String'>
    readonly acc_name: FieldRef<"bank_accounts", 'String'>
    readonly storesId: FieldRef<"bank_accounts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bank_accounts findUnique
   */
  export type bank_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts findUniqueOrThrow
   */
  export type bank_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts findFirst
   */
  export type bank_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_accounts.
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_accounts.
     */
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_accounts findFirstOrThrow
   */
  export type bank_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_accounts.
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_accounts.
     */
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_accounts findMany
   */
  export type bank_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter, which bank_accounts to fetch.
     */
    where?: bank_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_accounts to fetch.
     */
    orderBy?: bank_accountsOrderByWithRelationInput | bank_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bank_accounts.
     */
    cursor?: bank_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_accounts.
     */
    skip?: number
    distinct?: Bank_accountsScalarFieldEnum | Bank_accountsScalarFieldEnum[]
  }

  /**
   * bank_accounts create
   */
  export type bank_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a bank_accounts.
     */
    data: XOR<bank_accountsCreateInput, bank_accountsUncheckedCreateInput>
  }

  /**
   * bank_accounts createMany
   */
  export type bank_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bank_accounts.
     */
    data: bank_accountsCreateManyInput | bank_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank_accounts createManyAndReturn
   */
  export type bank_accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * The data used to create many bank_accounts.
     */
    data: bank_accountsCreateManyInput | bank_accountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_accounts update
   */
  export type bank_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a bank_accounts.
     */
    data: XOR<bank_accountsUpdateInput, bank_accountsUncheckedUpdateInput>
    /**
     * Choose, which bank_accounts to update.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts updateMany
   */
  export type bank_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bank_accounts.
     */
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyInput>
    /**
     * Filter which bank_accounts to update
     */
    where?: bank_accountsWhereInput
  }

  /**
   * bank_accounts updateManyAndReturn
   */
  export type bank_accountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * The data used to update bank_accounts.
     */
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyInput>
    /**
     * Filter which bank_accounts to update
     */
    where?: bank_accountsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank_accounts upsert
   */
  export type bank_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the bank_accounts to update in case it exists.
     */
    where: bank_accountsWhereUniqueInput
    /**
     * In case the bank_accounts found by the `where` argument doesn't exist, create a new bank_accounts with this data.
     */
    create: XOR<bank_accountsCreateInput, bank_accountsUncheckedCreateInput>
    /**
     * In case the bank_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bank_accountsUpdateInput, bank_accountsUncheckedUpdateInput>
  }

  /**
   * bank_accounts delete
   */
  export type bank_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
    /**
     * Filter which bank_accounts to delete.
     */
    where: bank_accountsWhereUniqueInput
  }

  /**
   * bank_accounts deleteMany
   */
  export type bank_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_accounts to delete
     */
    where?: bank_accountsWhereInput
  }

  /**
   * bank_accounts.store_id
   */
  export type bank_accounts$store_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * bank_accounts without action
   */
  export type bank_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_accounts
     */
    select?: bank_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank_accounts
     */
    omit?: bank_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bank_accountsInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    postal_code: string | null
    city_district: string | null
    is_main_location: boolean | null
    longitude: string | null
    latitude: string | null
    storesId: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    postal_code: string | null
    city_district: string | null
    is_main_location: boolean | null
    longitude: string | null
    latitude: string | null
    storesId: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    postal_code: number
    city_district: number
    is_main_location: number
    longitude: number
    latitude: number
    storesId: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    postal_code?: true
    city_district?: true
    is_main_location?: true
    longitude?: true
    latitude?: true
    storesId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    postal_code?: true
    city_district?: true
    is_main_location?: true
    longitude?: true
    latitude?: true
    storesId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    postal_code?: true
    city_district?: true
    is_main_location?: true
    longitude?: true
    latitude?: true
    storesId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location: boolean | null
    longitude: string
    latitude: string
    storesId: string | null
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    postal_code?: boolean
    city_district?: boolean
    is_main_location?: boolean
    longitude?: boolean
    latitude?: boolean
    storesId?: boolean
    store_id?: boolean | Location$store_idArgs<ExtArgs>
    profile_id?: boolean | Location$profile_idArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    postal_code?: boolean
    city_district?: boolean
    is_main_location?: boolean
    longitude?: boolean
    latitude?: boolean
    storesId?: boolean
    store_id?: boolean | Location$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    postal_code?: boolean
    city_district?: boolean
    is_main_location?: boolean
    longitude?: boolean
    latitude?: boolean
    storesId?: boolean
    store_id?: boolean | Location$store_idArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    postal_code?: boolean
    city_district?: boolean
    is_main_location?: boolean
    longitude?: boolean
    latitude?: boolean
    storesId?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "postal_code" | "city_district" | "is_main_location" | "longitude" | "latitude" | "storesId", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | Location$store_idArgs<ExtArgs>
    profile_id?: boolean | Location$profile_idArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | Location$store_idArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | Location$store_idArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      store_id: Prisma.$StoresPayload<ExtArgs> | null
      profile_id: Prisma.$ProfilesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      postal_code: string
      city_district: string
      is_main_location: boolean | null
      longitude: string
      latitude: string
      storesId: string | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store_id<T extends Location$store_idArgs<ExtArgs> = {}>(args?: Subset<T, Location$store_idArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    profile_id<T extends Location$profile_idArgs<ExtArgs> = {}>(args?: Subset<T, Location$profile_idArgs<ExtArgs>>): Prisma__ProfilesClient<$Result.GetResult<Prisma.$ProfilesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly postal_code: FieldRef<"Location", 'String'>
    readonly city_district: FieldRef<"Location", 'String'>
    readonly is_main_location: FieldRef<"Location", 'Boolean'>
    readonly longitude: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'String'>
    readonly storesId: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.store_id
   */
  export type Location$store_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores
     */
    omit?: StoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    where?: StoresWhereInput
  }

  /**
   * Location.profile_id
   */
  export type Location$profile_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profiles
     */
    select?: ProfilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profiles
     */
    omit?: ProfilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfilesInclude<ExtArgs> | null
    where?: ProfilesWhereInput
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Variant_option_values
   */

  export type AggregateVariant_option_values = {
    _count: Variant_option_valuesCountAggregateOutputType | null
    _avg: Variant_option_valuesAvgAggregateOutputType | null
    _sum: Variant_option_valuesSumAggregateOutputType | null
    _min: Variant_option_valuesMinAggregateOutputType | null
    _max: Variant_option_valuesMaxAggregateOutputType | null
  }

  export type Variant_option_valuesAvgAggregateOutputType = {
    stock: number | null
    price: number | null
  }

  export type Variant_option_valuesSumAggregateOutputType = {
    stock: number | null
    price: number | null
  }

  export type Variant_option_valuesMinAggregateOutputType = {
    id: string | null
    sku: string | null
    weight: string | null
    stock: number | null
    price: number | null
    is_active: boolean | null
    variant_optionsId: string | null
  }

  export type Variant_option_valuesMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    weight: string | null
    stock: number | null
    price: number | null
    is_active: boolean | null
    variant_optionsId: string | null
  }

  export type Variant_option_valuesCountAggregateOutputType = {
    id: number
    sku: number
    weight: number
    stock: number
    price: number
    is_active: number
    variant_optionsId: number
    _all: number
  }


  export type Variant_option_valuesAvgAggregateInputType = {
    stock?: true
    price?: true
  }

  export type Variant_option_valuesSumAggregateInputType = {
    stock?: true
    price?: true
  }

  export type Variant_option_valuesMinAggregateInputType = {
    id?: true
    sku?: true
    weight?: true
    stock?: true
    price?: true
    is_active?: true
    variant_optionsId?: true
  }

  export type Variant_option_valuesMaxAggregateInputType = {
    id?: true
    sku?: true
    weight?: true
    stock?: true
    price?: true
    is_active?: true
    variant_optionsId?: true
  }

  export type Variant_option_valuesCountAggregateInputType = {
    id?: true
    sku?: true
    weight?: true
    stock?: true
    price?: true
    is_active?: true
    variant_optionsId?: true
    _all?: true
  }

  export type Variant_option_valuesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant_option_values to aggregate.
     */
    where?: Variant_option_valuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_option_values to fetch.
     */
    orderBy?: Variant_option_valuesOrderByWithRelationInput | Variant_option_valuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Variant_option_valuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_option_values from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_option_values.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variant_option_values
    **/
    _count?: true | Variant_option_valuesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Variant_option_valuesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Variant_option_valuesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Variant_option_valuesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Variant_option_valuesMaxAggregateInputType
  }

  export type GetVariant_option_valuesAggregateType<T extends Variant_option_valuesAggregateArgs> = {
        [P in keyof T & keyof AggregateVariant_option_values]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariant_option_values[P]>
      : GetScalarType<T[P], AggregateVariant_option_values[P]>
  }




  export type Variant_option_valuesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Variant_option_valuesWhereInput
    orderBy?: Variant_option_valuesOrderByWithAggregationInput | Variant_option_valuesOrderByWithAggregationInput[]
    by: Variant_option_valuesScalarFieldEnum[] | Variant_option_valuesScalarFieldEnum
    having?: Variant_option_valuesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Variant_option_valuesCountAggregateInputType | true
    _avg?: Variant_option_valuesAvgAggregateInputType
    _sum?: Variant_option_valuesSumAggregateInputType
    _min?: Variant_option_valuesMinAggregateInputType
    _max?: Variant_option_valuesMaxAggregateInputType
  }

  export type Variant_option_valuesGroupByOutputType = {
    id: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active: boolean
    variant_optionsId: string
    _count: Variant_option_valuesCountAggregateOutputType | null
    _avg: Variant_option_valuesAvgAggregateOutputType | null
    _sum: Variant_option_valuesSumAggregateOutputType | null
    _min: Variant_option_valuesMinAggregateOutputType | null
    _max: Variant_option_valuesMaxAggregateOutputType | null
  }

  type GetVariant_option_valuesGroupByPayload<T extends Variant_option_valuesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Variant_option_valuesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Variant_option_valuesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Variant_option_valuesGroupByOutputType[P]>
            : GetScalarType<T[P], Variant_option_valuesGroupByOutputType[P]>
        }
      >
    >


  export type Variant_option_valuesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    weight?: boolean
    stock?: boolean
    price?: boolean
    is_active?: boolean
    variant_optionsId?: boolean
    variant_option_id?: boolean | Variant_optionsDefaultArgs<ExtArgs>
    Cart_items?: boolean | Variant_option_values$Cart_itemsArgs<ExtArgs>
    _count?: boolean | Variant_option_valuesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant_option_values"]>

  export type Variant_option_valuesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    weight?: boolean
    stock?: boolean
    price?: boolean
    is_active?: boolean
    variant_optionsId?: boolean
    variant_option_id?: boolean | Variant_optionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant_option_values"]>

  export type Variant_option_valuesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    weight?: boolean
    stock?: boolean
    price?: boolean
    is_active?: boolean
    variant_optionsId?: boolean
    variant_option_id?: boolean | Variant_optionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant_option_values"]>

  export type Variant_option_valuesSelectScalar = {
    id?: boolean
    sku?: boolean
    weight?: boolean
    stock?: boolean
    price?: boolean
    is_active?: boolean
    variant_optionsId?: boolean
  }

  export type Variant_option_valuesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sku" | "weight" | "stock" | "price" | "is_active" | "variant_optionsId", ExtArgs["result"]["variant_option_values"]>
  export type Variant_option_valuesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant_option_id?: boolean | Variant_optionsDefaultArgs<ExtArgs>
    Cart_items?: boolean | Variant_option_values$Cart_itemsArgs<ExtArgs>
    _count?: boolean | Variant_option_valuesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Variant_option_valuesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant_option_id?: boolean | Variant_optionsDefaultArgs<ExtArgs>
  }
  export type Variant_option_valuesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant_option_id?: boolean | Variant_optionsDefaultArgs<ExtArgs>
  }

  export type $Variant_option_valuesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variant_option_values"
    objects: {
      variant_option_id: Prisma.$Variant_optionsPayload<ExtArgs>
      Cart_items: Prisma.$Cart_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      weight: string
      stock: number
      price: number
      is_active: boolean
      variant_optionsId: string
    }, ExtArgs["result"]["variant_option_values"]>
    composites: {}
  }

  type Variant_option_valuesGetPayload<S extends boolean | null | undefined | Variant_option_valuesDefaultArgs> = $Result.GetResult<Prisma.$Variant_option_valuesPayload, S>

  type Variant_option_valuesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Variant_option_valuesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Variant_option_valuesCountAggregateInputType | true
    }

  export interface Variant_option_valuesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variant_option_values'], meta: { name: 'Variant_option_values' } }
    /**
     * Find zero or one Variant_option_values that matches the filter.
     * @param {Variant_option_valuesFindUniqueArgs} args - Arguments to find a Variant_option_values
     * @example
     * // Get one Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Variant_option_valuesFindUniqueArgs>(args: SelectSubset<T, Variant_option_valuesFindUniqueArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Variant_option_values that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Variant_option_valuesFindUniqueOrThrowArgs} args - Arguments to find a Variant_option_values
     * @example
     * // Get one Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Variant_option_valuesFindUniqueOrThrowArgs>(args: SelectSubset<T, Variant_option_valuesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Variant_option_values that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesFindFirstArgs} args - Arguments to find a Variant_option_values
     * @example
     * // Get one Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Variant_option_valuesFindFirstArgs>(args?: SelectSubset<T, Variant_option_valuesFindFirstArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Variant_option_values that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesFindFirstOrThrowArgs} args - Arguments to find a Variant_option_values
     * @example
     * // Get one Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Variant_option_valuesFindFirstOrThrowArgs>(args?: SelectSubset<T, Variant_option_valuesFindFirstOrThrowArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Variant_option_values that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.findMany()
     * 
     * // Get first 10 Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variant_option_valuesWithIdOnly = await prisma.variant_option_values.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Variant_option_valuesFindManyArgs>(args?: SelectSubset<T, Variant_option_valuesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Variant_option_values.
     * @param {Variant_option_valuesCreateArgs} args - Arguments to create a Variant_option_values.
     * @example
     * // Create one Variant_option_values
     * const Variant_option_values = await prisma.variant_option_values.create({
     *   data: {
     *     // ... data to create a Variant_option_values
     *   }
     * })
     * 
     */
    create<T extends Variant_option_valuesCreateArgs>(args: SelectSubset<T, Variant_option_valuesCreateArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Variant_option_values.
     * @param {Variant_option_valuesCreateManyArgs} args - Arguments to create many Variant_option_values.
     * @example
     * // Create many Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Variant_option_valuesCreateManyArgs>(args?: SelectSubset<T, Variant_option_valuesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variant_option_values and returns the data saved in the database.
     * @param {Variant_option_valuesCreateManyAndReturnArgs} args - Arguments to create many Variant_option_values.
     * @example
     * // Create many Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variant_option_values and only return the `id`
     * const variant_option_valuesWithIdOnly = await prisma.variant_option_values.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Variant_option_valuesCreateManyAndReturnArgs>(args?: SelectSubset<T, Variant_option_valuesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Variant_option_values.
     * @param {Variant_option_valuesDeleteArgs} args - Arguments to delete one Variant_option_values.
     * @example
     * // Delete one Variant_option_values
     * const Variant_option_values = await prisma.variant_option_values.delete({
     *   where: {
     *     // ... filter to delete one Variant_option_values
     *   }
     * })
     * 
     */
    delete<T extends Variant_option_valuesDeleteArgs>(args: SelectSubset<T, Variant_option_valuesDeleteArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Variant_option_values.
     * @param {Variant_option_valuesUpdateArgs} args - Arguments to update one Variant_option_values.
     * @example
     * // Update one Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Variant_option_valuesUpdateArgs>(args: SelectSubset<T, Variant_option_valuesUpdateArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Variant_option_values.
     * @param {Variant_option_valuesDeleteManyArgs} args - Arguments to filter Variant_option_values to delete.
     * @example
     * // Delete a few Variant_option_values
     * const { count } = await prisma.variant_option_values.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Variant_option_valuesDeleteManyArgs>(args?: SelectSubset<T, Variant_option_valuesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variant_option_values.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Variant_option_valuesUpdateManyArgs>(args: SelectSubset<T, Variant_option_valuesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variant_option_values and returns the data updated in the database.
     * @param {Variant_option_valuesUpdateManyAndReturnArgs} args - Arguments to update many Variant_option_values.
     * @example
     * // Update many Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variant_option_values and only return the `id`
     * const variant_option_valuesWithIdOnly = await prisma.variant_option_values.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Variant_option_valuesUpdateManyAndReturnArgs>(args: SelectSubset<T, Variant_option_valuesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Variant_option_values.
     * @param {Variant_option_valuesUpsertArgs} args - Arguments to update or create a Variant_option_values.
     * @example
     * // Update or create a Variant_option_values
     * const variant_option_values = await prisma.variant_option_values.upsert({
     *   create: {
     *     // ... data to create a Variant_option_values
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variant_option_values we want to update
     *   }
     * })
     */
    upsert<T extends Variant_option_valuesUpsertArgs>(args: SelectSubset<T, Variant_option_valuesUpsertArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Variant_option_values.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesCountArgs} args - Arguments to filter Variant_option_values to count.
     * @example
     * // Count the number of Variant_option_values
     * const count = await prisma.variant_option_values.count({
     *   where: {
     *     // ... the filter for the Variant_option_values we want to count
     *   }
     * })
    **/
    count<T extends Variant_option_valuesCountArgs>(
      args?: Subset<T, Variant_option_valuesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Variant_option_valuesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variant_option_values.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Variant_option_valuesAggregateArgs>(args: Subset<T, Variant_option_valuesAggregateArgs>): Prisma.PrismaPromise<GetVariant_option_valuesAggregateType<T>>

    /**
     * Group by Variant_option_values.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_option_valuesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Variant_option_valuesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Variant_option_valuesGroupByArgs['orderBy'] }
        : { orderBy?: Variant_option_valuesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Variant_option_valuesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariant_option_valuesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variant_option_values model
   */
  readonly fields: Variant_option_valuesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variant_option_values.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Variant_option_valuesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant_option_id<T extends Variant_optionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Variant_optionsDefaultArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Cart_items<T extends Variant_option_values$Cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Variant_option_values$Cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variant_option_values model
   */ 
  interface Variant_option_valuesFieldRefs {
    readonly id: FieldRef<"Variant_option_values", 'String'>
    readonly sku: FieldRef<"Variant_option_values", 'String'>
    readonly weight: FieldRef<"Variant_option_values", 'String'>
    readonly stock: FieldRef<"Variant_option_values", 'Int'>
    readonly price: FieldRef<"Variant_option_values", 'Int'>
    readonly is_active: FieldRef<"Variant_option_values", 'Boolean'>
    readonly variant_optionsId: FieldRef<"Variant_option_values", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Variant_option_values findUnique
   */
  export type Variant_option_valuesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * Filter, which Variant_option_values to fetch.
     */
    where: Variant_option_valuesWhereUniqueInput
  }

  /**
   * Variant_option_values findUniqueOrThrow
   */
  export type Variant_option_valuesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * Filter, which Variant_option_values to fetch.
     */
    where: Variant_option_valuesWhereUniqueInput
  }

  /**
   * Variant_option_values findFirst
   */
  export type Variant_option_valuesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * Filter, which Variant_option_values to fetch.
     */
    where?: Variant_option_valuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_option_values to fetch.
     */
    orderBy?: Variant_option_valuesOrderByWithRelationInput | Variant_option_valuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variant_option_values.
     */
    cursor?: Variant_option_valuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_option_values from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_option_values.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variant_option_values.
     */
    distinct?: Variant_option_valuesScalarFieldEnum | Variant_option_valuesScalarFieldEnum[]
  }

  /**
   * Variant_option_values findFirstOrThrow
   */
  export type Variant_option_valuesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * Filter, which Variant_option_values to fetch.
     */
    where?: Variant_option_valuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_option_values to fetch.
     */
    orderBy?: Variant_option_valuesOrderByWithRelationInput | Variant_option_valuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variant_option_values.
     */
    cursor?: Variant_option_valuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_option_values from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_option_values.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variant_option_values.
     */
    distinct?: Variant_option_valuesScalarFieldEnum | Variant_option_valuesScalarFieldEnum[]
  }

  /**
   * Variant_option_values findMany
   */
  export type Variant_option_valuesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * Filter, which Variant_option_values to fetch.
     */
    where?: Variant_option_valuesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_option_values to fetch.
     */
    orderBy?: Variant_option_valuesOrderByWithRelationInput | Variant_option_valuesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variant_option_values.
     */
    cursor?: Variant_option_valuesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_option_values from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_option_values.
     */
    skip?: number
    distinct?: Variant_option_valuesScalarFieldEnum | Variant_option_valuesScalarFieldEnum[]
  }

  /**
   * Variant_option_values create
   */
  export type Variant_option_valuesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * The data needed to create a Variant_option_values.
     */
    data: XOR<Variant_option_valuesCreateInput, Variant_option_valuesUncheckedCreateInput>
  }

  /**
   * Variant_option_values createMany
   */
  export type Variant_option_valuesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variant_option_values.
     */
    data: Variant_option_valuesCreateManyInput | Variant_option_valuesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variant_option_values createManyAndReturn
   */
  export type Variant_option_valuesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * The data used to create many Variant_option_values.
     */
    data: Variant_option_valuesCreateManyInput | Variant_option_valuesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant_option_values update
   */
  export type Variant_option_valuesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * The data needed to update a Variant_option_values.
     */
    data: XOR<Variant_option_valuesUpdateInput, Variant_option_valuesUncheckedUpdateInput>
    /**
     * Choose, which Variant_option_values to update.
     */
    where: Variant_option_valuesWhereUniqueInput
  }

  /**
   * Variant_option_values updateMany
   */
  export type Variant_option_valuesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variant_option_values.
     */
    data: XOR<Variant_option_valuesUpdateManyMutationInput, Variant_option_valuesUncheckedUpdateManyInput>
    /**
     * Filter which Variant_option_values to update
     */
    where?: Variant_option_valuesWhereInput
  }

  /**
   * Variant_option_values updateManyAndReturn
   */
  export type Variant_option_valuesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * The data used to update Variant_option_values.
     */
    data: XOR<Variant_option_valuesUpdateManyMutationInput, Variant_option_valuesUncheckedUpdateManyInput>
    /**
     * Filter which Variant_option_values to update
     */
    where?: Variant_option_valuesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant_option_values upsert
   */
  export type Variant_option_valuesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * The filter to search for the Variant_option_values to update in case it exists.
     */
    where: Variant_option_valuesWhereUniqueInput
    /**
     * In case the Variant_option_values found by the `where` argument doesn't exist, create a new Variant_option_values with this data.
     */
    create: XOR<Variant_option_valuesCreateInput, Variant_option_valuesUncheckedCreateInput>
    /**
     * In case the Variant_option_values was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Variant_option_valuesUpdateInput, Variant_option_valuesUncheckedUpdateInput>
  }

  /**
   * Variant_option_values delete
   */
  export type Variant_option_valuesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    /**
     * Filter which Variant_option_values to delete.
     */
    where: Variant_option_valuesWhereUniqueInput
  }

  /**
   * Variant_option_values deleteMany
   */
  export type Variant_option_valuesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant_option_values to delete
     */
    where?: Variant_option_valuesWhereInput
  }

  /**
   * Variant_option_values.Cart_items
   */
  export type Variant_option_values$Cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    where?: Cart_itemsWhereInput
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    cursor?: Cart_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * Variant_option_values without action
   */
  export type Variant_option_valuesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
  }


  /**
   * Model Variant_options
   */

  export type AggregateVariant_options = {
    _count: Variant_optionsCountAggregateOutputType | null
    _min: Variant_optionsMinAggregateOutputType | null
    _max: Variant_optionsMaxAggregateOutputType | null
  }

  export type Variant_optionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    variantsId: string | null
  }

  export type Variant_optionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    variantsId: string | null
  }

  export type Variant_optionsCountAggregateOutputType = {
    id: number
    name: number
    variantsId: number
    _all: number
  }


  export type Variant_optionsMinAggregateInputType = {
    id?: true
    name?: true
    variantsId?: true
  }

  export type Variant_optionsMaxAggregateInputType = {
    id?: true
    name?: true
    variantsId?: true
  }

  export type Variant_optionsCountAggregateInputType = {
    id?: true
    name?: true
    variantsId?: true
    _all?: true
  }

  export type Variant_optionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant_options to aggregate.
     */
    where?: Variant_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_options to fetch.
     */
    orderBy?: Variant_optionsOrderByWithRelationInput | Variant_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Variant_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variant_options
    **/
    _count?: true | Variant_optionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Variant_optionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Variant_optionsMaxAggregateInputType
  }

  export type GetVariant_optionsAggregateType<T extends Variant_optionsAggregateArgs> = {
        [P in keyof T & keyof AggregateVariant_options]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariant_options[P]>
      : GetScalarType<T[P], AggregateVariant_options[P]>
  }




  export type Variant_optionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Variant_optionsWhereInput
    orderBy?: Variant_optionsOrderByWithAggregationInput | Variant_optionsOrderByWithAggregationInput[]
    by: Variant_optionsScalarFieldEnum[] | Variant_optionsScalarFieldEnum
    having?: Variant_optionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Variant_optionsCountAggregateInputType | true
    _min?: Variant_optionsMinAggregateInputType
    _max?: Variant_optionsMaxAggregateInputType
  }

  export type Variant_optionsGroupByOutputType = {
    id: string
    name: string
    variantsId: string
    _count: Variant_optionsCountAggregateOutputType | null
    _min: Variant_optionsMinAggregateOutputType | null
    _max: Variant_optionsMaxAggregateOutputType | null
  }

  type GetVariant_optionsGroupByPayload<T extends Variant_optionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Variant_optionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Variant_optionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Variant_optionsGroupByOutputType[P]>
            : GetScalarType<T[P], Variant_optionsGroupByOutputType[P]>
        }
      >
    >


  export type Variant_optionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    variantsId?: boolean
    variant_id?: boolean | VariantsDefaultArgs<ExtArgs>
    Variant_option_values?: boolean | Variant_options$Variant_option_valuesArgs<ExtArgs>
    _count?: boolean | Variant_optionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant_options"]>

  export type Variant_optionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    variantsId?: boolean
    variant_id?: boolean | VariantsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant_options"]>

  export type Variant_optionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    variantsId?: boolean
    variant_id?: boolean | VariantsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant_options"]>

  export type Variant_optionsSelectScalar = {
    id?: boolean
    name?: boolean
    variantsId?: boolean
  }

  export type Variant_optionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "variantsId", ExtArgs["result"]["variant_options"]>
  export type Variant_optionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant_id?: boolean | VariantsDefaultArgs<ExtArgs>
    Variant_option_values?: boolean | Variant_options$Variant_option_valuesArgs<ExtArgs>
    _count?: boolean | Variant_optionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Variant_optionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant_id?: boolean | VariantsDefaultArgs<ExtArgs>
  }
  export type Variant_optionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant_id?: boolean | VariantsDefaultArgs<ExtArgs>
  }

  export type $Variant_optionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variant_options"
    objects: {
      variant_id: Prisma.$VariantsPayload<ExtArgs>
      Variant_option_values: Prisma.$Variant_option_valuesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      variantsId: string
    }, ExtArgs["result"]["variant_options"]>
    composites: {}
  }

  type Variant_optionsGetPayload<S extends boolean | null | undefined | Variant_optionsDefaultArgs> = $Result.GetResult<Prisma.$Variant_optionsPayload, S>

  type Variant_optionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Variant_optionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Variant_optionsCountAggregateInputType | true
    }

  export interface Variant_optionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variant_options'], meta: { name: 'Variant_options' } }
    /**
     * Find zero or one Variant_options that matches the filter.
     * @param {Variant_optionsFindUniqueArgs} args - Arguments to find a Variant_options
     * @example
     * // Get one Variant_options
     * const variant_options = await prisma.variant_options.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Variant_optionsFindUniqueArgs>(args: SelectSubset<T, Variant_optionsFindUniqueArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Variant_options that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Variant_optionsFindUniqueOrThrowArgs} args - Arguments to find a Variant_options
     * @example
     * // Get one Variant_options
     * const variant_options = await prisma.variant_options.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Variant_optionsFindUniqueOrThrowArgs>(args: SelectSubset<T, Variant_optionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Variant_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsFindFirstArgs} args - Arguments to find a Variant_options
     * @example
     * // Get one Variant_options
     * const variant_options = await prisma.variant_options.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Variant_optionsFindFirstArgs>(args?: SelectSubset<T, Variant_optionsFindFirstArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Variant_options that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsFindFirstOrThrowArgs} args - Arguments to find a Variant_options
     * @example
     * // Get one Variant_options
     * const variant_options = await prisma.variant_options.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Variant_optionsFindFirstOrThrowArgs>(args?: SelectSubset<T, Variant_optionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Variant_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variant_options
     * const variant_options = await prisma.variant_options.findMany()
     * 
     * // Get first 10 Variant_options
     * const variant_options = await prisma.variant_options.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variant_optionsWithIdOnly = await prisma.variant_options.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Variant_optionsFindManyArgs>(args?: SelectSubset<T, Variant_optionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Variant_options.
     * @param {Variant_optionsCreateArgs} args - Arguments to create a Variant_options.
     * @example
     * // Create one Variant_options
     * const Variant_options = await prisma.variant_options.create({
     *   data: {
     *     // ... data to create a Variant_options
     *   }
     * })
     * 
     */
    create<T extends Variant_optionsCreateArgs>(args: SelectSubset<T, Variant_optionsCreateArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Variant_options.
     * @param {Variant_optionsCreateManyArgs} args - Arguments to create many Variant_options.
     * @example
     * // Create many Variant_options
     * const variant_options = await prisma.variant_options.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Variant_optionsCreateManyArgs>(args?: SelectSubset<T, Variant_optionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variant_options and returns the data saved in the database.
     * @param {Variant_optionsCreateManyAndReturnArgs} args - Arguments to create many Variant_options.
     * @example
     * // Create many Variant_options
     * const variant_options = await prisma.variant_options.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variant_options and only return the `id`
     * const variant_optionsWithIdOnly = await prisma.variant_options.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Variant_optionsCreateManyAndReturnArgs>(args?: SelectSubset<T, Variant_optionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Variant_options.
     * @param {Variant_optionsDeleteArgs} args - Arguments to delete one Variant_options.
     * @example
     * // Delete one Variant_options
     * const Variant_options = await prisma.variant_options.delete({
     *   where: {
     *     // ... filter to delete one Variant_options
     *   }
     * })
     * 
     */
    delete<T extends Variant_optionsDeleteArgs>(args: SelectSubset<T, Variant_optionsDeleteArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Variant_options.
     * @param {Variant_optionsUpdateArgs} args - Arguments to update one Variant_options.
     * @example
     * // Update one Variant_options
     * const variant_options = await prisma.variant_options.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Variant_optionsUpdateArgs>(args: SelectSubset<T, Variant_optionsUpdateArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Variant_options.
     * @param {Variant_optionsDeleteManyArgs} args - Arguments to filter Variant_options to delete.
     * @example
     * // Delete a few Variant_options
     * const { count } = await prisma.variant_options.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Variant_optionsDeleteManyArgs>(args?: SelectSubset<T, Variant_optionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variant_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variant_options
     * const variant_options = await prisma.variant_options.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Variant_optionsUpdateManyArgs>(args: SelectSubset<T, Variant_optionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variant_options and returns the data updated in the database.
     * @param {Variant_optionsUpdateManyAndReturnArgs} args - Arguments to update many Variant_options.
     * @example
     * // Update many Variant_options
     * const variant_options = await prisma.variant_options.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variant_options and only return the `id`
     * const variant_optionsWithIdOnly = await prisma.variant_options.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Variant_optionsUpdateManyAndReturnArgs>(args: SelectSubset<T, Variant_optionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Variant_options.
     * @param {Variant_optionsUpsertArgs} args - Arguments to update or create a Variant_options.
     * @example
     * // Update or create a Variant_options
     * const variant_options = await prisma.variant_options.upsert({
     *   create: {
     *     // ... data to create a Variant_options
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variant_options we want to update
     *   }
     * })
     */
    upsert<T extends Variant_optionsUpsertArgs>(args: SelectSubset<T, Variant_optionsUpsertArgs<ExtArgs>>): Prisma__Variant_optionsClient<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Variant_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsCountArgs} args - Arguments to filter Variant_options to count.
     * @example
     * // Count the number of Variant_options
     * const count = await prisma.variant_options.count({
     *   where: {
     *     // ... the filter for the Variant_options we want to count
     *   }
     * })
    **/
    count<T extends Variant_optionsCountArgs>(
      args?: Subset<T, Variant_optionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Variant_optionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variant_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Variant_optionsAggregateArgs>(args: Subset<T, Variant_optionsAggregateArgs>): Prisma.PrismaPromise<GetVariant_optionsAggregateType<T>>

    /**
     * Group by Variant_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Variant_optionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Variant_optionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Variant_optionsGroupByArgs['orderBy'] }
        : { orderBy?: Variant_optionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Variant_optionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariant_optionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variant_options model
   */
  readonly fields: Variant_optionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variant_options.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Variant_optionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant_id<T extends VariantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariantsDefaultArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Variant_option_values<T extends Variant_options$Variant_option_valuesArgs<ExtArgs> = {}>(args?: Subset<T, Variant_options$Variant_option_valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variant_options model
   */ 
  interface Variant_optionsFieldRefs {
    readonly id: FieldRef<"Variant_options", 'String'>
    readonly name: FieldRef<"Variant_options", 'String'>
    readonly variantsId: FieldRef<"Variant_options", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Variant_options findUnique
   */
  export type Variant_optionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * Filter, which Variant_options to fetch.
     */
    where: Variant_optionsWhereUniqueInput
  }

  /**
   * Variant_options findUniqueOrThrow
   */
  export type Variant_optionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * Filter, which Variant_options to fetch.
     */
    where: Variant_optionsWhereUniqueInput
  }

  /**
   * Variant_options findFirst
   */
  export type Variant_optionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * Filter, which Variant_options to fetch.
     */
    where?: Variant_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_options to fetch.
     */
    orderBy?: Variant_optionsOrderByWithRelationInput | Variant_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variant_options.
     */
    cursor?: Variant_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variant_options.
     */
    distinct?: Variant_optionsScalarFieldEnum | Variant_optionsScalarFieldEnum[]
  }

  /**
   * Variant_options findFirstOrThrow
   */
  export type Variant_optionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * Filter, which Variant_options to fetch.
     */
    where?: Variant_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_options to fetch.
     */
    orderBy?: Variant_optionsOrderByWithRelationInput | Variant_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variant_options.
     */
    cursor?: Variant_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variant_options.
     */
    distinct?: Variant_optionsScalarFieldEnum | Variant_optionsScalarFieldEnum[]
  }

  /**
   * Variant_options findMany
   */
  export type Variant_optionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * Filter, which Variant_options to fetch.
     */
    where?: Variant_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variant_options to fetch.
     */
    orderBy?: Variant_optionsOrderByWithRelationInput | Variant_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variant_options.
     */
    cursor?: Variant_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variant_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variant_options.
     */
    skip?: number
    distinct?: Variant_optionsScalarFieldEnum | Variant_optionsScalarFieldEnum[]
  }

  /**
   * Variant_options create
   */
  export type Variant_optionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Variant_options.
     */
    data: XOR<Variant_optionsCreateInput, Variant_optionsUncheckedCreateInput>
  }

  /**
   * Variant_options createMany
   */
  export type Variant_optionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variant_options.
     */
    data: Variant_optionsCreateManyInput | Variant_optionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variant_options createManyAndReturn
   */
  export type Variant_optionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * The data used to create many Variant_options.
     */
    data: Variant_optionsCreateManyInput | Variant_optionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant_options update
   */
  export type Variant_optionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Variant_options.
     */
    data: XOR<Variant_optionsUpdateInput, Variant_optionsUncheckedUpdateInput>
    /**
     * Choose, which Variant_options to update.
     */
    where: Variant_optionsWhereUniqueInput
  }

  /**
   * Variant_options updateMany
   */
  export type Variant_optionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variant_options.
     */
    data: XOR<Variant_optionsUpdateManyMutationInput, Variant_optionsUncheckedUpdateManyInput>
    /**
     * Filter which Variant_options to update
     */
    where?: Variant_optionsWhereInput
  }

  /**
   * Variant_options updateManyAndReturn
   */
  export type Variant_optionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * The data used to update Variant_options.
     */
    data: XOR<Variant_optionsUpdateManyMutationInput, Variant_optionsUncheckedUpdateManyInput>
    /**
     * Filter which Variant_options to update
     */
    where?: Variant_optionsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant_options upsert
   */
  export type Variant_optionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Variant_options to update in case it exists.
     */
    where: Variant_optionsWhereUniqueInput
    /**
     * In case the Variant_options found by the `where` argument doesn't exist, create a new Variant_options with this data.
     */
    create: XOR<Variant_optionsCreateInput, Variant_optionsUncheckedCreateInput>
    /**
     * In case the Variant_options was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Variant_optionsUpdateInput, Variant_optionsUncheckedUpdateInput>
  }

  /**
   * Variant_options delete
   */
  export type Variant_optionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    /**
     * Filter which Variant_options to delete.
     */
    where: Variant_optionsWhereUniqueInput
  }

  /**
   * Variant_options deleteMany
   */
  export type Variant_optionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant_options to delete
     */
    where?: Variant_optionsWhereInput
  }

  /**
   * Variant_options.Variant_option_values
   */
  export type Variant_options$Variant_option_valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_option_values
     */
    select?: Variant_option_valuesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_option_values
     */
    omit?: Variant_option_valuesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_option_valuesInclude<ExtArgs> | null
    where?: Variant_option_valuesWhereInput
    orderBy?: Variant_option_valuesOrderByWithRelationInput | Variant_option_valuesOrderByWithRelationInput[]
    cursor?: Variant_option_valuesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Variant_option_valuesScalarFieldEnum | Variant_option_valuesScalarFieldEnum[]
  }

  /**
   * Variant_options without action
   */
  export type Variant_optionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
  }


  /**
   * Model Variants
   */

  export type AggregateVariants = {
    _count: VariantsCountAggregateOutputType | null
    _min: VariantsMinAggregateOutputType | null
    _max: VariantsMaxAggregateOutputType | null
  }

  export type VariantsMinAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    productId: string | null
  }

  export type VariantsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    is_active: boolean | null
    productId: string | null
  }

  export type VariantsCountAggregateOutputType = {
    id: number
    name: number
    is_active: number
    productId: number
    _all: number
  }


  export type VariantsMinAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    productId?: true
  }

  export type VariantsMaxAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    productId?: true
  }

  export type VariantsCountAggregateInputType = {
    id?: true
    name?: true
    is_active?: true
    productId?: true
    _all?: true
  }

  export type VariantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variants to aggregate.
     */
    where?: VariantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantsOrderByWithRelationInput | VariantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variants
    **/
    _count?: true | VariantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantsMaxAggregateInputType
  }

  export type GetVariantsAggregateType<T extends VariantsAggregateArgs> = {
        [P in keyof T & keyof AggregateVariants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariants[P]>
      : GetScalarType<T[P], AggregateVariants[P]>
  }




  export type VariantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantsWhereInput
    orderBy?: VariantsOrderByWithAggregationInput | VariantsOrderByWithAggregationInput[]
    by: VariantsScalarFieldEnum[] | VariantsScalarFieldEnum
    having?: VariantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantsCountAggregateInputType | true
    _min?: VariantsMinAggregateInputType
    _max?: VariantsMaxAggregateInputType
  }

  export type VariantsGroupByOutputType = {
    id: string
    name: string
    is_active: boolean
    productId: string
    _count: VariantsCountAggregateOutputType | null
    _min: VariantsMinAggregateOutputType | null
    _max: VariantsMaxAggregateOutputType | null
  }

  type GetVariantsGroupByPayload<T extends VariantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantsGroupByOutputType[P]>
            : GetScalarType<T[P], VariantsGroupByOutputType[P]>
        }
      >
    >


  export type VariantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    productId?: boolean
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
    Variant_options?: boolean | Variants$Variant_optionsArgs<ExtArgs>
    _count?: boolean | VariantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variants"]>

  export type VariantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    productId?: boolean
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variants"]>

  export type VariantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_active?: boolean
    productId?: boolean
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variants"]>

  export type VariantsSelectScalar = {
    id?: boolean
    name?: boolean
    is_active?: boolean
    productId?: boolean
  }

  export type VariantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_active" | "productId", ExtArgs["result"]["variants"]>
  export type VariantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
    Variant_options?: boolean | Variants$Variant_optionsArgs<ExtArgs>
    _count?: boolean | VariantsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type VariantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $VariantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variants"
    objects: {
      product_id: Prisma.$ProductPayload<ExtArgs>
      Variant_options: Prisma.$Variant_optionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      is_active: boolean
      productId: string
    }, ExtArgs["result"]["variants"]>
    composites: {}
  }

  type VariantsGetPayload<S extends boolean | null | undefined | VariantsDefaultArgs> = $Result.GetResult<Prisma.$VariantsPayload, S>

  type VariantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariantsCountAggregateInputType | true
    }

  export interface VariantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variants'], meta: { name: 'Variants' } }
    /**
     * Find zero or one Variants that matches the filter.
     * @param {VariantsFindUniqueArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantsFindUniqueArgs>(args: SelectSubset<T, VariantsFindUniqueArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Variants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariantsFindUniqueOrThrowArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantsFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsFindFirstArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantsFindFirstArgs>(args?: SelectSubset<T, VariantsFindFirstArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Variants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsFindFirstOrThrowArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantsFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variants
     * const variants = await prisma.variants.findMany()
     * 
     * // Get first 10 Variants
     * const variants = await prisma.variants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantsWithIdOnly = await prisma.variants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantsFindManyArgs>(args?: SelectSubset<T, VariantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Variants.
     * @param {VariantsCreateArgs} args - Arguments to create a Variants.
     * @example
     * // Create one Variants
     * const Variants = await prisma.variants.create({
     *   data: {
     *     // ... data to create a Variants
     *   }
     * })
     * 
     */
    create<T extends VariantsCreateArgs>(args: SelectSubset<T, VariantsCreateArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Variants.
     * @param {VariantsCreateManyArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variants = await prisma.variants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantsCreateManyArgs>(args?: SelectSubset<T, VariantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variants and returns the data saved in the database.
     * @param {VariantsCreateManyAndReturnArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variants = await prisma.variants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variants and only return the `id`
     * const variantsWithIdOnly = await prisma.variants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantsCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Variants.
     * @param {VariantsDeleteArgs} args - Arguments to delete one Variants.
     * @example
     * // Delete one Variants
     * const Variants = await prisma.variants.delete({
     *   where: {
     *     // ... filter to delete one Variants
     *   }
     * })
     * 
     */
    delete<T extends VariantsDeleteArgs>(args: SelectSubset<T, VariantsDeleteArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Variants.
     * @param {VariantsUpdateArgs} args - Arguments to update one Variants.
     * @example
     * // Update one Variants
     * const variants = await prisma.variants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantsUpdateArgs>(args: SelectSubset<T, VariantsUpdateArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Variants.
     * @param {VariantsDeleteManyArgs} args - Arguments to filter Variants to delete.
     * @example
     * // Delete a few Variants
     * const { count } = await prisma.variants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantsDeleteManyArgs>(args?: SelectSubset<T, VariantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variants
     * const variants = await prisma.variants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantsUpdateManyArgs>(args: SelectSubset<T, VariantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants and returns the data updated in the database.
     * @param {VariantsUpdateManyAndReturnArgs} args - Arguments to update many Variants.
     * @example
     * // Update many Variants
     * const variants = await prisma.variants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variants and only return the `id`
     * const variantsWithIdOnly = await prisma.variants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariantsUpdateManyAndReturnArgs>(args: SelectSubset<T, VariantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Variants.
     * @param {VariantsUpsertArgs} args - Arguments to update or create a Variants.
     * @example
     * // Update or create a Variants
     * const variants = await prisma.variants.upsert({
     *   create: {
     *     // ... data to create a Variants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variants we want to update
     *   }
     * })
     */
    upsert<T extends VariantsUpsertArgs>(args: SelectSubset<T, VariantsUpsertArgs<ExtArgs>>): Prisma__VariantsClient<$Result.GetResult<Prisma.$VariantsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsCountArgs} args - Arguments to filter Variants to count.
     * @example
     * // Count the number of Variants
     * const count = await prisma.variants.count({
     *   where: {
     *     // ... the filter for the Variants we want to count
     *   }
     * })
    **/
    count<T extends VariantsCountArgs>(
      args?: Subset<T, VariantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantsAggregateArgs>(args: Subset<T, VariantsAggregateArgs>): Prisma.PrismaPromise<GetVariantsAggregateType<T>>

    /**
     * Group by Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantsGroupByArgs['orderBy'] }
        : { orderBy?: VariantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variants model
   */
  readonly fields: VariantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product_id<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Variant_options<T extends Variants$Variant_optionsArgs<ExtArgs> = {}>(args?: Subset<T, Variants$Variant_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Variant_optionsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variants model
   */ 
  interface VariantsFieldRefs {
    readonly id: FieldRef<"Variants", 'String'>
    readonly name: FieldRef<"Variants", 'String'>
    readonly is_active: FieldRef<"Variants", 'Boolean'>
    readonly productId: FieldRef<"Variants", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Variants findUnique
   */
  export type VariantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where: VariantsWhereUniqueInput
  }

  /**
   * Variants findUniqueOrThrow
   */
  export type VariantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where: VariantsWhereUniqueInput
  }

  /**
   * Variants findFirst
   */
  export type VariantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where?: VariantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantsOrderByWithRelationInput | VariantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * Variants findFirstOrThrow
   */
  export type VariantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where?: VariantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantsOrderByWithRelationInput | VariantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * Variants findMany
   */
  export type VariantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where?: VariantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantsOrderByWithRelationInput | VariantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variants.
     */
    cursor?: VariantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * Variants create
   */
  export type VariantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * The data needed to create a Variants.
     */
    data: XOR<VariantsCreateInput, VariantsUncheckedCreateInput>
  }

  /**
   * Variants createMany
   */
  export type VariantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variants.
     */
    data: VariantsCreateManyInput | VariantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variants createManyAndReturn
   */
  export type VariantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * The data used to create many Variants.
     */
    data: VariantsCreateManyInput | VariantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variants update
   */
  export type VariantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * The data needed to update a Variants.
     */
    data: XOR<VariantsUpdateInput, VariantsUncheckedUpdateInput>
    /**
     * Choose, which Variants to update.
     */
    where: VariantsWhereUniqueInput
  }

  /**
   * Variants updateMany
   */
  export type VariantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantsUpdateManyMutationInput, VariantsUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantsWhereInput
  }

  /**
   * Variants updateManyAndReturn
   */
  export type VariantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantsUpdateManyMutationInput, VariantsUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variants upsert
   */
  export type VariantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * The filter to search for the Variants to update in case it exists.
     */
    where: VariantsWhereUniqueInput
    /**
     * In case the Variants found by the `where` argument doesn't exist, create a new Variants with this data.
     */
    create: XOR<VariantsCreateInput, VariantsUncheckedCreateInput>
    /**
     * In case the Variants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantsUpdateInput, VariantsUncheckedUpdateInput>
  }

  /**
   * Variants delete
   */
  export type VariantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
    /**
     * Filter which Variants to delete.
     */
    where: VariantsWhereUniqueInput
  }

  /**
   * Variants deleteMany
   */
  export type VariantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variants to delete
     */
    where?: VariantsWhereInput
  }

  /**
   * Variants.Variant_options
   */
  export type Variants$Variant_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant_options
     */
    select?: Variant_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant_options
     */
    omit?: Variant_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Variant_optionsInclude<ExtArgs> | null
    where?: Variant_optionsWhereInput
    orderBy?: Variant_optionsOrderByWithRelationInput | Variant_optionsOrderByWithRelationInput[]
    cursor?: Variant_optionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Variant_optionsScalarFieldEnum | Variant_optionsScalarFieldEnum[]
  }

  /**
   * Variants without action
   */
  export type VariantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variants
     */
    select?: VariantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variants
     */
    omit?: VariantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantsInclude<ExtArgs> | null
  }


  /**
   * Model Categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    productId: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    productId: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    productId: number
    _all: number
  }


  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    productId?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    productId?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    productId?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to aggregate.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriesWhereInput
    orderBy?: CategoriesOrderByWithAggregationInput | CategoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: CategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: string
    name: string
    productId: string
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type CategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    productId?: boolean
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    productId?: boolean
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    productId?: boolean
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type CategoriesSelectScalar = {
    id?: boolean
    name?: boolean
    productId?: boolean
  }

  export type CategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "productId", ExtArgs["result"]["categories"]>
  export type CategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_id?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categories"
    objects: {
      product_id: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      productId: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type CategoriesGetPayload<S extends boolean | null | undefined | CategoriesDefaultArgs> = $Result.GetResult<Prisma.$CategoriesPayload, S>

  type CategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface CategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categories'], meta: { name: 'Categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {CategoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriesFindUniqueArgs>(args: SelectSubset<T, CategoriesFindUniqueArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriesFindFirstArgs>(args?: SelectSubset<T, CategoriesFindFirstArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriesFindManyArgs>(args?: SelectSubset<T, CategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Categories.
     * @param {CategoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends CategoriesCreateArgs>(args: SelectSubset<T, CategoriesCreateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Categories.
     * @param {CategoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriesCreateManyArgs>(args?: SelectSubset<T, CategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Categories.
     * @param {CategoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends CategoriesDeleteArgs>(args: SelectSubset<T, CategoriesDeleteArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Categories.
     * @param {CategoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriesUpdateArgs>(args: SelectSubset<T, CategoriesUpdateArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriesDeleteManyArgs>(args?: SelectSubset<T, CategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriesUpdateManyArgs>(args: SelectSubset<T, CategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Categories.
     * @param {CategoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends CategoriesUpsertArgs>(args: SelectSubset<T, CategoriesUpsertArgs<ExtArgs>>): Prisma__CategoriesClient<$Result.GetResult<Prisma.$CategoriesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoriesCountArgs>(
      args?: Subset<T, CategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categories model
   */
  readonly fields: CategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product_id<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categories model
   */ 
  interface CategoriesFieldRefs {
    readonly id: FieldRef<"Categories", 'String'>
    readonly name: FieldRef<"Categories", 'String'>
    readonly productId: FieldRef<"Categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categories findUnique
   */
  export type CategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findUniqueOrThrow
   */
  export type CategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories findFirst
   */
  export type CategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findFirstOrThrow
   */
  export type CategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories findMany
   */
  export type CategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoriesOrderByWithRelationInput | CategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * Categories create
   */
  export type CategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Categories.
     */
    data: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
  }

  /**
   * Categories createMany
   */
  export type CategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categories createManyAndReturn
   */
  export type CategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoriesCreateManyInput | CategoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categories update
   */
  export type CategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Categories.
     */
    data: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
    /**
     * Choose, which Categories to update.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories updateMany
   */
  export type CategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
  }

  /**
   * Categories updateManyAndReturn
   */
  export type CategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoriesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categories upsert
   */
  export type CategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Categories to update in case it exists.
     */
    where: CategoriesWhereUniqueInput
    /**
     * In case the Categories found by the `where` argument doesn't exist, create a new Categories with this data.
     */
    create: XOR<CategoriesCreateInput, CategoriesUncheckedCreateInput>
    /**
     * In case the Categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriesUpdateInput, CategoriesUncheckedUpdateInput>
  }

  /**
   * Categories delete
   */
  export type CategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
    /**
     * Filter which Categories to delete.
     */
    where: CategoriesWhereUniqueInput
  }

  /**
   * Categories deleteMany
   */
  export type CategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoriesWhereInput
  }

  /**
   * Categories without action
   */
  export type CategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categories
     */
    select?: CategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categories
     */
    omit?: CategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Carts
   */

  export type AggregateCarts = {
    _count: CartsCountAggregateOutputType | null
    _avg: CartsAvgAggregateOutputType | null
    _sum: CartsSumAggregateOutputType | null
    _min: CartsMinAggregateOutputType | null
    _max: CartsMaxAggregateOutputType | null
  }

  export type CartsAvgAggregateOutputType = {
    prices: number | null
  }

  export type CartsSumAggregateOutputType = {
    prices: number | null
  }

  export type CartsMinAggregateOutputType = {
    id: string | null
    prices: number | null
    discount: string | null
    userId: string | null
    storesId: string | null
  }

  export type CartsMaxAggregateOutputType = {
    id: string | null
    prices: number | null
    discount: string | null
    userId: string | null
    storesId: string | null
  }

  export type CartsCountAggregateOutputType = {
    id: number
    prices: number
    discount: number
    userId: number
    storesId: number
    _all: number
  }


  export type CartsAvgAggregateInputType = {
    prices?: true
  }

  export type CartsSumAggregateInputType = {
    prices?: true
  }

  export type CartsMinAggregateInputType = {
    id?: true
    prices?: true
    discount?: true
    userId?: true
    storesId?: true
  }

  export type CartsMaxAggregateInputType = {
    id?: true
    prices?: true
    discount?: true
    userId?: true
    storesId?: true
  }

  export type CartsCountAggregateInputType = {
    id?: true
    prices?: true
    discount?: true
    userId?: true
    storesId?: true
    _all?: true
  }

  export type CartsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to aggregate.
     */
    where?: CartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartsOrderByWithRelationInput | CartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartsMaxAggregateInputType
  }

  export type GetCartsAggregateType<T extends CartsAggregateArgs> = {
        [P in keyof T & keyof AggregateCarts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarts[P]>
      : GetScalarType<T[P], AggregateCarts[P]>
  }




  export type CartsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartsWhereInput
    orderBy?: CartsOrderByWithAggregationInput | CartsOrderByWithAggregationInput[]
    by: CartsScalarFieldEnum[] | CartsScalarFieldEnum
    having?: CartsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartsCountAggregateInputType | true
    _avg?: CartsAvgAggregateInputType
    _sum?: CartsSumAggregateInputType
    _min?: CartsMinAggregateInputType
    _max?: CartsMaxAggregateInputType
  }

  export type CartsGroupByOutputType = {
    id: string
    prices: number
    discount: string | null
    userId: string
    storesId: string
    _count: CartsCountAggregateOutputType | null
    _avg: CartsAvgAggregateOutputType | null
    _sum: CartsSumAggregateOutputType | null
    _min: CartsMinAggregateOutputType | null
    _max: CartsMaxAggregateOutputType | null
  }

  type GetCartsGroupByPayload<T extends CartsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartsGroupByOutputType[P]>
            : GetScalarType<T[P], CartsGroupByOutputType[P]>
        }
      >
    >


  export type CartsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prices?: boolean
    discount?: boolean
    userId?: boolean
    storesId?: boolean
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    Cart_items?: boolean | Carts$Cart_itemsArgs<ExtArgs>
    Invoices?: boolean | Carts$InvoicesArgs<ExtArgs>
    _count?: boolean | CartsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carts"]>

  export type CartsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prices?: boolean
    discount?: boolean
    userId?: boolean
    storesId?: boolean
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carts"]>

  export type CartsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prices?: boolean
    discount?: boolean
    userId?: boolean
    storesId?: boolean
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carts"]>

  export type CartsSelectScalar = {
    id?: boolean
    prices?: boolean
    discount?: boolean
    userId?: boolean
    storesId?: boolean
  }

  export type CartsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prices" | "discount" | "userId" | "storesId", ExtArgs["result"]["carts"]>
  export type CartsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    Cart_items?: boolean | Carts$Cart_itemsArgs<ExtArgs>
    Invoices?: boolean | Carts$InvoicesArgs<ExtArgs>
    _count?: boolean | CartsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type CartsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $CartsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carts"
    objects: {
      user_id: Prisma.$UserPayload<ExtArgs>
      store_id: Prisma.$StoresPayload<ExtArgs>
      Cart_items: Prisma.$Cart_itemsPayload<ExtArgs>[]
      Invoices: Prisma.$InvoicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prices: number
      discount: string | null
      userId: string
      storesId: string
    }, ExtArgs["result"]["carts"]>
    composites: {}
  }

  type CartsGetPayload<S extends boolean | null | undefined | CartsDefaultArgs> = $Result.GetResult<Prisma.$CartsPayload, S>

  type CartsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartsCountAggregateInputType | true
    }

  export interface CartsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carts'], meta: { name: 'Carts' } }
    /**
     * Find zero or one Carts that matches the filter.
     * @param {CartsFindUniqueArgs} args - Arguments to find a Carts
     * @example
     * // Get one Carts
     * const carts = await prisma.carts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartsFindUniqueArgs>(args: SelectSubset<T, CartsFindUniqueArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Carts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartsFindUniqueOrThrowArgs} args - Arguments to find a Carts
     * @example
     * // Get one Carts
     * const carts = await prisma.carts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartsFindUniqueOrThrowArgs>(args: SelectSubset<T, CartsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsFindFirstArgs} args - Arguments to find a Carts
     * @example
     * // Get one Carts
     * const carts = await prisma.carts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartsFindFirstArgs>(args?: SelectSubset<T, CartsFindFirstArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Carts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsFindFirstOrThrowArgs} args - Arguments to find a Carts
     * @example
     * // Get one Carts
     * const carts = await prisma.carts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartsFindFirstOrThrowArgs>(args?: SelectSubset<T, CartsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.carts.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.carts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartsWithIdOnly = await prisma.carts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartsFindManyArgs>(args?: SelectSubset<T, CartsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Carts.
     * @param {CartsCreateArgs} args - Arguments to create a Carts.
     * @example
     * // Create one Carts
     * const Carts = await prisma.carts.create({
     *   data: {
     *     // ... data to create a Carts
     *   }
     * })
     * 
     */
    create<T extends CartsCreateArgs>(args: SelectSubset<T, CartsCreateArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Carts.
     * @param {CartsCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const carts = await prisma.carts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartsCreateManyArgs>(args?: SelectSubset<T, CartsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartsCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const carts = await prisma.carts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartsWithIdOnly = await prisma.carts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartsCreateManyAndReturnArgs>(args?: SelectSubset<T, CartsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Carts.
     * @param {CartsDeleteArgs} args - Arguments to delete one Carts.
     * @example
     * // Delete one Carts
     * const Carts = await prisma.carts.delete({
     *   where: {
     *     // ... filter to delete one Carts
     *   }
     * })
     * 
     */
    delete<T extends CartsDeleteArgs>(args: SelectSubset<T, CartsDeleteArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Carts.
     * @param {CartsUpdateArgs} args - Arguments to update one Carts.
     * @example
     * // Update one Carts
     * const carts = await prisma.carts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartsUpdateArgs>(args: SelectSubset<T, CartsUpdateArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartsDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.carts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartsDeleteManyArgs>(args?: SelectSubset<T, CartsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const carts = await prisma.carts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartsUpdateManyArgs>(args: SelectSubset<T, CartsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartsUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const carts = await prisma.carts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartsWithIdOnly = await prisma.carts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartsUpdateManyAndReturnArgs>(args: SelectSubset<T, CartsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Carts.
     * @param {CartsUpsertArgs} args - Arguments to update or create a Carts.
     * @example
     * // Update or create a Carts
     * const carts = await prisma.carts.upsert({
     *   create: {
     *     // ... data to create a Carts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carts we want to update
     *   }
     * })
     */
    upsert<T extends CartsUpsertArgs>(args: SelectSubset<T, CartsUpsertArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.carts.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartsCountArgs>(
      args?: Subset<T, CartsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartsAggregateArgs>(args: Subset<T, CartsAggregateArgs>): Prisma.PrismaPromise<GetCartsAggregateType<T>>

    /**
     * Group by Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartsGroupByArgs['orderBy'] }
        : { orderBy?: CartsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carts model
   */
  readonly fields: CartsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_id<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    store_id<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Cart_items<T extends Carts$Cart_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Carts$Cart_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Invoices<T extends Carts$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Carts$InvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carts model
   */ 
  interface CartsFieldRefs {
    readonly id: FieldRef<"Carts", 'String'>
    readonly prices: FieldRef<"Carts", 'Int'>
    readonly discount: FieldRef<"Carts", 'String'>
    readonly userId: FieldRef<"Carts", 'String'>
    readonly storesId: FieldRef<"Carts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Carts findUnique
   */
  export type CartsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where: CartsWhereUniqueInput
  }

  /**
   * Carts findUniqueOrThrow
   */
  export type CartsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where: CartsWhereUniqueInput
  }

  /**
   * Carts findFirst
   */
  export type CartsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartsOrderByWithRelationInput | CartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartsScalarFieldEnum | CartsScalarFieldEnum[]
  }

  /**
   * Carts findFirstOrThrow
   */
  export type CartsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartsOrderByWithRelationInput | CartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartsScalarFieldEnum | CartsScalarFieldEnum[]
  }

  /**
   * Carts findMany
   */
  export type CartsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartsOrderByWithRelationInput | CartsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartsScalarFieldEnum | CartsScalarFieldEnum[]
  }

  /**
   * Carts create
   */
  export type CartsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * The data needed to create a Carts.
     */
    data: XOR<CartsCreateInput, CartsUncheckedCreateInput>
  }

  /**
   * Carts createMany
   */
  export type CartsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartsCreateManyInput | CartsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carts createManyAndReturn
   */
  export type CartsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartsCreateManyInput | CartsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carts update
   */
  export type CartsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * The data needed to update a Carts.
     */
    data: XOR<CartsUpdateInput, CartsUncheckedUpdateInput>
    /**
     * Choose, which Carts to update.
     */
    where: CartsWhereUniqueInput
  }

  /**
   * Carts updateMany
   */
  export type CartsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartsUpdateManyMutationInput, CartsUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartsWhereInput
  }

  /**
   * Carts updateManyAndReturn
   */
  export type CartsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartsUpdateManyMutationInput, CartsUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carts upsert
   */
  export type CartsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * The filter to search for the Carts to update in case it exists.
     */
    where: CartsWhereUniqueInput
    /**
     * In case the Carts found by the `where` argument doesn't exist, create a new Carts with this data.
     */
    create: XOR<CartsCreateInput, CartsUncheckedCreateInput>
    /**
     * In case the Carts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartsUpdateInput, CartsUncheckedUpdateInput>
  }

  /**
   * Carts delete
   */
  export type CartsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
    /**
     * Filter which Carts to delete.
     */
    where: CartsWhereUniqueInput
  }

  /**
   * Carts deleteMany
   */
  export type CartsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartsWhereInput
  }

  /**
   * Carts.Cart_items
   */
  export type Carts$Cart_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    where?: Cart_itemsWhereInput
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    cursor?: Cart_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * Carts.Invoices
   */
  export type Carts$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    where?: InvoicesWhereInput
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    cursor?: InvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Carts without action
   */
  export type CartsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carts
     */
    select?: CartsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carts
     */
    omit?: CartsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartsInclude<ExtArgs> | null
  }


  /**
   * Model Cart_items
   */

  export type AggregateCart_items = {
    _count: Cart_itemsCountAggregateOutputType | null
    _avg: Cart_itemsAvgAggregateOutputType | null
    _sum: Cart_itemsSumAggregateOutputType | null
    _min: Cart_itemsMinAggregateOutputType | null
    _max: Cart_itemsMaxAggregateOutputType | null
  }

  export type Cart_itemsAvgAggregateOutputType = {
    qty: number | null
    price: number | null
  }

  export type Cart_itemsSumAggregateOutputType = {
    qty: number | null
    price: number | null
  }

  export type Cart_itemsMinAggregateOutputType = {
    id: string | null
    qty: number | null
    price: number | null
    cartsId: string | null
    userId: string | null
    storesId: string | null
    variant_option_valuesId: string | null
  }

  export type Cart_itemsMaxAggregateOutputType = {
    id: string | null
    qty: number | null
    price: number | null
    cartsId: string | null
    userId: string | null
    storesId: string | null
    variant_option_valuesId: string | null
  }

  export type Cart_itemsCountAggregateOutputType = {
    id: number
    qty: number
    price: number
    cartsId: number
    userId: number
    storesId: number
    variant_option_valuesId: number
    _all: number
  }


  export type Cart_itemsAvgAggregateInputType = {
    qty?: true
    price?: true
  }

  export type Cart_itemsSumAggregateInputType = {
    qty?: true
    price?: true
  }

  export type Cart_itemsMinAggregateInputType = {
    id?: true
    qty?: true
    price?: true
    cartsId?: true
    userId?: true
    storesId?: true
    variant_option_valuesId?: true
  }

  export type Cart_itemsMaxAggregateInputType = {
    id?: true
    qty?: true
    price?: true
    cartsId?: true
    userId?: true
    storesId?: true
    variant_option_valuesId?: true
  }

  export type Cart_itemsCountAggregateInputType = {
    id?: true
    qty?: true
    price?: true
    cartsId?: true
    userId?: true
    storesId?: true
    variant_option_valuesId?: true
    _all?: true
  }

  export type Cart_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart_items to aggregate.
     */
    where?: Cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cart_items to fetch.
     */
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cart_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cart_items
    **/
    _count?: true | Cart_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cart_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cart_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cart_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cart_itemsMaxAggregateInputType
  }

  export type GetCart_itemsAggregateType<T extends Cart_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCart_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart_items[P]>
      : GetScalarType<T[P], AggregateCart_items[P]>
  }




  export type Cart_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Cart_itemsWhereInput
    orderBy?: Cart_itemsOrderByWithAggregationInput | Cart_itemsOrderByWithAggregationInput[]
    by: Cart_itemsScalarFieldEnum[] | Cart_itemsScalarFieldEnum
    having?: Cart_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cart_itemsCountAggregateInputType | true
    _avg?: Cart_itemsAvgAggregateInputType
    _sum?: Cart_itemsSumAggregateInputType
    _min?: Cart_itemsMinAggregateInputType
    _max?: Cart_itemsMaxAggregateInputType
  }

  export type Cart_itemsGroupByOutputType = {
    id: string
    qty: number
    price: number
    cartsId: string
    userId: string
    storesId: string
    variant_option_valuesId: string
    _count: Cart_itemsCountAggregateOutputType | null
    _avg: Cart_itemsAvgAggregateOutputType | null
    _sum: Cart_itemsSumAggregateOutputType | null
    _min: Cart_itemsMinAggregateOutputType | null
    _max: Cart_itemsMaxAggregateOutputType | null
  }

  type GetCart_itemsGroupByPayload<T extends Cart_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cart_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cart_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cart_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Cart_itemsGroupByOutputType[P]>
        }
      >
    >


  export type Cart_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qty?: boolean
    price?: boolean
    cartsId?: boolean
    userId?: boolean
    storesId?: boolean
    variant_option_valuesId?: boolean
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    variant_option_value_id?: boolean | Variant_option_valuesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_items"]>

  export type Cart_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qty?: boolean
    price?: boolean
    cartsId?: boolean
    userId?: boolean
    storesId?: boolean
    variant_option_valuesId?: boolean
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    variant_option_value_id?: boolean | Variant_option_valuesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_items"]>

  export type Cart_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qty?: boolean
    price?: boolean
    cartsId?: boolean
    userId?: boolean
    storesId?: boolean
    variant_option_valuesId?: boolean
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    variant_option_value_id?: boolean | Variant_option_valuesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_items"]>

  export type Cart_itemsSelectScalar = {
    id?: boolean
    qty?: boolean
    price?: boolean
    cartsId?: boolean
    userId?: boolean
    storesId?: boolean
    variant_option_valuesId?: boolean
  }

  export type Cart_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qty" | "price" | "cartsId" | "userId" | "storesId" | "variant_option_valuesId", ExtArgs["result"]["cart_items"]>
  export type Cart_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    variant_option_value_id?: boolean | Variant_option_valuesDefaultArgs<ExtArgs>
  }
  export type Cart_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    variant_option_value_id?: boolean | Variant_option_valuesDefaultArgs<ExtArgs>
  }
  export type Cart_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
    variant_option_value_id?: boolean | Variant_option_valuesDefaultArgs<ExtArgs>
  }

  export type $Cart_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart_items"
    objects: {
      cart_id: Prisma.$CartsPayload<ExtArgs>
      user_id: Prisma.$UserPayload<ExtArgs>
      store_id: Prisma.$StoresPayload<ExtArgs>
      variant_option_value_id: Prisma.$Variant_option_valuesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      qty: number
      price: number
      cartsId: string
      userId: string
      storesId: string
      variant_option_valuesId: string
    }, ExtArgs["result"]["cart_items"]>
    composites: {}
  }

  type Cart_itemsGetPayload<S extends boolean | null | undefined | Cart_itemsDefaultArgs> = $Result.GetResult<Prisma.$Cart_itemsPayload, S>

  type Cart_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Cart_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cart_itemsCountAggregateInputType | true
    }

  export interface Cart_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart_items'], meta: { name: 'Cart_items' } }
    /**
     * Find zero or one Cart_items that matches the filter.
     * @param {Cart_itemsFindUniqueArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Cart_itemsFindUniqueArgs>(args: SelectSubset<T, Cart_itemsFindUniqueArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cart_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Cart_itemsFindUniqueOrThrowArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Cart_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, Cart_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cart_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsFindFirstArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Cart_itemsFindFirstArgs>(args?: SelectSubset<T, Cart_itemsFindFirstArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cart_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsFindFirstOrThrowArgs} args - Arguments to find a Cart_items
     * @example
     * // Get one Cart_items
     * const cart_items = await prisma.cart_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Cart_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, Cart_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cart_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cart_items
     * const cart_items = await prisma.cart_items.findMany()
     * 
     * // Get first 10 Cart_items
     * const cart_items = await prisma.cart_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cart_itemsWithIdOnly = await prisma.cart_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Cart_itemsFindManyArgs>(args?: SelectSubset<T, Cart_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cart_items.
     * @param {Cart_itemsCreateArgs} args - Arguments to create a Cart_items.
     * @example
     * // Create one Cart_items
     * const Cart_items = await prisma.cart_items.create({
     *   data: {
     *     // ... data to create a Cart_items
     *   }
     * })
     * 
     */
    create<T extends Cart_itemsCreateArgs>(args: SelectSubset<T, Cart_itemsCreateArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cart_items.
     * @param {Cart_itemsCreateManyArgs} args - Arguments to create many Cart_items.
     * @example
     * // Create many Cart_items
     * const cart_items = await prisma.cart_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Cart_itemsCreateManyArgs>(args?: SelectSubset<T, Cart_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cart_items and returns the data saved in the database.
     * @param {Cart_itemsCreateManyAndReturnArgs} args - Arguments to create many Cart_items.
     * @example
     * // Create many Cart_items
     * const cart_items = await prisma.cart_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cart_items and only return the `id`
     * const cart_itemsWithIdOnly = await prisma.cart_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Cart_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, Cart_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Cart_items.
     * @param {Cart_itemsDeleteArgs} args - Arguments to delete one Cart_items.
     * @example
     * // Delete one Cart_items
     * const Cart_items = await prisma.cart_items.delete({
     *   where: {
     *     // ... filter to delete one Cart_items
     *   }
     * })
     * 
     */
    delete<T extends Cart_itemsDeleteArgs>(args: SelectSubset<T, Cart_itemsDeleteArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cart_items.
     * @param {Cart_itemsUpdateArgs} args - Arguments to update one Cart_items.
     * @example
     * // Update one Cart_items
     * const cart_items = await prisma.cart_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Cart_itemsUpdateArgs>(args: SelectSubset<T, Cart_itemsUpdateArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cart_items.
     * @param {Cart_itemsDeleteManyArgs} args - Arguments to filter Cart_items to delete.
     * @example
     * // Delete a few Cart_items
     * const { count } = await prisma.cart_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Cart_itemsDeleteManyArgs>(args?: SelectSubset<T, Cart_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cart_items
     * const cart_items = await prisma.cart_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Cart_itemsUpdateManyArgs>(args: SelectSubset<T, Cart_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cart_items and returns the data updated in the database.
     * @param {Cart_itemsUpdateManyAndReturnArgs} args - Arguments to update many Cart_items.
     * @example
     * // Update many Cart_items
     * const cart_items = await prisma.cart_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cart_items and only return the `id`
     * const cart_itemsWithIdOnly = await prisma.cart_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Cart_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, Cart_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Cart_items.
     * @param {Cart_itemsUpsertArgs} args - Arguments to update or create a Cart_items.
     * @example
     * // Update or create a Cart_items
     * const cart_items = await prisma.cart_items.upsert({
     *   create: {
     *     // ... data to create a Cart_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart_items we want to update
     *   }
     * })
     */
    upsert<T extends Cart_itemsUpsertArgs>(args: SelectSubset<T, Cart_itemsUpsertArgs<ExtArgs>>): Prisma__Cart_itemsClient<$Result.GetResult<Prisma.$Cart_itemsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsCountArgs} args - Arguments to filter Cart_items to count.
     * @example
     * // Count the number of Cart_items
     * const count = await prisma.cart_items.count({
     *   where: {
     *     // ... the filter for the Cart_items we want to count
     *   }
     * })
    **/
    count<T extends Cart_itemsCountArgs>(
      args?: Subset<T, Cart_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cart_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cart_itemsAggregateArgs>(args: Subset<T, Cart_itemsAggregateArgs>): Prisma.PrismaPromise<GetCart_itemsAggregateType<T>>

    /**
     * Group by Cart_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cart_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cart_itemsGroupByArgs['orderBy'] }
        : { orderBy?: Cart_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cart_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCart_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart_items model
   */
  readonly fields: Cart_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Cart_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart_id<T extends CartsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartsDefaultArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user_id<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    store_id<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    variant_option_value_id<T extends Variant_option_valuesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Variant_option_valuesDefaultArgs<ExtArgs>>): Prisma__Variant_option_valuesClient<$Result.GetResult<Prisma.$Variant_option_valuesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart_items model
   */ 
  interface Cart_itemsFieldRefs {
    readonly id: FieldRef<"Cart_items", 'String'>
    readonly qty: FieldRef<"Cart_items", 'Int'>
    readonly price: FieldRef<"Cart_items", 'Int'>
    readonly cartsId: FieldRef<"Cart_items", 'String'>
    readonly userId: FieldRef<"Cart_items", 'String'>
    readonly storesId: FieldRef<"Cart_items", 'String'>
    readonly variant_option_valuesId: FieldRef<"Cart_items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cart_items findUnique
   */
  export type Cart_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Cart_items to fetch.
     */
    where: Cart_itemsWhereUniqueInput
  }

  /**
   * Cart_items findUniqueOrThrow
   */
  export type Cart_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Cart_items to fetch.
     */
    where: Cart_itemsWhereUniqueInput
  }

  /**
   * Cart_items findFirst
   */
  export type Cart_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Cart_items to fetch.
     */
    where?: Cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cart_items to fetch.
     */
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cart_items.
     */
    cursor?: Cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cart_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cart_items.
     */
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * Cart_items findFirstOrThrow
   */
  export type Cart_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Cart_items to fetch.
     */
    where?: Cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cart_items to fetch.
     */
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cart_items.
     */
    cursor?: Cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cart_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cart_items.
     */
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * Cart_items findMany
   */
  export type Cart_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * Filter, which Cart_items to fetch.
     */
    where?: Cart_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cart_items to fetch.
     */
    orderBy?: Cart_itemsOrderByWithRelationInput | Cart_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cart_items.
     */
    cursor?: Cart_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cart_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cart_items.
     */
    skip?: number
    distinct?: Cart_itemsScalarFieldEnum | Cart_itemsScalarFieldEnum[]
  }

  /**
   * Cart_items create
   */
  export type Cart_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart_items.
     */
    data: XOR<Cart_itemsCreateInput, Cart_itemsUncheckedCreateInput>
  }

  /**
   * Cart_items createMany
   */
  export type Cart_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cart_items.
     */
    data: Cart_itemsCreateManyInput | Cart_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart_items createManyAndReturn
   */
  export type Cart_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many Cart_items.
     */
    data: Cart_itemsCreateManyInput | Cart_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart_items update
   */
  export type Cart_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart_items.
     */
    data: XOR<Cart_itemsUpdateInput, Cart_itemsUncheckedUpdateInput>
    /**
     * Choose, which Cart_items to update.
     */
    where: Cart_itemsWhereUniqueInput
  }

  /**
   * Cart_items updateMany
   */
  export type Cart_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cart_items.
     */
    data: XOR<Cart_itemsUpdateManyMutationInput, Cart_itemsUncheckedUpdateManyInput>
    /**
     * Filter which Cart_items to update
     */
    where?: Cart_itemsWhereInput
  }

  /**
   * Cart_items updateManyAndReturn
   */
  export type Cart_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * The data used to update Cart_items.
     */
    data: XOR<Cart_itemsUpdateManyMutationInput, Cart_itemsUncheckedUpdateManyInput>
    /**
     * Filter which Cart_items to update
     */
    where?: Cart_itemsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart_items upsert
   */
  export type Cart_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart_items to update in case it exists.
     */
    where: Cart_itemsWhereUniqueInput
    /**
     * In case the Cart_items found by the `where` argument doesn't exist, create a new Cart_items with this data.
     */
    create: XOR<Cart_itemsCreateInput, Cart_itemsUncheckedCreateInput>
    /**
     * In case the Cart_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Cart_itemsUpdateInput, Cart_itemsUncheckedUpdateInput>
  }

  /**
   * Cart_items delete
   */
  export type Cart_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
    /**
     * Filter which Cart_items to delete.
     */
    where: Cart_itemsWhereUniqueInput
  }

  /**
   * Cart_items deleteMany
   */
  export type Cart_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart_items to delete
     */
    where?: Cart_itemsWhereInput
  }

  /**
   * Cart_items without action
   */
  export type Cart_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart_items
     */
    select?: Cart_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart_items
     */
    omit?: Cart_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Cart_itemsInclude<ExtArgs> | null
  }


  /**
   * Model Invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    prices: number | null
  }

  export type InvoicesSumAggregateOutputType = {
    prices: number | null
  }

  export type InvoicesMinAggregateOutputType = {
    id: string | null
    prices: number | null
    status: boolean | null
    receiver_longitude: string | null
    receiver_latitude: string | null
    receiver_district: string | null
    receiver_phone: string | null
    receiver_address: string | null
    receiver_name: string | null
    invoice_number: string | null
    cartsId: string | null
    userId: string | null
    paymentsId: string | null
  }

  export type InvoicesMaxAggregateOutputType = {
    id: string | null
    prices: number | null
    status: boolean | null
    receiver_longitude: string | null
    receiver_latitude: string | null
    receiver_district: string | null
    receiver_phone: string | null
    receiver_address: string | null
    receiver_name: string | null
    invoice_number: string | null
    cartsId: string | null
    userId: string | null
    paymentsId: string | null
  }

  export type InvoicesCountAggregateOutputType = {
    id: number
    prices: number
    status: number
    receiver_longitude: number
    receiver_latitude: number
    receiver_district: number
    receiver_phone: number
    receiver_address: number
    receiver_name: number
    invoice_number: number
    cartsId: number
    userId: number
    paymentsId: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    prices?: true
  }

  export type InvoicesSumAggregateInputType = {
    prices?: true
  }

  export type InvoicesMinAggregateInputType = {
    id?: true
    prices?: true
    status?: true
    receiver_longitude?: true
    receiver_latitude?: true
    receiver_district?: true
    receiver_phone?: true
    receiver_address?: true
    receiver_name?: true
    invoice_number?: true
    cartsId?: true
    userId?: true
    paymentsId?: true
  }

  export type InvoicesMaxAggregateInputType = {
    id?: true
    prices?: true
    status?: true
    receiver_longitude?: true
    receiver_latitude?: true
    receiver_district?: true
    receiver_phone?: true
    receiver_address?: true
    receiver_name?: true
    invoice_number?: true
    cartsId?: true
    userId?: true
    paymentsId?: true
  }

  export type InvoicesCountAggregateInputType = {
    id?: true
    prices?: true
    status?: true
    receiver_longitude?: true
    receiver_latitude?: true
    receiver_district?: true
    receiver_phone?: true
    receiver_address?: true
    receiver_name?: true
    invoice_number?: true
    cartsId?: true
    userId?: true
    paymentsId?: true
    _all?: true
  }

  export type InvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to aggregate.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type InvoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicesWhereInput
    orderBy?: InvoicesOrderByWithAggregationInput | InvoicesOrderByWithAggregationInput[]
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum
    having?: InvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }

  export type InvoicesGroupByOutputType = {
    id: string
    prices: number
    status: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    paymentsId: string
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends InvoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type InvoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prices?: boolean
    status?: boolean
    receiver_longitude?: boolean
    receiver_latitude?: boolean
    receiver_district?: boolean
    receiver_phone?: boolean
    receiver_address?: boolean
    receiver_name?: boolean
    invoice_number?: boolean
    cartsId?: boolean
    userId?: boolean
    paymentsId?: boolean
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    courier_id?: boolean | Invoices$courier_idArgs<ExtArgs>
    payment_id?: boolean | Invoices$payment_idArgs<ExtArgs>
    Confirmation_payment?: boolean | Invoices$Confirmation_paymentArgs<ExtArgs>
    Invoice_histories?: boolean | Invoices$Invoice_historiesArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type InvoicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prices?: boolean
    status?: boolean
    receiver_longitude?: boolean
    receiver_latitude?: boolean
    receiver_district?: boolean
    receiver_phone?: boolean
    receiver_address?: boolean
    receiver_name?: boolean
    invoice_number?: boolean
    cartsId?: boolean
    userId?: boolean
    paymentsId?: boolean
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    payment_id?: boolean | Invoices$payment_idArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type InvoicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prices?: boolean
    status?: boolean
    receiver_longitude?: boolean
    receiver_latitude?: boolean
    receiver_district?: boolean
    receiver_phone?: boolean
    receiver_address?: boolean
    receiver_name?: boolean
    invoice_number?: boolean
    cartsId?: boolean
    userId?: boolean
    paymentsId?: boolean
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    payment_id?: boolean | Invoices$payment_idArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>

  export type InvoicesSelectScalar = {
    id?: boolean
    prices?: boolean
    status?: boolean
    receiver_longitude?: boolean
    receiver_latitude?: boolean
    receiver_district?: boolean
    receiver_phone?: boolean
    receiver_address?: boolean
    receiver_name?: boolean
    invoice_number?: boolean
    cartsId?: boolean
    userId?: boolean
    paymentsId?: boolean
  }

  export type InvoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prices" | "status" | "receiver_longitude" | "receiver_latitude" | "receiver_district" | "receiver_phone" | "receiver_address" | "receiver_name" | "invoice_number" | "cartsId" | "userId" | "paymentsId", ExtArgs["result"]["invoices"]>
  export type InvoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    courier_id?: boolean | Invoices$courier_idArgs<ExtArgs>
    payment_id?: boolean | Invoices$payment_idArgs<ExtArgs>
    Confirmation_payment?: boolean | Invoices$Confirmation_paymentArgs<ExtArgs>
    Invoice_histories?: boolean | Invoices$Invoice_historiesArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    payment_id?: boolean | Invoices$payment_idArgs<ExtArgs>
  }
  export type InvoicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_id?: boolean | CartsDefaultArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
    payment_id?: boolean | Invoices$payment_idArgs<ExtArgs>
  }

  export type $InvoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoices"
    objects: {
      cart_id: Prisma.$CartsPayload<ExtArgs>
      user_id: Prisma.$UserPayload<ExtArgs>
      courier_id: Prisma.$CouriersPayload<ExtArgs> | null
      payment_id: Prisma.$PaymentsPayload<ExtArgs> | null
      Confirmation_payment: Prisma.$Confirmation_paymentPayload<ExtArgs>[]
      Invoice_histories: Prisma.$Invoice_historiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prices: number
      status: boolean
      receiver_longitude: string
      receiver_latitude: string
      receiver_district: string
      receiver_phone: string
      receiver_address: string
      receiver_name: string
      invoice_number: string
      cartsId: string
      userId: string
      paymentsId: string
    }, ExtArgs["result"]["invoices"]>
    composites: {}
  }

  type InvoicesGetPayload<S extends boolean | null | undefined | InvoicesDefaultArgs> = $Result.GetResult<Prisma.$InvoicesPayload, S>

  type InvoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicesCountAggregateInputType | true
    }

  export interface InvoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoices'], meta: { name: 'Invoices' } }
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {InvoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoicesFindUniqueArgs>(args: SelectSubset<T, InvoicesFindUniqueArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Invoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoicesFindFirstArgs>(args?: SelectSubset<T, InvoicesFindFirstArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicesWithIdOnly = await prisma.invoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoicesFindManyArgs>(args?: SelectSubset<T, InvoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Invoices.
     * @param {InvoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
     */
    create<T extends InvoicesCreateArgs>(args: SelectSubset<T, InvoicesCreateArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Invoices.
     * @param {InvoicesCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoicesCreateManyArgs>(args?: SelectSubset<T, InvoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoicesCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoicesWithIdOnly = await prisma.invoices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoicesCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Invoices.
     * @param {InvoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
     */
    delete<T extends InvoicesDeleteArgs>(args: SelectSubset<T, InvoicesDeleteArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Invoices.
     * @param {InvoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoicesUpdateArgs>(args: SelectSubset<T, InvoicesUpdateArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoicesDeleteManyArgs>(args?: SelectSubset<T, InvoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoicesUpdateManyArgs>(args: SelectSubset<T, InvoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoicesUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoicesWithIdOnly = await prisma.invoices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoicesUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Invoices.
     * @param {InvoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
     */
    upsert<T extends InvoicesUpsertArgs>(args: SelectSubset<T, InvoicesUpsertArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoicesCountArgs>(
      args?: Subset<T, InvoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicesGroupByArgs['orderBy'] }
        : { orderBy?: InvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoices model
   */
  readonly fields: InvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart_id<T extends CartsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartsDefaultArgs<ExtArgs>>): Prisma__CartsClient<$Result.GetResult<Prisma.$CartsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user_id<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    courier_id<T extends Invoices$courier_idArgs<ExtArgs> = {}>(args?: Subset<T, Invoices$courier_idArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    payment_id<T extends Invoices$payment_idArgs<ExtArgs> = {}>(args?: Subset<T, Invoices$payment_idArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Confirmation_payment<T extends Invoices$Confirmation_paymentArgs<ExtArgs> = {}>(args?: Subset<T, Invoices$Confirmation_paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Invoice_histories<T extends Invoices$Invoice_historiesArgs<ExtArgs> = {}>(args?: Subset<T, Invoices$Invoice_historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoices model
   */ 
  interface InvoicesFieldRefs {
    readonly id: FieldRef<"Invoices", 'String'>
    readonly prices: FieldRef<"Invoices", 'Int'>
    readonly status: FieldRef<"Invoices", 'Boolean'>
    readonly receiver_longitude: FieldRef<"Invoices", 'String'>
    readonly receiver_latitude: FieldRef<"Invoices", 'String'>
    readonly receiver_district: FieldRef<"Invoices", 'String'>
    readonly receiver_phone: FieldRef<"Invoices", 'String'>
    readonly receiver_address: FieldRef<"Invoices", 'String'>
    readonly receiver_name: FieldRef<"Invoices", 'String'>
    readonly invoice_number: FieldRef<"Invoices", 'String'>
    readonly cartsId: FieldRef<"Invoices", 'String'>
    readonly userId: FieldRef<"Invoices", 'String'>
    readonly paymentsId: FieldRef<"Invoices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoices findUnique
   */
  export type InvoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices findUniqueOrThrow
   */
  export type InvoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices findFirst
   */
  export type InvoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Invoices findFirstOrThrow
   */
  export type InvoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Invoices findMany
   */
  export type InvoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoicesOrderByWithRelationInput | InvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * Invoices create
   */
  export type InvoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoices.
     */
    data: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
  }

  /**
   * Invoices createMany
   */
  export type InvoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoicesCreateManyInput | InvoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoices createManyAndReturn
   */
  export type InvoicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoicesCreateManyInput | InvoicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoices update
   */
  export type InvoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoices.
     */
    data: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
    /**
     * Choose, which Invoices to update.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices updateMany
   */
  export type InvoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoicesWhereInput
  }

  /**
   * Invoices updateManyAndReturn
   */
  export type InvoicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoicesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoices upsert
   */
  export type InvoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoices to update in case it exists.
     */
    where: InvoicesWhereUniqueInput
    /**
     * In case the Invoices found by the `where` argument doesn't exist, create a new Invoices with this data.
     */
    create: XOR<InvoicesCreateInput, InvoicesUncheckedCreateInput>
    /**
     * In case the Invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicesUpdateInput, InvoicesUncheckedUpdateInput>
  }

  /**
   * Invoices delete
   */
  export type InvoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    /**
     * Filter which Invoices to delete.
     */
    where: InvoicesWhereUniqueInput
  }

  /**
   * Invoices deleteMany
   */
  export type InvoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoicesWhereInput
  }

  /**
   * Invoices.courier_id
   */
  export type Invoices$courier_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    where?: CouriersWhereInput
  }

  /**
   * Invoices.payment_id
   */
  export type Invoices$payment_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    where?: PaymentsWhereInput
  }

  /**
   * Invoices.Confirmation_payment
   */
  export type Invoices$Confirmation_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    where?: Confirmation_paymentWhereInput
    orderBy?: Confirmation_paymentOrderByWithRelationInput | Confirmation_paymentOrderByWithRelationInput[]
    cursor?: Confirmation_paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Confirmation_paymentScalarFieldEnum | Confirmation_paymentScalarFieldEnum[]
  }

  /**
   * Invoices.Invoice_histories
   */
  export type Invoices$Invoice_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    where?: Invoice_historiesWhereInput
    orderBy?: Invoice_historiesOrderByWithRelationInput | Invoice_historiesOrderByWithRelationInput[]
    cursor?: Invoice_historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invoice_historiesScalarFieldEnum | Invoice_historiesScalarFieldEnum[]
  }

  /**
   * Invoices without action
   */
  export type InvoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
  }


  /**
   * Model Confirmation_payment
   */

  export type AggregateConfirmation_payment = {
    _count: Confirmation_paymentCountAggregateOutputType | null
    _avg: Confirmation_paymentAvgAggregateOutputType | null
    _sum: Confirmation_paymentSumAggregateOutputType | null
    _min: Confirmation_paymentMinAggregateOutputType | null
    _max: Confirmation_paymentMaxAggregateOutputType | null
  }

  export type Confirmation_paymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type Confirmation_paymentSumAggregateOutputType = {
    amount: number | null
  }

  export type Confirmation_paymentMinAggregateOutputType = {
    id: string | null
    amount: number | null
    bank: string | null
    invoicesId: string | null
  }

  export type Confirmation_paymentMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    bank: string | null
    invoicesId: string | null
  }

  export type Confirmation_paymentCountAggregateOutputType = {
    id: number
    amount: number
    bank: number
    invoicesId: number
    _all: number
  }


  export type Confirmation_paymentAvgAggregateInputType = {
    amount?: true
  }

  export type Confirmation_paymentSumAggregateInputType = {
    amount?: true
  }

  export type Confirmation_paymentMinAggregateInputType = {
    id?: true
    amount?: true
    bank?: true
    invoicesId?: true
  }

  export type Confirmation_paymentMaxAggregateInputType = {
    id?: true
    amount?: true
    bank?: true
    invoicesId?: true
  }

  export type Confirmation_paymentCountAggregateInputType = {
    id?: true
    amount?: true
    bank?: true
    invoicesId?: true
    _all?: true
  }

  export type Confirmation_paymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Confirmation_payment to aggregate.
     */
    where?: Confirmation_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confirmation_payments to fetch.
     */
    orderBy?: Confirmation_paymentOrderByWithRelationInput | Confirmation_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Confirmation_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confirmation_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confirmation_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Confirmation_payments
    **/
    _count?: true | Confirmation_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Confirmation_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Confirmation_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Confirmation_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Confirmation_paymentMaxAggregateInputType
  }

  export type GetConfirmation_paymentAggregateType<T extends Confirmation_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateConfirmation_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfirmation_payment[P]>
      : GetScalarType<T[P], AggregateConfirmation_payment[P]>
  }




  export type Confirmation_paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Confirmation_paymentWhereInput
    orderBy?: Confirmation_paymentOrderByWithAggregationInput | Confirmation_paymentOrderByWithAggregationInput[]
    by: Confirmation_paymentScalarFieldEnum[] | Confirmation_paymentScalarFieldEnum
    having?: Confirmation_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Confirmation_paymentCountAggregateInputType | true
    _avg?: Confirmation_paymentAvgAggregateInputType
    _sum?: Confirmation_paymentSumAggregateInputType
    _min?: Confirmation_paymentMinAggregateInputType
    _max?: Confirmation_paymentMaxAggregateInputType
  }

  export type Confirmation_paymentGroupByOutputType = {
    id: string
    amount: number
    bank: string
    invoicesId: string
    _count: Confirmation_paymentCountAggregateOutputType | null
    _avg: Confirmation_paymentAvgAggregateOutputType | null
    _sum: Confirmation_paymentSumAggregateOutputType | null
    _min: Confirmation_paymentMinAggregateOutputType | null
    _max: Confirmation_paymentMaxAggregateOutputType | null
  }

  type GetConfirmation_paymentGroupByPayload<T extends Confirmation_paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Confirmation_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Confirmation_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Confirmation_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Confirmation_paymentGroupByOutputType[P]>
        }
      >
    >


  export type Confirmation_paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    bank?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["confirmation_payment"]>

  export type Confirmation_paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    bank?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["confirmation_payment"]>

  export type Confirmation_paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    bank?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["confirmation_payment"]>

  export type Confirmation_paymentSelectScalar = {
    id?: boolean
    amount?: boolean
    bank?: boolean
    invoicesId?: boolean
  }

  export type Confirmation_paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "bank" | "invoicesId", ExtArgs["result"]["confirmation_payment"]>
  export type Confirmation_paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }
  export type Confirmation_paymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }
  export type Confirmation_paymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }

  export type $Confirmation_paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Confirmation_payment"
    objects: {
      invoice_id: Prisma.$InvoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      bank: string
      invoicesId: string
    }, ExtArgs["result"]["confirmation_payment"]>
    composites: {}
  }

  type Confirmation_paymentGetPayload<S extends boolean | null | undefined | Confirmation_paymentDefaultArgs> = $Result.GetResult<Prisma.$Confirmation_paymentPayload, S>

  type Confirmation_paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Confirmation_paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Confirmation_paymentCountAggregateInputType | true
    }

  export interface Confirmation_paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Confirmation_payment'], meta: { name: 'Confirmation_payment' } }
    /**
     * Find zero or one Confirmation_payment that matches the filter.
     * @param {Confirmation_paymentFindUniqueArgs} args - Arguments to find a Confirmation_payment
     * @example
     * // Get one Confirmation_payment
     * const confirmation_payment = await prisma.confirmation_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Confirmation_paymentFindUniqueArgs>(args: SelectSubset<T, Confirmation_paymentFindUniqueArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Confirmation_payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Confirmation_paymentFindUniqueOrThrowArgs} args - Arguments to find a Confirmation_payment
     * @example
     * // Get one Confirmation_payment
     * const confirmation_payment = await prisma.confirmation_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Confirmation_paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, Confirmation_paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Confirmation_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentFindFirstArgs} args - Arguments to find a Confirmation_payment
     * @example
     * // Get one Confirmation_payment
     * const confirmation_payment = await prisma.confirmation_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Confirmation_paymentFindFirstArgs>(args?: SelectSubset<T, Confirmation_paymentFindFirstArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Confirmation_payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentFindFirstOrThrowArgs} args - Arguments to find a Confirmation_payment
     * @example
     * // Get one Confirmation_payment
     * const confirmation_payment = await prisma.confirmation_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Confirmation_paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, Confirmation_paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Confirmation_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Confirmation_payments
     * const confirmation_payments = await prisma.confirmation_payment.findMany()
     * 
     * // Get first 10 Confirmation_payments
     * const confirmation_payments = await prisma.confirmation_payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const confirmation_paymentWithIdOnly = await prisma.confirmation_payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Confirmation_paymentFindManyArgs>(args?: SelectSubset<T, Confirmation_paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Confirmation_payment.
     * @param {Confirmation_paymentCreateArgs} args - Arguments to create a Confirmation_payment.
     * @example
     * // Create one Confirmation_payment
     * const Confirmation_payment = await prisma.confirmation_payment.create({
     *   data: {
     *     // ... data to create a Confirmation_payment
     *   }
     * })
     * 
     */
    create<T extends Confirmation_paymentCreateArgs>(args: SelectSubset<T, Confirmation_paymentCreateArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Confirmation_payments.
     * @param {Confirmation_paymentCreateManyArgs} args - Arguments to create many Confirmation_payments.
     * @example
     * // Create many Confirmation_payments
     * const confirmation_payment = await prisma.confirmation_payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Confirmation_paymentCreateManyArgs>(args?: SelectSubset<T, Confirmation_paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Confirmation_payments and returns the data saved in the database.
     * @param {Confirmation_paymentCreateManyAndReturnArgs} args - Arguments to create many Confirmation_payments.
     * @example
     * // Create many Confirmation_payments
     * const confirmation_payment = await prisma.confirmation_payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Confirmation_payments and only return the `id`
     * const confirmation_paymentWithIdOnly = await prisma.confirmation_payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Confirmation_paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, Confirmation_paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Confirmation_payment.
     * @param {Confirmation_paymentDeleteArgs} args - Arguments to delete one Confirmation_payment.
     * @example
     * // Delete one Confirmation_payment
     * const Confirmation_payment = await prisma.confirmation_payment.delete({
     *   where: {
     *     // ... filter to delete one Confirmation_payment
     *   }
     * })
     * 
     */
    delete<T extends Confirmation_paymentDeleteArgs>(args: SelectSubset<T, Confirmation_paymentDeleteArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Confirmation_payment.
     * @param {Confirmation_paymentUpdateArgs} args - Arguments to update one Confirmation_payment.
     * @example
     * // Update one Confirmation_payment
     * const confirmation_payment = await prisma.confirmation_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Confirmation_paymentUpdateArgs>(args: SelectSubset<T, Confirmation_paymentUpdateArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Confirmation_payments.
     * @param {Confirmation_paymentDeleteManyArgs} args - Arguments to filter Confirmation_payments to delete.
     * @example
     * // Delete a few Confirmation_payments
     * const { count } = await prisma.confirmation_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Confirmation_paymentDeleteManyArgs>(args?: SelectSubset<T, Confirmation_paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confirmation_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Confirmation_payments
     * const confirmation_payment = await prisma.confirmation_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Confirmation_paymentUpdateManyArgs>(args: SelectSubset<T, Confirmation_paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confirmation_payments and returns the data updated in the database.
     * @param {Confirmation_paymentUpdateManyAndReturnArgs} args - Arguments to update many Confirmation_payments.
     * @example
     * // Update many Confirmation_payments
     * const confirmation_payment = await prisma.confirmation_payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Confirmation_payments and only return the `id`
     * const confirmation_paymentWithIdOnly = await prisma.confirmation_payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Confirmation_paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, Confirmation_paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Confirmation_payment.
     * @param {Confirmation_paymentUpsertArgs} args - Arguments to update or create a Confirmation_payment.
     * @example
     * // Update or create a Confirmation_payment
     * const confirmation_payment = await prisma.confirmation_payment.upsert({
     *   create: {
     *     // ... data to create a Confirmation_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Confirmation_payment we want to update
     *   }
     * })
     */
    upsert<T extends Confirmation_paymentUpsertArgs>(args: SelectSubset<T, Confirmation_paymentUpsertArgs<ExtArgs>>): Prisma__Confirmation_paymentClient<$Result.GetResult<Prisma.$Confirmation_paymentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Confirmation_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentCountArgs} args - Arguments to filter Confirmation_payments to count.
     * @example
     * // Count the number of Confirmation_payments
     * const count = await prisma.confirmation_payment.count({
     *   where: {
     *     // ... the filter for the Confirmation_payments we want to count
     *   }
     * })
    **/
    count<T extends Confirmation_paymentCountArgs>(
      args?: Subset<T, Confirmation_paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Confirmation_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Confirmation_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Confirmation_paymentAggregateArgs>(args: Subset<T, Confirmation_paymentAggregateArgs>): Prisma.PrismaPromise<GetConfirmation_paymentAggregateType<T>>

    /**
     * Group by Confirmation_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmation_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Confirmation_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Confirmation_paymentGroupByArgs['orderBy'] }
        : { orderBy?: Confirmation_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Confirmation_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfirmation_paymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Confirmation_payment model
   */
  readonly fields: Confirmation_paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Confirmation_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Confirmation_paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_id<T extends InvoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoicesDefaultArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Confirmation_payment model
   */ 
  interface Confirmation_paymentFieldRefs {
    readonly id: FieldRef<"Confirmation_payment", 'String'>
    readonly amount: FieldRef<"Confirmation_payment", 'Int'>
    readonly bank: FieldRef<"Confirmation_payment", 'String'>
    readonly invoicesId: FieldRef<"Confirmation_payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Confirmation_payment findUnique
   */
  export type Confirmation_paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * Filter, which Confirmation_payment to fetch.
     */
    where: Confirmation_paymentWhereUniqueInput
  }

  /**
   * Confirmation_payment findUniqueOrThrow
   */
  export type Confirmation_paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * Filter, which Confirmation_payment to fetch.
     */
    where: Confirmation_paymentWhereUniqueInput
  }

  /**
   * Confirmation_payment findFirst
   */
  export type Confirmation_paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * Filter, which Confirmation_payment to fetch.
     */
    where?: Confirmation_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confirmation_payments to fetch.
     */
    orderBy?: Confirmation_paymentOrderByWithRelationInput | Confirmation_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Confirmation_payments.
     */
    cursor?: Confirmation_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confirmation_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confirmation_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Confirmation_payments.
     */
    distinct?: Confirmation_paymentScalarFieldEnum | Confirmation_paymentScalarFieldEnum[]
  }

  /**
   * Confirmation_payment findFirstOrThrow
   */
  export type Confirmation_paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * Filter, which Confirmation_payment to fetch.
     */
    where?: Confirmation_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confirmation_payments to fetch.
     */
    orderBy?: Confirmation_paymentOrderByWithRelationInput | Confirmation_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Confirmation_payments.
     */
    cursor?: Confirmation_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confirmation_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confirmation_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Confirmation_payments.
     */
    distinct?: Confirmation_paymentScalarFieldEnum | Confirmation_paymentScalarFieldEnum[]
  }

  /**
   * Confirmation_payment findMany
   */
  export type Confirmation_paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * Filter, which Confirmation_payments to fetch.
     */
    where?: Confirmation_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confirmation_payments to fetch.
     */
    orderBy?: Confirmation_paymentOrderByWithRelationInput | Confirmation_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Confirmation_payments.
     */
    cursor?: Confirmation_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confirmation_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confirmation_payments.
     */
    skip?: number
    distinct?: Confirmation_paymentScalarFieldEnum | Confirmation_paymentScalarFieldEnum[]
  }

  /**
   * Confirmation_payment create
   */
  export type Confirmation_paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Confirmation_payment.
     */
    data: XOR<Confirmation_paymentCreateInput, Confirmation_paymentUncheckedCreateInput>
  }

  /**
   * Confirmation_payment createMany
   */
  export type Confirmation_paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Confirmation_payments.
     */
    data: Confirmation_paymentCreateManyInput | Confirmation_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Confirmation_payment createManyAndReturn
   */
  export type Confirmation_paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * The data used to create many Confirmation_payments.
     */
    data: Confirmation_paymentCreateManyInput | Confirmation_paymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Confirmation_payment update
   */
  export type Confirmation_paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Confirmation_payment.
     */
    data: XOR<Confirmation_paymentUpdateInput, Confirmation_paymentUncheckedUpdateInput>
    /**
     * Choose, which Confirmation_payment to update.
     */
    where: Confirmation_paymentWhereUniqueInput
  }

  /**
   * Confirmation_payment updateMany
   */
  export type Confirmation_paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Confirmation_payments.
     */
    data: XOR<Confirmation_paymentUpdateManyMutationInput, Confirmation_paymentUncheckedUpdateManyInput>
    /**
     * Filter which Confirmation_payments to update
     */
    where?: Confirmation_paymentWhereInput
  }

  /**
   * Confirmation_payment updateManyAndReturn
   */
  export type Confirmation_paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * The data used to update Confirmation_payments.
     */
    data: XOR<Confirmation_paymentUpdateManyMutationInput, Confirmation_paymentUncheckedUpdateManyInput>
    /**
     * Filter which Confirmation_payments to update
     */
    where?: Confirmation_paymentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Confirmation_payment upsert
   */
  export type Confirmation_paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Confirmation_payment to update in case it exists.
     */
    where: Confirmation_paymentWhereUniqueInput
    /**
     * In case the Confirmation_payment found by the `where` argument doesn't exist, create a new Confirmation_payment with this data.
     */
    create: XOR<Confirmation_paymentCreateInput, Confirmation_paymentUncheckedCreateInput>
    /**
     * In case the Confirmation_payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Confirmation_paymentUpdateInput, Confirmation_paymentUncheckedUpdateInput>
  }

  /**
   * Confirmation_payment delete
   */
  export type Confirmation_paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
    /**
     * Filter which Confirmation_payment to delete.
     */
    where: Confirmation_paymentWhereUniqueInput
  }

  /**
   * Confirmation_payment deleteMany
   */
  export type Confirmation_paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Confirmation_payments to delete
     */
    where?: Confirmation_paymentWhereInput
  }

  /**
   * Confirmation_payment without action
   */
  export type Confirmation_paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Confirmation_payment
     */
    select?: Confirmation_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Confirmation_payment
     */
    omit?: Confirmation_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Confirmation_paymentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice_histories
   */

  export type AggregateInvoice_histories = {
    _count: Invoice_historiesCountAggregateOutputType | null
    _min: Invoice_historiesMinAggregateOutputType | null
    _max: Invoice_historiesMaxAggregateOutputType | null
  }

  export type Invoice_historiesMinAggregateOutputType = {
    id: string | null
    status: boolean | null
    created_at: Date | null
    invoicesId: string | null
  }

  export type Invoice_historiesMaxAggregateOutputType = {
    id: string | null
    status: boolean | null
    created_at: Date | null
    invoicesId: string | null
  }

  export type Invoice_historiesCountAggregateOutputType = {
    id: number
    status: number
    created_at: number
    invoicesId: number
    _all: number
  }


  export type Invoice_historiesMinAggregateInputType = {
    id?: true
    status?: true
    created_at?: true
    invoicesId?: true
  }

  export type Invoice_historiesMaxAggregateInputType = {
    id?: true
    status?: true
    created_at?: true
    invoicesId?: true
  }

  export type Invoice_historiesCountAggregateInputType = {
    id?: true
    status?: true
    created_at?: true
    invoicesId?: true
    _all?: true
  }

  export type Invoice_historiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice_histories to aggregate.
     */
    where?: Invoice_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoice_histories to fetch.
     */
    orderBy?: Invoice_historiesOrderByWithRelationInput | Invoice_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Invoice_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoice_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoice_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoice_histories
    **/
    _count?: true | Invoice_historiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invoice_historiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invoice_historiesMaxAggregateInputType
  }

  export type GetInvoice_historiesAggregateType<T extends Invoice_historiesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice_histories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice_histories[P]>
      : GetScalarType<T[P], AggregateInvoice_histories[P]>
  }




  export type Invoice_historiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Invoice_historiesWhereInput
    orderBy?: Invoice_historiesOrderByWithAggregationInput | Invoice_historiesOrderByWithAggregationInput[]
    by: Invoice_historiesScalarFieldEnum[] | Invoice_historiesScalarFieldEnum
    having?: Invoice_historiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invoice_historiesCountAggregateInputType | true
    _min?: Invoice_historiesMinAggregateInputType
    _max?: Invoice_historiesMaxAggregateInputType
  }

  export type Invoice_historiesGroupByOutputType = {
    id: string
    status: boolean
    created_at: Date | null
    invoicesId: string
    _count: Invoice_historiesCountAggregateOutputType | null
    _min: Invoice_historiesMinAggregateOutputType | null
    _max: Invoice_historiesMaxAggregateOutputType | null
  }

  type GetInvoice_historiesGroupByPayload<T extends Invoice_historiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invoice_historiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invoice_historiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invoice_historiesGroupByOutputType[P]>
            : GetScalarType<T[P], Invoice_historiesGroupByOutputType[P]>
        }
      >
    >


  export type Invoice_historiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    created_at?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_histories"]>

  export type Invoice_historiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    created_at?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_histories"]>

  export type Invoice_historiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    created_at?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice_histories"]>

  export type Invoice_historiesSelectScalar = {
    id?: boolean
    status?: boolean
    created_at?: boolean
    invoicesId?: boolean
  }

  export type Invoice_historiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "created_at" | "invoicesId", ExtArgs["result"]["invoice_histories"]>
  export type Invoice_historiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }
  export type Invoice_historiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }
  export type Invoice_historiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }

  export type $Invoice_historiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice_histories"
    objects: {
      invoice_id: Prisma.$InvoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: boolean
      created_at: Date | null
      invoicesId: string
    }, ExtArgs["result"]["invoice_histories"]>
    composites: {}
  }

  type Invoice_historiesGetPayload<S extends boolean | null | undefined | Invoice_historiesDefaultArgs> = $Result.GetResult<Prisma.$Invoice_historiesPayload, S>

  type Invoice_historiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Invoice_historiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Invoice_historiesCountAggregateInputType | true
    }

  export interface Invoice_historiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice_histories'], meta: { name: 'Invoice_histories' } }
    /**
     * Find zero or one Invoice_histories that matches the filter.
     * @param {Invoice_historiesFindUniqueArgs} args - Arguments to find a Invoice_histories
     * @example
     * // Get one Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Invoice_historiesFindUniqueArgs>(args: SelectSubset<T, Invoice_historiesFindUniqueArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Invoice_histories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Invoice_historiesFindUniqueOrThrowArgs} args - Arguments to find a Invoice_histories
     * @example
     * // Get one Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Invoice_historiesFindUniqueOrThrowArgs>(args: SelectSubset<T, Invoice_historiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Invoice_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesFindFirstArgs} args - Arguments to find a Invoice_histories
     * @example
     * // Get one Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Invoice_historiesFindFirstArgs>(args?: SelectSubset<T, Invoice_historiesFindFirstArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Invoice_histories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesFindFirstOrThrowArgs} args - Arguments to find a Invoice_histories
     * @example
     * // Get one Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Invoice_historiesFindFirstOrThrowArgs>(args?: SelectSubset<T, Invoice_historiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Invoice_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.findMany()
     * 
     * // Get first 10 Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoice_historiesWithIdOnly = await prisma.invoice_histories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Invoice_historiesFindManyArgs>(args?: SelectSubset<T, Invoice_historiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Invoice_histories.
     * @param {Invoice_historiesCreateArgs} args - Arguments to create a Invoice_histories.
     * @example
     * // Create one Invoice_histories
     * const Invoice_histories = await prisma.invoice_histories.create({
     *   data: {
     *     // ... data to create a Invoice_histories
     *   }
     * })
     * 
     */
    create<T extends Invoice_historiesCreateArgs>(args: SelectSubset<T, Invoice_historiesCreateArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Invoice_histories.
     * @param {Invoice_historiesCreateManyArgs} args - Arguments to create many Invoice_histories.
     * @example
     * // Create many Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Invoice_historiesCreateManyArgs>(args?: SelectSubset<T, Invoice_historiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoice_histories and returns the data saved in the database.
     * @param {Invoice_historiesCreateManyAndReturnArgs} args - Arguments to create many Invoice_histories.
     * @example
     * // Create many Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoice_histories and only return the `id`
     * const invoice_historiesWithIdOnly = await prisma.invoice_histories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Invoice_historiesCreateManyAndReturnArgs>(args?: SelectSubset<T, Invoice_historiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Invoice_histories.
     * @param {Invoice_historiesDeleteArgs} args - Arguments to delete one Invoice_histories.
     * @example
     * // Delete one Invoice_histories
     * const Invoice_histories = await prisma.invoice_histories.delete({
     *   where: {
     *     // ... filter to delete one Invoice_histories
     *   }
     * })
     * 
     */
    delete<T extends Invoice_historiesDeleteArgs>(args: SelectSubset<T, Invoice_historiesDeleteArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Invoice_histories.
     * @param {Invoice_historiesUpdateArgs} args - Arguments to update one Invoice_histories.
     * @example
     * // Update one Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Invoice_historiesUpdateArgs>(args: SelectSubset<T, Invoice_historiesUpdateArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Invoice_histories.
     * @param {Invoice_historiesDeleteManyArgs} args - Arguments to filter Invoice_histories to delete.
     * @example
     * // Delete a few Invoice_histories
     * const { count } = await prisma.invoice_histories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Invoice_historiesDeleteManyArgs>(args?: SelectSubset<T, Invoice_historiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Invoice_historiesUpdateManyArgs>(args: SelectSubset<T, Invoice_historiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoice_histories and returns the data updated in the database.
     * @param {Invoice_historiesUpdateManyAndReturnArgs} args - Arguments to update many Invoice_histories.
     * @example
     * // Update many Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoice_histories and only return the `id`
     * const invoice_historiesWithIdOnly = await prisma.invoice_histories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Invoice_historiesUpdateManyAndReturnArgs>(args: SelectSubset<T, Invoice_historiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Invoice_histories.
     * @param {Invoice_historiesUpsertArgs} args - Arguments to update or create a Invoice_histories.
     * @example
     * // Update or create a Invoice_histories
     * const invoice_histories = await prisma.invoice_histories.upsert({
     *   create: {
     *     // ... data to create a Invoice_histories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice_histories we want to update
     *   }
     * })
     */
    upsert<T extends Invoice_historiesUpsertArgs>(args: SelectSubset<T, Invoice_historiesUpsertArgs<ExtArgs>>): Prisma__Invoice_historiesClient<$Result.GetResult<Prisma.$Invoice_historiesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Invoice_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesCountArgs} args - Arguments to filter Invoice_histories to count.
     * @example
     * // Count the number of Invoice_histories
     * const count = await prisma.invoice_histories.count({
     *   where: {
     *     // ... the filter for the Invoice_histories we want to count
     *   }
     * })
    **/
    count<T extends Invoice_historiesCountArgs>(
      args?: Subset<T, Invoice_historiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invoice_historiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invoice_historiesAggregateArgs>(args: Subset<T, Invoice_historiesAggregateArgs>): Prisma.PrismaPromise<GetInvoice_historiesAggregateType<T>>

    /**
     * Group by Invoice_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invoice_historiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Invoice_historiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Invoice_historiesGroupByArgs['orderBy'] }
        : { orderBy?: Invoice_historiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Invoice_historiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoice_historiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice_histories model
   */
  readonly fields: Invoice_historiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice_histories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Invoice_historiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_id<T extends InvoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoicesDefaultArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice_histories model
   */ 
  interface Invoice_historiesFieldRefs {
    readonly id: FieldRef<"Invoice_histories", 'String'>
    readonly status: FieldRef<"Invoice_histories", 'Boolean'>
    readonly created_at: FieldRef<"Invoice_histories", 'DateTime'>
    readonly invoicesId: FieldRef<"Invoice_histories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice_histories findUnique
   */
  export type Invoice_historiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * Filter, which Invoice_histories to fetch.
     */
    where: Invoice_historiesWhereUniqueInput
  }

  /**
   * Invoice_histories findUniqueOrThrow
   */
  export type Invoice_historiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * Filter, which Invoice_histories to fetch.
     */
    where: Invoice_historiesWhereUniqueInput
  }

  /**
   * Invoice_histories findFirst
   */
  export type Invoice_historiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * Filter, which Invoice_histories to fetch.
     */
    where?: Invoice_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoice_histories to fetch.
     */
    orderBy?: Invoice_historiesOrderByWithRelationInput | Invoice_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoice_histories.
     */
    cursor?: Invoice_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoice_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoice_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoice_histories.
     */
    distinct?: Invoice_historiesScalarFieldEnum | Invoice_historiesScalarFieldEnum[]
  }

  /**
   * Invoice_histories findFirstOrThrow
   */
  export type Invoice_historiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * Filter, which Invoice_histories to fetch.
     */
    where?: Invoice_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoice_histories to fetch.
     */
    orderBy?: Invoice_historiesOrderByWithRelationInput | Invoice_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoice_histories.
     */
    cursor?: Invoice_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoice_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoice_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoice_histories.
     */
    distinct?: Invoice_historiesScalarFieldEnum | Invoice_historiesScalarFieldEnum[]
  }

  /**
   * Invoice_histories findMany
   */
  export type Invoice_historiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * Filter, which Invoice_histories to fetch.
     */
    where?: Invoice_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoice_histories to fetch.
     */
    orderBy?: Invoice_historiesOrderByWithRelationInput | Invoice_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoice_histories.
     */
    cursor?: Invoice_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoice_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoice_histories.
     */
    skip?: number
    distinct?: Invoice_historiesScalarFieldEnum | Invoice_historiesScalarFieldEnum[]
  }

  /**
   * Invoice_histories create
   */
  export type Invoice_historiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice_histories.
     */
    data: XOR<Invoice_historiesCreateInput, Invoice_historiesUncheckedCreateInput>
  }

  /**
   * Invoice_histories createMany
   */
  export type Invoice_historiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoice_histories.
     */
    data: Invoice_historiesCreateManyInput | Invoice_historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice_histories createManyAndReturn
   */
  export type Invoice_historiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * The data used to create many Invoice_histories.
     */
    data: Invoice_historiesCreateManyInput | Invoice_historiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice_histories update
   */
  export type Invoice_historiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice_histories.
     */
    data: XOR<Invoice_historiesUpdateInput, Invoice_historiesUncheckedUpdateInput>
    /**
     * Choose, which Invoice_histories to update.
     */
    where: Invoice_historiesWhereUniqueInput
  }

  /**
   * Invoice_histories updateMany
   */
  export type Invoice_historiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoice_histories.
     */
    data: XOR<Invoice_historiesUpdateManyMutationInput, Invoice_historiesUncheckedUpdateManyInput>
    /**
     * Filter which Invoice_histories to update
     */
    where?: Invoice_historiesWhereInput
  }

  /**
   * Invoice_histories updateManyAndReturn
   */
  export type Invoice_historiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * The data used to update Invoice_histories.
     */
    data: XOR<Invoice_historiesUpdateManyMutationInput, Invoice_historiesUncheckedUpdateManyInput>
    /**
     * Filter which Invoice_histories to update
     */
    where?: Invoice_historiesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice_histories upsert
   */
  export type Invoice_historiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice_histories to update in case it exists.
     */
    where: Invoice_historiesWhereUniqueInput
    /**
     * In case the Invoice_histories found by the `where` argument doesn't exist, create a new Invoice_histories with this data.
     */
    create: XOR<Invoice_historiesCreateInput, Invoice_historiesUncheckedCreateInput>
    /**
     * In case the Invoice_histories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Invoice_historiesUpdateInput, Invoice_historiesUncheckedUpdateInput>
  }

  /**
   * Invoice_histories delete
   */
  export type Invoice_historiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
    /**
     * Filter which Invoice_histories to delete.
     */
    where: Invoice_historiesWhereUniqueInput
  }

  /**
   * Invoice_histories deleteMany
   */
  export type Invoice_historiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice_histories to delete
     */
    where?: Invoice_historiesWhereInput
  }

  /**
   * Invoice_histories without action
   */
  export type Invoice_historiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice_histories
     */
    select?: Invoice_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice_histories
     */
    omit?: Invoice_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Invoice_historiesInclude<ExtArgs> | null
  }


  /**
   * Model Payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    bank: string | null
    amount: number | null
    status: boolean | null
    moota_transaction_id: string | null
    userId: string | null
    invoicesId: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    bank: string | null
    amount: number | null
    status: boolean | null
    moota_transaction_id: string | null
    userId: string | null
    invoicesId: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    bank: number
    amount: number
    status: number
    moota_transaction_id: number
    userId: number
    invoicesId: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    bank?: true
    amount?: true
    status?: true
    moota_transaction_id?: true
    userId?: true
    invoicesId?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    bank?: true
    amount?: true
    status?: true
    moota_transaction_id?: true
    userId?: true
    invoicesId?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    bank?: true
    amount?: true
    status?: true
    moota_transaction_id?: true
    userId?: true
    invoicesId?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to aggregate.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type PaymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentsWhereInput
    orderBy?: PaymentsOrderByWithAggregationInput | PaymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: PaymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    bank: string
    amount: number
    status: boolean
    moota_transaction_id: string | null
    userId: string
    invoicesId: string
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends PaymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank?: boolean
    amount?: boolean
    status?: boolean
    moota_transaction_id?: boolean
    userId?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | Payments$invoice_idArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank?: boolean
    amount?: boolean
    status?: boolean
    moota_transaction_id?: boolean
    userId?: boolean
    invoicesId?: boolean
    user_id?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank?: boolean
    amount?: boolean
    status?: boolean
    moota_transaction_id?: boolean
    userId?: boolean
    invoicesId?: boolean
    user_id?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type PaymentsSelectScalar = {
    id?: boolean
    bank?: boolean
    amount?: boolean
    status?: boolean
    moota_transaction_id?: boolean
    userId?: boolean
    invoicesId?: boolean
  }

  export type PaymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bank" | "amount" | "status" | "moota_transaction_id" | "userId" | "invoicesId", ExtArgs["result"]["payments"]>
  export type PaymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | Payments$invoice_idArgs<ExtArgs>
    user_id?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_id?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_id?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payments"
    objects: {
      invoice_id: Prisma.$InvoicesPayload<ExtArgs> | null
      user_id: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bank: string
      amount: number
      status: boolean
      moota_transaction_id: string | null
      userId: string
      invoicesId: string
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type PaymentsGetPayload<S extends boolean | null | undefined | PaymentsDefaultArgs> = $Result.GetResult<Prisma.$PaymentsPayload, S>

  type PaymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface PaymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payments'], meta: { name: 'Payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {PaymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentsFindUniqueArgs>(args: SelectSubset<T, PaymentsFindUniqueArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentsFindFirstArgs>(args?: SelectSubset<T, PaymentsFindFirstArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentsFindManyArgs>(args?: SelectSubset<T, PaymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Payments.
     * @param {PaymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends PaymentsCreateArgs>(args: SelectSubset<T, PaymentsCreateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Payments.
     * @param {PaymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentsCreateManyArgs>(args?: SelectSubset<T, PaymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Payments.
     * @param {PaymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends PaymentsDeleteArgs>(args: SelectSubset<T, PaymentsDeleteArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Payments.
     * @param {PaymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentsUpdateArgs>(args: SelectSubset<T, PaymentsUpdateArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentsDeleteManyArgs>(args?: SelectSubset<T, PaymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentsUpdateManyArgs>(args: SelectSubset<T, PaymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Payments.
     * @param {PaymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends PaymentsUpsertArgs>(args: SelectSubset<T, PaymentsUpsertArgs<ExtArgs>>): Prisma__PaymentsClient<$Result.GetResult<Prisma.$PaymentsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentsCountArgs>(
      args?: Subset<T, PaymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payments model
   */
  readonly fields: PaymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_id<T extends Payments$invoice_idArgs<ExtArgs> = {}>(args?: Subset<T, Payments$invoice_idArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    user_id<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payments model
   */ 
  interface PaymentsFieldRefs {
    readonly id: FieldRef<"Payments", 'String'>
    readonly bank: FieldRef<"Payments", 'String'>
    readonly amount: FieldRef<"Payments", 'Int'>
    readonly status: FieldRef<"Payments", 'Boolean'>
    readonly moota_transaction_id: FieldRef<"Payments", 'String'>
    readonly userId: FieldRef<"Payments", 'String'>
    readonly invoicesId: FieldRef<"Payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payments findUnique
   */
  export type PaymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findUniqueOrThrow
   */
  export type PaymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments findFirst
   */
  export type PaymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findFirstOrThrow
   */
  export type PaymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments findMany
   */
  export type PaymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentsOrderByWithRelationInput | PaymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * Payments create
   */
  export type PaymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payments.
     */
    data: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
  }

  /**
   * Payments createMany
   */
  export type PaymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payments createManyAndReturn
   */
  export type PaymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentsCreateManyInput | PaymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments update
   */
  export type PaymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payments.
     */
    data: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
    /**
     * Choose, which Payments to update.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments updateMany
   */
  export type PaymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
  }

  /**
   * Payments updateManyAndReturn
   */
  export type PaymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payments upsert
   */
  export type PaymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payments to update in case it exists.
     */
    where: PaymentsWhereUniqueInput
    /**
     * In case the Payments found by the `where` argument doesn't exist, create a new Payments with this data.
     */
    create: XOR<PaymentsCreateInput, PaymentsUncheckedCreateInput>
    /**
     * In case the Payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentsUpdateInput, PaymentsUncheckedUpdateInput>
  }

  /**
   * Payments delete
   */
  export type PaymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
    /**
     * Filter which Payments to delete.
     */
    where: PaymentsWhereUniqueInput
  }

  /**
   * Payments deleteMany
   */
  export type PaymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentsWhereInput
  }

  /**
   * Payments.invoice_id
   */
  export type Payments$invoice_idArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoices
     */
    select?: InvoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoices
     */
    omit?: InvoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicesInclude<ExtArgs> | null
    where?: InvoicesWhereInput
  }

  /**
   * Payments without action
   */
  export type PaymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payments
     */
    select?: PaymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payments
     */
    omit?: PaymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentsInclude<ExtArgs> | null
  }


  /**
   * Model Couriers
   */

  export type AggregateCouriers = {
    _count: CouriersCountAggregateOutputType | null
    _avg: CouriersAvgAggregateOutputType | null
    _sum: CouriersSumAggregateOutputType | null
    _min: CouriersMinAggregateOutputType | null
    _max: CouriersMaxAggregateOutputType | null
  }

  export type CouriersAvgAggregateOutputType = {
    price: number | null
  }

  export type CouriersSumAggregateOutputType = {
    price: number | null
  }

  export type CouriersMinAggregateOutputType = {
    id: string | null
    courier_code: string | null
    courier_service_name: string | null
    courier_service_code: string | null
    price: number | null
    order_id: string | null
    invoicesId: string | null
  }

  export type CouriersMaxAggregateOutputType = {
    id: string | null
    courier_code: string | null
    courier_service_name: string | null
    courier_service_code: string | null
    price: number | null
    order_id: string | null
    invoicesId: string | null
  }

  export type CouriersCountAggregateOutputType = {
    id: number
    courier_code: number
    courier_service_name: number
    courier_service_code: number
    price: number
    order_id: number
    invoicesId: number
    _all: number
  }


  export type CouriersAvgAggregateInputType = {
    price?: true
  }

  export type CouriersSumAggregateInputType = {
    price?: true
  }

  export type CouriersMinAggregateInputType = {
    id?: true
    courier_code?: true
    courier_service_name?: true
    courier_service_code?: true
    price?: true
    order_id?: true
    invoicesId?: true
  }

  export type CouriersMaxAggregateInputType = {
    id?: true
    courier_code?: true
    courier_service_name?: true
    courier_service_code?: true
    price?: true
    order_id?: true
    invoicesId?: true
  }

  export type CouriersCountAggregateInputType = {
    id?: true
    courier_code?: true
    courier_service_name?: true
    courier_service_code?: true
    price?: true
    order_id?: true
    invoicesId?: true
    _all?: true
  }

  export type CouriersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Couriers to aggregate.
     */
    where?: CouriersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CouriersOrderByWithRelationInput | CouriersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouriersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Couriers
    **/
    _count?: true | CouriersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouriersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouriersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouriersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouriersMaxAggregateInputType
  }

  export type GetCouriersAggregateType<T extends CouriersAggregateArgs> = {
        [P in keyof T & keyof AggregateCouriers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouriers[P]>
      : GetScalarType<T[P], AggregateCouriers[P]>
  }




  export type CouriersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouriersWhereInput
    orderBy?: CouriersOrderByWithAggregationInput | CouriersOrderByWithAggregationInput[]
    by: CouriersScalarFieldEnum[] | CouriersScalarFieldEnum
    having?: CouriersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouriersCountAggregateInputType | true
    _avg?: CouriersAvgAggregateInputType
    _sum?: CouriersSumAggregateInputType
    _min?: CouriersMinAggregateInputType
    _max?: CouriersMaxAggregateInputType
  }

  export type CouriersGroupByOutputType = {
    id: string
    courier_code: string
    courier_service_name: string
    courier_service_code: string
    price: number
    order_id: string
    invoicesId: string
    _count: CouriersCountAggregateOutputType | null
    _avg: CouriersAvgAggregateOutputType | null
    _sum: CouriersSumAggregateOutputType | null
    _min: CouriersMinAggregateOutputType | null
    _max: CouriersMaxAggregateOutputType | null
  }

  type GetCouriersGroupByPayload<T extends CouriersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouriersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouriersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouriersGroupByOutputType[P]>
            : GetScalarType<T[P], CouriersGroupByOutputType[P]>
        }
      >
    >


  export type CouriersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courier_code?: boolean
    courier_service_name?: boolean
    courier_service_code?: boolean
    price?: boolean
    order_id?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couriers"]>

  export type CouriersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courier_code?: boolean
    courier_service_name?: boolean
    courier_service_code?: boolean
    price?: boolean
    order_id?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couriers"]>

  export type CouriersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courier_code?: boolean
    courier_service_name?: boolean
    courier_service_code?: boolean
    price?: boolean
    order_id?: boolean
    invoicesId?: boolean
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couriers"]>

  export type CouriersSelectScalar = {
    id?: boolean
    courier_code?: boolean
    courier_service_name?: boolean
    courier_service_code?: boolean
    price?: boolean
    order_id?: boolean
    invoicesId?: boolean
  }

  export type CouriersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courier_code" | "courier_service_name" | "courier_service_code" | "price" | "order_id" | "invoicesId", ExtArgs["result"]["couriers"]>
  export type CouriersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }
  export type CouriersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }
  export type CouriersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice_id?: boolean | InvoicesDefaultArgs<ExtArgs>
  }

  export type $CouriersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Couriers"
    objects: {
      invoice_id: Prisma.$InvoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courier_code: string
      courier_service_name: string
      courier_service_code: string
      price: number
      order_id: string
      invoicesId: string
    }, ExtArgs["result"]["couriers"]>
    composites: {}
  }

  type CouriersGetPayload<S extends boolean | null | undefined | CouriersDefaultArgs> = $Result.GetResult<Prisma.$CouriersPayload, S>

  type CouriersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouriersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouriersCountAggregateInputType | true
    }

  export interface CouriersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Couriers'], meta: { name: 'Couriers' } }
    /**
     * Find zero or one Couriers that matches the filter.
     * @param {CouriersFindUniqueArgs} args - Arguments to find a Couriers
     * @example
     * // Get one Couriers
     * const couriers = await prisma.couriers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouriersFindUniqueArgs>(args: SelectSubset<T, CouriersFindUniqueArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Couriers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouriersFindUniqueOrThrowArgs} args - Arguments to find a Couriers
     * @example
     * // Get one Couriers
     * const couriers = await prisma.couriers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouriersFindUniqueOrThrowArgs>(args: SelectSubset<T, CouriersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Couriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersFindFirstArgs} args - Arguments to find a Couriers
     * @example
     * // Get one Couriers
     * const couriers = await prisma.couriers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouriersFindFirstArgs>(args?: SelectSubset<T, CouriersFindFirstArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Couriers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersFindFirstOrThrowArgs} args - Arguments to find a Couriers
     * @example
     * // Get one Couriers
     * const couriers = await prisma.couriers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouriersFindFirstOrThrowArgs>(args?: SelectSubset<T, CouriersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Couriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Couriers
     * const couriers = await prisma.couriers.findMany()
     * 
     * // Get first 10 Couriers
     * const couriers = await prisma.couriers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couriersWithIdOnly = await prisma.couriers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouriersFindManyArgs>(args?: SelectSubset<T, CouriersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Couriers.
     * @param {CouriersCreateArgs} args - Arguments to create a Couriers.
     * @example
     * // Create one Couriers
     * const Couriers = await prisma.couriers.create({
     *   data: {
     *     // ... data to create a Couriers
     *   }
     * })
     * 
     */
    create<T extends CouriersCreateArgs>(args: SelectSubset<T, CouriersCreateArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Couriers.
     * @param {CouriersCreateManyArgs} args - Arguments to create many Couriers.
     * @example
     * // Create many Couriers
     * const couriers = await prisma.couriers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouriersCreateManyArgs>(args?: SelectSubset<T, CouriersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Couriers and returns the data saved in the database.
     * @param {CouriersCreateManyAndReturnArgs} args - Arguments to create many Couriers.
     * @example
     * // Create many Couriers
     * const couriers = await prisma.couriers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Couriers and only return the `id`
     * const couriersWithIdOnly = await prisma.couriers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouriersCreateManyAndReturnArgs>(args?: SelectSubset<T, CouriersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Couriers.
     * @param {CouriersDeleteArgs} args - Arguments to delete one Couriers.
     * @example
     * // Delete one Couriers
     * const Couriers = await prisma.couriers.delete({
     *   where: {
     *     // ... filter to delete one Couriers
     *   }
     * })
     * 
     */
    delete<T extends CouriersDeleteArgs>(args: SelectSubset<T, CouriersDeleteArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Couriers.
     * @param {CouriersUpdateArgs} args - Arguments to update one Couriers.
     * @example
     * // Update one Couriers
     * const couriers = await prisma.couriers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouriersUpdateArgs>(args: SelectSubset<T, CouriersUpdateArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Couriers.
     * @param {CouriersDeleteManyArgs} args - Arguments to filter Couriers to delete.
     * @example
     * // Delete a few Couriers
     * const { count } = await prisma.couriers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouriersDeleteManyArgs>(args?: SelectSubset<T, CouriersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Couriers
     * const couriers = await prisma.couriers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouriersUpdateManyArgs>(args: SelectSubset<T, CouriersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers and returns the data updated in the database.
     * @param {CouriersUpdateManyAndReturnArgs} args - Arguments to update many Couriers.
     * @example
     * // Update many Couriers
     * const couriers = await prisma.couriers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Couriers and only return the `id`
     * const couriersWithIdOnly = await prisma.couriers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouriersUpdateManyAndReturnArgs>(args: SelectSubset<T, CouriersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Couriers.
     * @param {CouriersUpsertArgs} args - Arguments to update or create a Couriers.
     * @example
     * // Update or create a Couriers
     * const couriers = await prisma.couriers.upsert({
     *   create: {
     *     // ... data to create a Couriers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Couriers we want to update
     *   }
     * })
     */
    upsert<T extends CouriersUpsertArgs>(args: SelectSubset<T, CouriersUpsertArgs<ExtArgs>>): Prisma__CouriersClient<$Result.GetResult<Prisma.$CouriersPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersCountArgs} args - Arguments to filter Couriers to count.
     * @example
     * // Count the number of Couriers
     * const count = await prisma.couriers.count({
     *   where: {
     *     // ... the filter for the Couriers we want to count
     *   }
     * })
    **/
    count<T extends CouriersCountArgs>(
      args?: Subset<T, CouriersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouriersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouriersAggregateArgs>(args: Subset<T, CouriersAggregateArgs>): Prisma.PrismaPromise<GetCouriersAggregateType<T>>

    /**
     * Group by Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouriersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouriersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouriersGroupByArgs['orderBy'] }
        : { orderBy?: CouriersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouriersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouriersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Couriers model
   */
  readonly fields: CouriersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Couriers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouriersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice_id<T extends InvoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoicesDefaultArgs<ExtArgs>>): Prisma__InvoicesClient<$Result.GetResult<Prisma.$InvoicesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Couriers model
   */ 
  interface CouriersFieldRefs {
    readonly id: FieldRef<"Couriers", 'String'>
    readonly courier_code: FieldRef<"Couriers", 'String'>
    readonly courier_service_name: FieldRef<"Couriers", 'String'>
    readonly courier_service_code: FieldRef<"Couriers", 'String'>
    readonly price: FieldRef<"Couriers", 'Int'>
    readonly order_id: FieldRef<"Couriers", 'String'>
    readonly invoicesId: FieldRef<"Couriers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Couriers findUnique
   */
  export type CouriersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where: CouriersWhereUniqueInput
  }

  /**
   * Couriers findUniqueOrThrow
   */
  export type CouriersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where: CouriersWhereUniqueInput
  }

  /**
   * Couriers findFirst
   */
  export type CouriersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where?: CouriersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CouriersOrderByWithRelationInput | CouriersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CouriersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CouriersScalarFieldEnum | CouriersScalarFieldEnum[]
  }

  /**
   * Couriers findFirstOrThrow
   */
  export type CouriersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where?: CouriersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CouriersOrderByWithRelationInput | CouriersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CouriersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CouriersScalarFieldEnum | CouriersScalarFieldEnum[]
  }

  /**
   * Couriers findMany
   */
  export type CouriersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where?: CouriersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CouriersOrderByWithRelationInput | CouriersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Couriers.
     */
    cursor?: CouriersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    distinct?: CouriersScalarFieldEnum | CouriersScalarFieldEnum[]
  }

  /**
   * Couriers create
   */
  export type CouriersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * The data needed to create a Couriers.
     */
    data: XOR<CouriersCreateInput, CouriersUncheckedCreateInput>
  }

  /**
   * Couriers createMany
   */
  export type CouriersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Couriers.
     */
    data: CouriersCreateManyInput | CouriersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Couriers createManyAndReturn
   */
  export type CouriersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * The data used to create many Couriers.
     */
    data: CouriersCreateManyInput | CouriersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Couriers update
   */
  export type CouriersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * The data needed to update a Couriers.
     */
    data: XOR<CouriersUpdateInput, CouriersUncheckedUpdateInput>
    /**
     * Choose, which Couriers to update.
     */
    where: CouriersWhereUniqueInput
  }

  /**
   * Couriers updateMany
   */
  export type CouriersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Couriers.
     */
    data: XOR<CouriersUpdateManyMutationInput, CouriersUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CouriersWhereInput
  }

  /**
   * Couriers updateManyAndReturn
   */
  export type CouriersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * The data used to update Couriers.
     */
    data: XOR<CouriersUpdateManyMutationInput, CouriersUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CouriersWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Couriers upsert
   */
  export type CouriersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * The filter to search for the Couriers to update in case it exists.
     */
    where: CouriersWhereUniqueInput
    /**
     * In case the Couriers found by the `where` argument doesn't exist, create a new Couriers with this data.
     */
    create: XOR<CouriersCreateInput, CouriersUncheckedCreateInput>
    /**
     * In case the Couriers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouriersUpdateInput, CouriersUncheckedUpdateInput>
  }

  /**
   * Couriers delete
   */
  export type CouriersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
    /**
     * Filter which Couriers to delete.
     */
    where: CouriersWhereUniqueInput
  }

  /**
   * Couriers deleteMany
   */
  export type CouriersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Couriers to delete
     */
    where?: CouriersWhereInput
  }

  /**
   * Couriers without action
   */
  export type CouriersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Couriers
     */
    select?: CouriersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Couriers
     */
    omit?: CouriersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouriersInclude<ExtArgs> | null
  }


  /**
   * Model Decoration
   */

  export type AggregateDecoration = {
    _count: DecorationCountAggregateOutputType | null
    _min: DecorationMinAggregateOutputType | null
    _max: DecorationMaxAggregateOutputType | null
  }

  export type DecorationMinAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type DecorationMaxAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type DecorationCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type DecorationMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type DecorationMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type DecorationCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type DecorationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decoration to aggregate.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Decorations
    **/
    _count?: true | DecorationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecorationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecorationMaxAggregateInputType
  }

  export type GetDecorationAggregateType<T extends DecorationAggregateArgs> = {
        [P in keyof T & keyof AggregateDecoration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecoration[P]>
      : GetScalarType<T[P], AggregateDecoration[P]>
  }




  export type DecorationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecorationWhereInput
    orderBy?: DecorationOrderByWithAggregationInput | DecorationOrderByWithAggregationInput[]
    by: DecorationScalarFieldEnum[] | DecorationScalarFieldEnum
    having?: DecorationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecorationCountAggregateInputType | true
    _min?: DecorationMinAggregateInputType
    _max?: DecorationMaxAggregateInputType
  }

  export type DecorationGroupByOutputType = {
    id: string
    type: string
    _count: DecorationCountAggregateOutputType | null
    _min: DecorationMinAggregateOutputType | null
    _max: DecorationMaxAggregateOutputType | null
  }

  type GetDecorationGroupByPayload<T extends DecorationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecorationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecorationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecorationGroupByOutputType[P]>
            : GetScalarType<T[P], DecorationGroupByOutputType[P]>
        }
      >
    >


  export type DecorationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["decoration"]>

  export type DecorationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["decoration"]>

  export type DecorationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["decoration"]>

  export type DecorationSelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type DecorationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["decoration"]>

  export type $DecorationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Decoration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
    }, ExtArgs["result"]["decoration"]>
    composites: {}
  }

  type DecorationGetPayload<S extends boolean | null | undefined | DecorationDefaultArgs> = $Result.GetResult<Prisma.$DecorationPayload, S>

  type DecorationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DecorationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DecorationCountAggregateInputType | true
    }

  export interface DecorationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Decoration'], meta: { name: 'Decoration' } }
    /**
     * Find zero or one Decoration that matches the filter.
     * @param {DecorationFindUniqueArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecorationFindUniqueArgs>(args: SelectSubset<T, DecorationFindUniqueArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Decoration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DecorationFindUniqueOrThrowArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecorationFindUniqueOrThrowArgs>(args: SelectSubset<T, DecorationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Decoration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationFindFirstArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecorationFindFirstArgs>(args?: SelectSubset<T, DecorationFindFirstArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Decoration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationFindFirstOrThrowArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecorationFindFirstOrThrowArgs>(args?: SelectSubset<T, DecorationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Decorations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Decorations
     * const decorations = await prisma.decoration.findMany()
     * 
     * // Get first 10 Decorations
     * const decorations = await prisma.decoration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decorationWithIdOnly = await prisma.decoration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecorationFindManyArgs>(args?: SelectSubset<T, DecorationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Decoration.
     * @param {DecorationCreateArgs} args - Arguments to create a Decoration.
     * @example
     * // Create one Decoration
     * const Decoration = await prisma.decoration.create({
     *   data: {
     *     // ... data to create a Decoration
     *   }
     * })
     * 
     */
    create<T extends DecorationCreateArgs>(args: SelectSubset<T, DecorationCreateArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Decorations.
     * @param {DecorationCreateManyArgs} args - Arguments to create many Decorations.
     * @example
     * // Create many Decorations
     * const decoration = await prisma.decoration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecorationCreateManyArgs>(args?: SelectSubset<T, DecorationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Decorations and returns the data saved in the database.
     * @param {DecorationCreateManyAndReturnArgs} args - Arguments to create many Decorations.
     * @example
     * // Create many Decorations
     * const decoration = await prisma.decoration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Decorations and only return the `id`
     * const decorationWithIdOnly = await prisma.decoration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecorationCreateManyAndReturnArgs>(args?: SelectSubset<T, DecorationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Decoration.
     * @param {DecorationDeleteArgs} args - Arguments to delete one Decoration.
     * @example
     * // Delete one Decoration
     * const Decoration = await prisma.decoration.delete({
     *   where: {
     *     // ... filter to delete one Decoration
     *   }
     * })
     * 
     */
    delete<T extends DecorationDeleteArgs>(args: SelectSubset<T, DecorationDeleteArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Decoration.
     * @param {DecorationUpdateArgs} args - Arguments to update one Decoration.
     * @example
     * // Update one Decoration
     * const decoration = await prisma.decoration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecorationUpdateArgs>(args: SelectSubset<T, DecorationUpdateArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Decorations.
     * @param {DecorationDeleteManyArgs} args - Arguments to filter Decorations to delete.
     * @example
     * // Delete a few Decorations
     * const { count } = await prisma.decoration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecorationDeleteManyArgs>(args?: SelectSubset<T, DecorationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Decorations
     * const decoration = await prisma.decoration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecorationUpdateManyArgs>(args: SelectSubset<T, DecorationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decorations and returns the data updated in the database.
     * @param {DecorationUpdateManyAndReturnArgs} args - Arguments to update many Decorations.
     * @example
     * // Update many Decorations
     * const decoration = await prisma.decoration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Decorations and only return the `id`
     * const decorationWithIdOnly = await prisma.decoration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DecorationUpdateManyAndReturnArgs>(args: SelectSubset<T, DecorationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Decoration.
     * @param {DecorationUpsertArgs} args - Arguments to update or create a Decoration.
     * @example
     * // Update or create a Decoration
     * const decoration = await prisma.decoration.upsert({
     *   create: {
     *     // ... data to create a Decoration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Decoration we want to update
     *   }
     * })
     */
    upsert<T extends DecorationUpsertArgs>(args: SelectSubset<T, DecorationUpsertArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationCountArgs} args - Arguments to filter Decorations to count.
     * @example
     * // Count the number of Decorations
     * const count = await prisma.decoration.count({
     *   where: {
     *     // ... the filter for the Decorations we want to count
     *   }
     * })
    **/
    count<T extends DecorationCountArgs>(
      args?: Subset<T, DecorationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecorationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Decoration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecorationAggregateArgs>(args: Subset<T, DecorationAggregateArgs>): Prisma.PrismaPromise<GetDecorationAggregateType<T>>

    /**
     * Group by Decoration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecorationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecorationGroupByArgs['orderBy'] }
        : { orderBy?: DecorationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecorationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecorationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Decoration model
   */
  readonly fields: DecorationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Decoration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecorationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Decoration model
   */ 
  interface DecorationFieldRefs {
    readonly id: FieldRef<"Decoration", 'String'>
    readonly type: FieldRef<"Decoration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Decoration findUnique
   */
  export type DecorationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration findUniqueOrThrow
   */
  export type DecorationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration findFirst
   */
  export type DecorationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decorations.
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decorations.
     */
    distinct?: DecorationScalarFieldEnum | DecorationScalarFieldEnum[]
  }

  /**
   * Decoration findFirstOrThrow
   */
  export type DecorationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decorations.
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decorations.
     */
    distinct?: DecorationScalarFieldEnum | DecorationScalarFieldEnum[]
  }

  /**
   * Decoration findMany
   */
  export type DecorationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Filter, which Decorations to fetch.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Decorations.
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    distinct?: DecorationScalarFieldEnum | DecorationScalarFieldEnum[]
  }

  /**
   * Decoration create
   */
  export type DecorationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The data needed to create a Decoration.
     */
    data: XOR<DecorationCreateInput, DecorationUncheckedCreateInput>
  }

  /**
   * Decoration createMany
   */
  export type DecorationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Decorations.
     */
    data: DecorationCreateManyInput | DecorationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decoration createManyAndReturn
   */
  export type DecorationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The data used to create many Decorations.
     */
    data: DecorationCreateManyInput | DecorationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decoration update
   */
  export type DecorationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The data needed to update a Decoration.
     */
    data: XOR<DecorationUpdateInput, DecorationUncheckedUpdateInput>
    /**
     * Choose, which Decoration to update.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration updateMany
   */
  export type DecorationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Decorations.
     */
    data: XOR<DecorationUpdateManyMutationInput, DecorationUncheckedUpdateManyInput>
    /**
     * Filter which Decorations to update
     */
    where?: DecorationWhereInput
  }

  /**
   * Decoration updateManyAndReturn
   */
  export type DecorationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The data used to update Decorations.
     */
    data: XOR<DecorationUpdateManyMutationInput, DecorationUncheckedUpdateManyInput>
    /**
     * Filter which Decorations to update
     */
    where?: DecorationWhereInput
  }

  /**
   * Decoration upsert
   */
  export type DecorationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The filter to search for the Decoration to update in case it exists.
     */
    where: DecorationWhereUniqueInput
    /**
     * In case the Decoration found by the `where` argument doesn't exist, create a new Decoration with this data.
     */
    create: XOR<DecorationCreateInput, DecorationUncheckedCreateInput>
    /**
     * In case the Decoration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecorationUpdateInput, DecorationUncheckedUpdateInput>
  }

  /**
   * Decoration delete
   */
  export type DecorationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Filter which Decoration to delete.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration deleteMany
   */
  export type DecorationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decorations to delete
     */
    where?: DecorationWhereInput
  }

  /**
   * Decoration without action
   */
  export type DecorationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
  }


  /**
   * Model Stores_on_decorations
   */

  export type AggregateStores_on_decorations = {
    _count: Stores_on_decorationsCountAggregateOutputType | null
    _min: Stores_on_decorationsMinAggregateOutputType | null
    _max: Stores_on_decorationsMaxAggregateOutputType | null
  }

  export type Stores_on_decorationsMinAggregateOutputType = {
    id: string | null
    storesId: string | null
  }

  export type Stores_on_decorationsMaxAggregateOutputType = {
    id: string | null
    storesId: string | null
  }

  export type Stores_on_decorationsCountAggregateOutputType = {
    id: number
    storesId: number
    _all: number
  }


  export type Stores_on_decorationsMinAggregateInputType = {
    id?: true
    storesId?: true
  }

  export type Stores_on_decorationsMaxAggregateInputType = {
    id?: true
    storesId?: true
  }

  export type Stores_on_decorationsCountAggregateInputType = {
    id?: true
    storesId?: true
    _all?: true
  }

  export type Stores_on_decorationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores_on_decorations to aggregate.
     */
    where?: Stores_on_decorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores_on_decorations to fetch.
     */
    orderBy?: Stores_on_decorationsOrderByWithRelationInput | Stores_on_decorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Stores_on_decorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores_on_decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores_on_decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores_on_decorations
    **/
    _count?: true | Stores_on_decorationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stores_on_decorationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stores_on_decorationsMaxAggregateInputType
  }

  export type GetStores_on_decorationsAggregateType<T extends Stores_on_decorationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStores_on_decorations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores_on_decorations[P]>
      : GetScalarType<T[P], AggregateStores_on_decorations[P]>
  }




  export type Stores_on_decorationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Stores_on_decorationsWhereInput
    orderBy?: Stores_on_decorationsOrderByWithAggregationInput | Stores_on_decorationsOrderByWithAggregationInput[]
    by: Stores_on_decorationsScalarFieldEnum[] | Stores_on_decorationsScalarFieldEnum
    having?: Stores_on_decorationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stores_on_decorationsCountAggregateInputType | true
    _min?: Stores_on_decorationsMinAggregateInputType
    _max?: Stores_on_decorationsMaxAggregateInputType
  }

  export type Stores_on_decorationsGroupByOutputType = {
    id: string
    storesId: string
    _count: Stores_on_decorationsCountAggregateOutputType | null
    _min: Stores_on_decorationsMinAggregateOutputType | null
    _max: Stores_on_decorationsMaxAggregateOutputType | null
  }

  type GetStores_on_decorationsGroupByPayload<T extends Stores_on_decorationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stores_on_decorationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stores_on_decorationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stores_on_decorationsGroupByOutputType[P]>
            : GetScalarType<T[P], Stores_on_decorationsGroupByOutputType[P]>
        }
      >
    >


  export type Stores_on_decorationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores_on_decorations"]>

  export type Stores_on_decorationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores_on_decorations"]>

  export type Stores_on_decorationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores_on_decorations"]>

  export type Stores_on_decorationsSelectScalar = {
    id?: boolean
    storesId?: boolean
  }

  export type Stores_on_decorationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storesId", ExtArgs["result"]["stores_on_decorations"]>
  export type Stores_on_decorationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type Stores_on_decorationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type Stores_on_decorationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $Stores_on_decorationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stores_on_decorations"
    objects: {
      store_id: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storesId: string
    }, ExtArgs["result"]["stores_on_decorations"]>
    composites: {}
  }

  type Stores_on_decorationsGetPayload<S extends boolean | null | undefined | Stores_on_decorationsDefaultArgs> = $Result.GetResult<Prisma.$Stores_on_decorationsPayload, S>

  type Stores_on_decorationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Stores_on_decorationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Stores_on_decorationsCountAggregateInputType | true
    }

  export interface Stores_on_decorationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stores_on_decorations'], meta: { name: 'Stores_on_decorations' } }
    /**
     * Find zero or one Stores_on_decorations that matches the filter.
     * @param {Stores_on_decorationsFindUniqueArgs} args - Arguments to find a Stores_on_decorations
     * @example
     * // Get one Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Stores_on_decorationsFindUniqueArgs>(args: SelectSubset<T, Stores_on_decorationsFindUniqueArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stores_on_decorations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Stores_on_decorationsFindUniqueOrThrowArgs} args - Arguments to find a Stores_on_decorations
     * @example
     * // Get one Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Stores_on_decorationsFindUniqueOrThrowArgs>(args: SelectSubset<T, Stores_on_decorationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stores_on_decorations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsFindFirstArgs} args - Arguments to find a Stores_on_decorations
     * @example
     * // Get one Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Stores_on_decorationsFindFirstArgs>(args?: SelectSubset<T, Stores_on_decorationsFindFirstArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stores_on_decorations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsFindFirstOrThrowArgs} args - Arguments to find a Stores_on_decorations
     * @example
     * // Get one Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Stores_on_decorationsFindFirstOrThrowArgs>(args?: SelectSubset<T, Stores_on_decorationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stores_on_decorations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.findMany()
     * 
     * // Get first 10 Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stores_on_decorationsWithIdOnly = await prisma.stores_on_decorations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Stores_on_decorationsFindManyArgs>(args?: SelectSubset<T, Stores_on_decorationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stores_on_decorations.
     * @param {Stores_on_decorationsCreateArgs} args - Arguments to create a Stores_on_decorations.
     * @example
     * // Create one Stores_on_decorations
     * const Stores_on_decorations = await prisma.stores_on_decorations.create({
     *   data: {
     *     // ... data to create a Stores_on_decorations
     *   }
     * })
     * 
     */
    create<T extends Stores_on_decorationsCreateArgs>(args: SelectSubset<T, Stores_on_decorationsCreateArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stores_on_decorations.
     * @param {Stores_on_decorationsCreateManyArgs} args - Arguments to create many Stores_on_decorations.
     * @example
     * // Create many Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Stores_on_decorationsCreateManyArgs>(args?: SelectSubset<T, Stores_on_decorationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores_on_decorations and returns the data saved in the database.
     * @param {Stores_on_decorationsCreateManyAndReturnArgs} args - Arguments to create many Stores_on_decorations.
     * @example
     * // Create many Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores_on_decorations and only return the `id`
     * const stores_on_decorationsWithIdOnly = await prisma.stores_on_decorations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Stores_on_decorationsCreateManyAndReturnArgs>(args?: SelectSubset<T, Stores_on_decorationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stores_on_decorations.
     * @param {Stores_on_decorationsDeleteArgs} args - Arguments to delete one Stores_on_decorations.
     * @example
     * // Delete one Stores_on_decorations
     * const Stores_on_decorations = await prisma.stores_on_decorations.delete({
     *   where: {
     *     // ... filter to delete one Stores_on_decorations
     *   }
     * })
     * 
     */
    delete<T extends Stores_on_decorationsDeleteArgs>(args: SelectSubset<T, Stores_on_decorationsDeleteArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stores_on_decorations.
     * @param {Stores_on_decorationsUpdateArgs} args - Arguments to update one Stores_on_decorations.
     * @example
     * // Update one Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Stores_on_decorationsUpdateArgs>(args: SelectSubset<T, Stores_on_decorationsUpdateArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stores_on_decorations.
     * @param {Stores_on_decorationsDeleteManyArgs} args - Arguments to filter Stores_on_decorations to delete.
     * @example
     * // Delete a few Stores_on_decorations
     * const { count } = await prisma.stores_on_decorations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Stores_on_decorationsDeleteManyArgs>(args?: SelectSubset<T, Stores_on_decorationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores_on_decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Stores_on_decorationsUpdateManyArgs>(args: SelectSubset<T, Stores_on_decorationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores_on_decorations and returns the data updated in the database.
     * @param {Stores_on_decorationsUpdateManyAndReturnArgs} args - Arguments to update many Stores_on_decorations.
     * @example
     * // Update many Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores_on_decorations and only return the `id`
     * const stores_on_decorationsWithIdOnly = await prisma.stores_on_decorations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Stores_on_decorationsUpdateManyAndReturnArgs>(args: SelectSubset<T, Stores_on_decorationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Stores_on_decorations.
     * @param {Stores_on_decorationsUpsertArgs} args - Arguments to update or create a Stores_on_decorations.
     * @example
     * // Update or create a Stores_on_decorations
     * const stores_on_decorations = await prisma.stores_on_decorations.upsert({
     *   create: {
     *     // ... data to create a Stores_on_decorations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores_on_decorations we want to update
     *   }
     * })
     */
    upsert<T extends Stores_on_decorationsUpsertArgs>(args: SelectSubset<T, Stores_on_decorationsUpsertArgs<ExtArgs>>): Prisma__Stores_on_decorationsClient<$Result.GetResult<Prisma.$Stores_on_decorationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stores_on_decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsCountArgs} args - Arguments to filter Stores_on_decorations to count.
     * @example
     * // Count the number of Stores_on_decorations
     * const count = await prisma.stores_on_decorations.count({
     *   where: {
     *     // ... the filter for the Stores_on_decorations we want to count
     *   }
     * })
    **/
    count<T extends Stores_on_decorationsCountArgs>(
      args?: Subset<T, Stores_on_decorationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stores_on_decorationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores_on_decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stores_on_decorationsAggregateArgs>(args: Subset<T, Stores_on_decorationsAggregateArgs>): Prisma.PrismaPromise<GetStores_on_decorationsAggregateType<T>>

    /**
     * Group by Stores_on_decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stores_on_decorationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Stores_on_decorationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Stores_on_decorationsGroupByArgs['orderBy'] }
        : { orderBy?: Stores_on_decorationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Stores_on_decorationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStores_on_decorationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stores_on_decorations model
   */
  readonly fields: Stores_on_decorationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stores_on_decorations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Stores_on_decorationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store_id<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stores_on_decorations model
   */ 
  interface Stores_on_decorationsFieldRefs {
    readonly id: FieldRef<"Stores_on_decorations", 'String'>
    readonly storesId: FieldRef<"Stores_on_decorations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Stores_on_decorations findUnique
   */
  export type Stores_on_decorationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * Filter, which Stores_on_decorations to fetch.
     */
    where: Stores_on_decorationsWhereUniqueInput
  }

  /**
   * Stores_on_decorations findUniqueOrThrow
   */
  export type Stores_on_decorationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * Filter, which Stores_on_decorations to fetch.
     */
    where: Stores_on_decorationsWhereUniqueInput
  }

  /**
   * Stores_on_decorations findFirst
   */
  export type Stores_on_decorationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * Filter, which Stores_on_decorations to fetch.
     */
    where?: Stores_on_decorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores_on_decorations to fetch.
     */
    orderBy?: Stores_on_decorationsOrderByWithRelationInput | Stores_on_decorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores_on_decorations.
     */
    cursor?: Stores_on_decorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores_on_decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores_on_decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores_on_decorations.
     */
    distinct?: Stores_on_decorationsScalarFieldEnum | Stores_on_decorationsScalarFieldEnum[]
  }

  /**
   * Stores_on_decorations findFirstOrThrow
   */
  export type Stores_on_decorationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * Filter, which Stores_on_decorations to fetch.
     */
    where?: Stores_on_decorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores_on_decorations to fetch.
     */
    orderBy?: Stores_on_decorationsOrderByWithRelationInput | Stores_on_decorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores_on_decorations.
     */
    cursor?: Stores_on_decorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores_on_decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores_on_decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores_on_decorations.
     */
    distinct?: Stores_on_decorationsScalarFieldEnum | Stores_on_decorationsScalarFieldEnum[]
  }

  /**
   * Stores_on_decorations findMany
   */
  export type Stores_on_decorationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * Filter, which Stores_on_decorations to fetch.
     */
    where?: Stores_on_decorationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores_on_decorations to fetch.
     */
    orderBy?: Stores_on_decorationsOrderByWithRelationInput | Stores_on_decorationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores_on_decorations.
     */
    cursor?: Stores_on_decorationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores_on_decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores_on_decorations.
     */
    skip?: number
    distinct?: Stores_on_decorationsScalarFieldEnum | Stores_on_decorationsScalarFieldEnum[]
  }

  /**
   * Stores_on_decorations create
   */
  export type Stores_on_decorationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Stores_on_decorations.
     */
    data: XOR<Stores_on_decorationsCreateInput, Stores_on_decorationsUncheckedCreateInput>
  }

  /**
   * Stores_on_decorations createMany
   */
  export type Stores_on_decorationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores_on_decorations.
     */
    data: Stores_on_decorationsCreateManyInput | Stores_on_decorationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores_on_decorations createManyAndReturn
   */
  export type Stores_on_decorationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * The data used to create many Stores_on_decorations.
     */
    data: Stores_on_decorationsCreateManyInput | Stores_on_decorationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stores_on_decorations update
   */
  export type Stores_on_decorationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Stores_on_decorations.
     */
    data: XOR<Stores_on_decorationsUpdateInput, Stores_on_decorationsUncheckedUpdateInput>
    /**
     * Choose, which Stores_on_decorations to update.
     */
    where: Stores_on_decorationsWhereUniqueInput
  }

  /**
   * Stores_on_decorations updateMany
   */
  export type Stores_on_decorationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores_on_decorations.
     */
    data: XOR<Stores_on_decorationsUpdateManyMutationInput, Stores_on_decorationsUncheckedUpdateManyInput>
    /**
     * Filter which Stores_on_decorations to update
     */
    where?: Stores_on_decorationsWhereInput
  }

  /**
   * Stores_on_decorations updateManyAndReturn
   */
  export type Stores_on_decorationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * The data used to update Stores_on_decorations.
     */
    data: XOR<Stores_on_decorationsUpdateManyMutationInput, Stores_on_decorationsUncheckedUpdateManyInput>
    /**
     * Filter which Stores_on_decorations to update
     */
    where?: Stores_on_decorationsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stores_on_decorations upsert
   */
  export type Stores_on_decorationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Stores_on_decorations to update in case it exists.
     */
    where: Stores_on_decorationsWhereUniqueInput
    /**
     * In case the Stores_on_decorations found by the `where` argument doesn't exist, create a new Stores_on_decorations with this data.
     */
    create: XOR<Stores_on_decorationsCreateInput, Stores_on_decorationsUncheckedCreateInput>
    /**
     * In case the Stores_on_decorations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Stores_on_decorationsUpdateInput, Stores_on_decorationsUncheckedUpdateInput>
  }

  /**
   * Stores_on_decorations delete
   */
  export type Stores_on_decorationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
    /**
     * Filter which Stores_on_decorations to delete.
     */
    where: Stores_on_decorationsWhereUniqueInput
  }

  /**
   * Stores_on_decorations deleteMany
   */
  export type Stores_on_decorationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores_on_decorations to delete
     */
    where?: Stores_on_decorationsWhereInput
  }

  /**
   * Stores_on_decorations without action
   */
  export type Stores_on_decorationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores_on_decorations
     */
    select?: Stores_on_decorationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stores_on_decorations
     */
    omit?: Stores_on_decorationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Stores_on_decorationsInclude<ExtArgs> | null
  }


  /**
   * Model Operation_hours
   */

  export type AggregateOperation_hours = {
    _count: Operation_hoursCountAggregateOutputType | null
    _min: Operation_hoursMinAggregateOutputType | null
    _max: Operation_hoursMaxAggregateOutputType | null
  }

  export type Operation_hoursMinAggregateOutputType = {
    id: string | null
    day: string | null
    open_at: string | null
    close_at: string | null
    is_off: boolean | null
    storesId: string | null
  }

  export type Operation_hoursMaxAggregateOutputType = {
    id: string | null
    day: string | null
    open_at: string | null
    close_at: string | null
    is_off: boolean | null
    storesId: string | null
  }

  export type Operation_hoursCountAggregateOutputType = {
    id: number
    day: number
    open_at: number
    close_at: number
    is_off: number
    storesId: number
    _all: number
  }


  export type Operation_hoursMinAggregateInputType = {
    id?: true
    day?: true
    open_at?: true
    close_at?: true
    is_off?: true
    storesId?: true
  }

  export type Operation_hoursMaxAggregateInputType = {
    id?: true
    day?: true
    open_at?: true
    close_at?: true
    is_off?: true
    storesId?: true
  }

  export type Operation_hoursCountAggregateInputType = {
    id?: true
    day?: true
    open_at?: true
    close_at?: true
    is_off?: true
    storesId?: true
    _all?: true
  }

  export type Operation_hoursAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operation_hours to aggregate.
     */
    where?: Operation_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operation_hours to fetch.
     */
    orderBy?: Operation_hoursOrderByWithRelationInput | Operation_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Operation_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operation_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operation_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operation_hours
    **/
    _count?: true | Operation_hoursCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Operation_hoursMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Operation_hoursMaxAggregateInputType
  }

  export type GetOperation_hoursAggregateType<T extends Operation_hoursAggregateArgs> = {
        [P in keyof T & keyof AggregateOperation_hours]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperation_hours[P]>
      : GetScalarType<T[P], AggregateOperation_hours[P]>
  }




  export type Operation_hoursGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Operation_hoursWhereInput
    orderBy?: Operation_hoursOrderByWithAggregationInput | Operation_hoursOrderByWithAggregationInput[]
    by: Operation_hoursScalarFieldEnum[] | Operation_hoursScalarFieldEnum
    having?: Operation_hoursScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Operation_hoursCountAggregateInputType | true
    _min?: Operation_hoursMinAggregateInputType
    _max?: Operation_hoursMaxAggregateInputType
  }

  export type Operation_hoursGroupByOutputType = {
    id: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
    storesId: string
    _count: Operation_hoursCountAggregateOutputType | null
    _min: Operation_hoursMinAggregateOutputType | null
    _max: Operation_hoursMaxAggregateOutputType | null
  }

  type GetOperation_hoursGroupByPayload<T extends Operation_hoursGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Operation_hoursGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Operation_hoursGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Operation_hoursGroupByOutputType[P]>
            : GetScalarType<T[P], Operation_hoursGroupByOutputType[P]>
        }
      >
    >


  export type Operation_hoursSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    open_at?: boolean
    close_at?: boolean
    is_off?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operation_hours"]>

  export type Operation_hoursSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    open_at?: boolean
    close_at?: boolean
    is_off?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operation_hours"]>

  export type Operation_hoursSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    open_at?: boolean
    close_at?: boolean
    is_off?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operation_hours"]>

  export type Operation_hoursSelectScalar = {
    id?: boolean
    day?: boolean
    open_at?: boolean
    close_at?: boolean
    is_off?: boolean
    storesId?: boolean
  }

  export type Operation_hoursOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "day" | "open_at" | "close_at" | "is_off" | "storesId", ExtArgs["result"]["operation_hours"]>
  export type Operation_hoursInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type Operation_hoursIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type Operation_hoursIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $Operation_hoursPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operation_hours"
    objects: {
      store_id: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      day: string
      open_at: string
      close_at: string
      is_off: boolean
      storesId: string
    }, ExtArgs["result"]["operation_hours"]>
    composites: {}
  }

  type Operation_hoursGetPayload<S extends boolean | null | undefined | Operation_hoursDefaultArgs> = $Result.GetResult<Prisma.$Operation_hoursPayload, S>

  type Operation_hoursCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Operation_hoursFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Operation_hoursCountAggregateInputType | true
    }

  export interface Operation_hoursDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operation_hours'], meta: { name: 'Operation_hours' } }
    /**
     * Find zero or one Operation_hours that matches the filter.
     * @param {Operation_hoursFindUniqueArgs} args - Arguments to find a Operation_hours
     * @example
     * // Get one Operation_hours
     * const operation_hours = await prisma.operation_hours.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Operation_hoursFindUniqueArgs>(args: SelectSubset<T, Operation_hoursFindUniqueArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Operation_hours that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Operation_hoursFindUniqueOrThrowArgs} args - Arguments to find a Operation_hours
     * @example
     * // Get one Operation_hours
     * const operation_hours = await prisma.operation_hours.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Operation_hoursFindUniqueOrThrowArgs>(args: SelectSubset<T, Operation_hoursFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Operation_hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursFindFirstArgs} args - Arguments to find a Operation_hours
     * @example
     * // Get one Operation_hours
     * const operation_hours = await prisma.operation_hours.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Operation_hoursFindFirstArgs>(args?: SelectSubset<T, Operation_hoursFindFirstArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Operation_hours that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursFindFirstOrThrowArgs} args - Arguments to find a Operation_hours
     * @example
     * // Get one Operation_hours
     * const operation_hours = await prisma.operation_hours.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Operation_hoursFindFirstOrThrowArgs>(args?: SelectSubset<T, Operation_hoursFindFirstOrThrowArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Operation_hours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operation_hours
     * const operation_hours = await prisma.operation_hours.findMany()
     * 
     * // Get first 10 Operation_hours
     * const operation_hours = await prisma.operation_hours.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operation_hoursWithIdOnly = await prisma.operation_hours.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Operation_hoursFindManyArgs>(args?: SelectSubset<T, Operation_hoursFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Operation_hours.
     * @param {Operation_hoursCreateArgs} args - Arguments to create a Operation_hours.
     * @example
     * // Create one Operation_hours
     * const Operation_hours = await prisma.operation_hours.create({
     *   data: {
     *     // ... data to create a Operation_hours
     *   }
     * })
     * 
     */
    create<T extends Operation_hoursCreateArgs>(args: SelectSubset<T, Operation_hoursCreateArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Operation_hours.
     * @param {Operation_hoursCreateManyArgs} args - Arguments to create many Operation_hours.
     * @example
     * // Create many Operation_hours
     * const operation_hours = await prisma.operation_hours.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Operation_hoursCreateManyArgs>(args?: SelectSubset<T, Operation_hoursCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operation_hours and returns the data saved in the database.
     * @param {Operation_hoursCreateManyAndReturnArgs} args - Arguments to create many Operation_hours.
     * @example
     * // Create many Operation_hours
     * const operation_hours = await prisma.operation_hours.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operation_hours and only return the `id`
     * const operation_hoursWithIdOnly = await prisma.operation_hours.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Operation_hoursCreateManyAndReturnArgs>(args?: SelectSubset<T, Operation_hoursCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Operation_hours.
     * @param {Operation_hoursDeleteArgs} args - Arguments to delete one Operation_hours.
     * @example
     * // Delete one Operation_hours
     * const Operation_hours = await prisma.operation_hours.delete({
     *   where: {
     *     // ... filter to delete one Operation_hours
     *   }
     * })
     * 
     */
    delete<T extends Operation_hoursDeleteArgs>(args: SelectSubset<T, Operation_hoursDeleteArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Operation_hours.
     * @param {Operation_hoursUpdateArgs} args - Arguments to update one Operation_hours.
     * @example
     * // Update one Operation_hours
     * const operation_hours = await prisma.operation_hours.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Operation_hoursUpdateArgs>(args: SelectSubset<T, Operation_hoursUpdateArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Operation_hours.
     * @param {Operation_hoursDeleteManyArgs} args - Arguments to filter Operation_hours to delete.
     * @example
     * // Delete a few Operation_hours
     * const { count } = await prisma.operation_hours.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Operation_hoursDeleteManyArgs>(args?: SelectSubset<T, Operation_hoursDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operation_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operation_hours
     * const operation_hours = await prisma.operation_hours.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Operation_hoursUpdateManyArgs>(args: SelectSubset<T, Operation_hoursUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operation_hours and returns the data updated in the database.
     * @param {Operation_hoursUpdateManyAndReturnArgs} args - Arguments to update many Operation_hours.
     * @example
     * // Update many Operation_hours
     * const operation_hours = await prisma.operation_hours.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operation_hours and only return the `id`
     * const operation_hoursWithIdOnly = await prisma.operation_hours.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Operation_hoursUpdateManyAndReturnArgs>(args: SelectSubset<T, Operation_hoursUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Operation_hours.
     * @param {Operation_hoursUpsertArgs} args - Arguments to update or create a Operation_hours.
     * @example
     * // Update or create a Operation_hours
     * const operation_hours = await prisma.operation_hours.upsert({
     *   create: {
     *     // ... data to create a Operation_hours
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operation_hours we want to update
     *   }
     * })
     */
    upsert<T extends Operation_hoursUpsertArgs>(args: SelectSubset<T, Operation_hoursUpsertArgs<ExtArgs>>): Prisma__Operation_hoursClient<$Result.GetResult<Prisma.$Operation_hoursPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Operation_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursCountArgs} args - Arguments to filter Operation_hours to count.
     * @example
     * // Count the number of Operation_hours
     * const count = await prisma.operation_hours.count({
     *   where: {
     *     // ... the filter for the Operation_hours we want to count
     *   }
     * })
    **/
    count<T extends Operation_hoursCountArgs>(
      args?: Subset<T, Operation_hoursCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Operation_hoursCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operation_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Operation_hoursAggregateArgs>(args: Subset<T, Operation_hoursAggregateArgs>): Prisma.PrismaPromise<GetOperation_hoursAggregateType<T>>

    /**
     * Group by Operation_hours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Operation_hoursGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Operation_hoursGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Operation_hoursGroupByArgs['orderBy'] }
        : { orderBy?: Operation_hoursGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Operation_hoursGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperation_hoursGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operation_hours model
   */
  readonly fields: Operation_hoursFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operation_hours.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Operation_hoursClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store_id<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operation_hours model
   */ 
  interface Operation_hoursFieldRefs {
    readonly id: FieldRef<"Operation_hours", 'String'>
    readonly day: FieldRef<"Operation_hours", 'String'>
    readonly open_at: FieldRef<"Operation_hours", 'String'>
    readonly close_at: FieldRef<"Operation_hours", 'String'>
    readonly is_off: FieldRef<"Operation_hours", 'Boolean'>
    readonly storesId: FieldRef<"Operation_hours", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Operation_hours findUnique
   */
  export type Operation_hoursFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * Filter, which Operation_hours to fetch.
     */
    where: Operation_hoursWhereUniqueInput
  }

  /**
   * Operation_hours findUniqueOrThrow
   */
  export type Operation_hoursFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * Filter, which Operation_hours to fetch.
     */
    where: Operation_hoursWhereUniqueInput
  }

  /**
   * Operation_hours findFirst
   */
  export type Operation_hoursFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * Filter, which Operation_hours to fetch.
     */
    where?: Operation_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operation_hours to fetch.
     */
    orderBy?: Operation_hoursOrderByWithRelationInput | Operation_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operation_hours.
     */
    cursor?: Operation_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operation_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operation_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operation_hours.
     */
    distinct?: Operation_hoursScalarFieldEnum | Operation_hoursScalarFieldEnum[]
  }

  /**
   * Operation_hours findFirstOrThrow
   */
  export type Operation_hoursFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * Filter, which Operation_hours to fetch.
     */
    where?: Operation_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operation_hours to fetch.
     */
    orderBy?: Operation_hoursOrderByWithRelationInput | Operation_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operation_hours.
     */
    cursor?: Operation_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operation_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operation_hours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operation_hours.
     */
    distinct?: Operation_hoursScalarFieldEnum | Operation_hoursScalarFieldEnum[]
  }

  /**
   * Operation_hours findMany
   */
  export type Operation_hoursFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * Filter, which Operation_hours to fetch.
     */
    where?: Operation_hoursWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operation_hours to fetch.
     */
    orderBy?: Operation_hoursOrderByWithRelationInput | Operation_hoursOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operation_hours.
     */
    cursor?: Operation_hoursWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operation_hours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operation_hours.
     */
    skip?: number
    distinct?: Operation_hoursScalarFieldEnum | Operation_hoursScalarFieldEnum[]
  }

  /**
   * Operation_hours create
   */
  export type Operation_hoursCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * The data needed to create a Operation_hours.
     */
    data: XOR<Operation_hoursCreateInput, Operation_hoursUncheckedCreateInput>
  }

  /**
   * Operation_hours createMany
   */
  export type Operation_hoursCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operation_hours.
     */
    data: Operation_hoursCreateManyInput | Operation_hoursCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operation_hours createManyAndReturn
   */
  export type Operation_hoursCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * The data used to create many Operation_hours.
     */
    data: Operation_hoursCreateManyInput | Operation_hoursCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operation_hours update
   */
  export type Operation_hoursUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * The data needed to update a Operation_hours.
     */
    data: XOR<Operation_hoursUpdateInput, Operation_hoursUncheckedUpdateInput>
    /**
     * Choose, which Operation_hours to update.
     */
    where: Operation_hoursWhereUniqueInput
  }

  /**
   * Operation_hours updateMany
   */
  export type Operation_hoursUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operation_hours.
     */
    data: XOR<Operation_hoursUpdateManyMutationInput, Operation_hoursUncheckedUpdateManyInput>
    /**
     * Filter which Operation_hours to update
     */
    where?: Operation_hoursWhereInput
  }

  /**
   * Operation_hours updateManyAndReturn
   */
  export type Operation_hoursUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * The data used to update Operation_hours.
     */
    data: XOR<Operation_hoursUpdateManyMutationInput, Operation_hoursUncheckedUpdateManyInput>
    /**
     * Filter which Operation_hours to update
     */
    where?: Operation_hoursWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operation_hours upsert
   */
  export type Operation_hoursUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * The filter to search for the Operation_hours to update in case it exists.
     */
    where: Operation_hoursWhereUniqueInput
    /**
     * In case the Operation_hours found by the `where` argument doesn't exist, create a new Operation_hours with this data.
     */
    create: XOR<Operation_hoursCreateInput, Operation_hoursUncheckedCreateInput>
    /**
     * In case the Operation_hours was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Operation_hoursUpdateInput, Operation_hoursUncheckedUpdateInput>
  }

  /**
   * Operation_hours delete
   */
  export type Operation_hoursDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
    /**
     * Filter which Operation_hours to delete.
     */
    where: Operation_hoursWhereUniqueInput
  }

  /**
   * Operation_hours deleteMany
   */
  export type Operation_hoursDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operation_hours to delete
     */
    where?: Operation_hoursWhereInput
  }

  /**
   * Operation_hours without action
   */
  export type Operation_hoursDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operation_hours
     */
    select?: Operation_hoursSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operation_hours
     */
    omit?: Operation_hoursOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Operation_hoursInclude<ExtArgs> | null
  }


  /**
   * Model Message_templates
   */

  export type AggregateMessage_templates = {
    _count: Message_templatesCountAggregateOutputType | null
    _min: Message_templatesMinAggregateOutputType | null
    _max: Message_templatesMaxAggregateOutputType | null
  }

  export type Message_templatesMinAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    storesId: string | null
  }

  export type Message_templatesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    storesId: string | null
  }

  export type Message_templatesCountAggregateOutputType = {
    id: number
    name: number
    content: number
    storesId: number
    _all: number
  }


  export type Message_templatesMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    storesId?: true
  }

  export type Message_templatesMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    storesId?: true
  }

  export type Message_templatesCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    storesId?: true
    _all?: true
  }

  export type Message_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message_templates to aggregate.
     */
    where?: Message_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Message_templates to fetch.
     */
    orderBy?: Message_templatesOrderByWithRelationInput | Message_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Message_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Message_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Message_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Message_templates
    **/
    _count?: true | Message_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Message_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Message_templatesMaxAggregateInputType
  }

  export type GetMessage_templatesAggregateType<T extends Message_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage_templates[P]>
      : GetScalarType<T[P], AggregateMessage_templates[P]>
  }




  export type Message_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Message_templatesWhereInput
    orderBy?: Message_templatesOrderByWithAggregationInput | Message_templatesOrderByWithAggregationInput[]
    by: Message_templatesScalarFieldEnum[] | Message_templatesScalarFieldEnum
    having?: Message_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Message_templatesCountAggregateInputType | true
    _min?: Message_templatesMinAggregateInputType
    _max?: Message_templatesMaxAggregateInputType
  }

  export type Message_templatesGroupByOutputType = {
    id: string
    name: string
    content: string
    storesId: string
    _count: Message_templatesCountAggregateOutputType | null
    _min: Message_templatesMinAggregateOutputType | null
    _max: Message_templatesMaxAggregateOutputType | null
  }

  type GetMessage_templatesGroupByPayload<T extends Message_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Message_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Message_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Message_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Message_templatesGroupByOutputType[P]>
        }
      >
    >


  export type Message_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_templates"]>

  export type Message_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_templates"]>

  export type Message_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    storesId?: boolean
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_templates"]>

  export type Message_templatesSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    storesId?: boolean
  }

  export type Message_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "storesId", ExtArgs["result"]["message_templates"]>
  export type Message_templatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type Message_templatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type Message_templatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store_id?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $Message_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message_templates"
    objects: {
      store_id: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      content: string
      storesId: string
    }, ExtArgs["result"]["message_templates"]>
    composites: {}
  }

  type Message_templatesGetPayload<S extends boolean | null | undefined | Message_templatesDefaultArgs> = $Result.GetResult<Prisma.$Message_templatesPayload, S>

  type Message_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Message_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Message_templatesCountAggregateInputType | true
    }

  export interface Message_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message_templates'], meta: { name: 'Message_templates' } }
    /**
     * Find zero or one Message_templates that matches the filter.
     * @param {Message_templatesFindUniqueArgs} args - Arguments to find a Message_templates
     * @example
     * // Get one Message_templates
     * const message_templates = await prisma.message_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Message_templatesFindUniqueArgs>(args: SelectSubset<T, Message_templatesFindUniqueArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Message_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Message_templatesFindUniqueOrThrowArgs} args - Arguments to find a Message_templates
     * @example
     * // Get one Message_templates
     * const message_templates = await prisma.message_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Message_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, Message_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Message_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesFindFirstArgs} args - Arguments to find a Message_templates
     * @example
     * // Get one Message_templates
     * const message_templates = await prisma.message_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Message_templatesFindFirstArgs>(args?: SelectSubset<T, Message_templatesFindFirstArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Message_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesFindFirstOrThrowArgs} args - Arguments to find a Message_templates
     * @example
     * // Get one Message_templates
     * const message_templates = await prisma.message_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Message_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, Message_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Message_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Message_templates
     * const message_templates = await prisma.message_templates.findMany()
     * 
     * // Get first 10 Message_templates
     * const message_templates = await prisma.message_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const message_templatesWithIdOnly = await prisma.message_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Message_templatesFindManyArgs>(args?: SelectSubset<T, Message_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Message_templates.
     * @param {Message_templatesCreateArgs} args - Arguments to create a Message_templates.
     * @example
     * // Create one Message_templates
     * const Message_templates = await prisma.message_templates.create({
     *   data: {
     *     // ... data to create a Message_templates
     *   }
     * })
     * 
     */
    create<T extends Message_templatesCreateArgs>(args: SelectSubset<T, Message_templatesCreateArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Message_templates.
     * @param {Message_templatesCreateManyArgs} args - Arguments to create many Message_templates.
     * @example
     * // Create many Message_templates
     * const message_templates = await prisma.message_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Message_templatesCreateManyArgs>(args?: SelectSubset<T, Message_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Message_templates and returns the data saved in the database.
     * @param {Message_templatesCreateManyAndReturnArgs} args - Arguments to create many Message_templates.
     * @example
     * // Create many Message_templates
     * const message_templates = await prisma.message_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Message_templates and only return the `id`
     * const message_templatesWithIdOnly = await prisma.message_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Message_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, Message_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Message_templates.
     * @param {Message_templatesDeleteArgs} args - Arguments to delete one Message_templates.
     * @example
     * // Delete one Message_templates
     * const Message_templates = await prisma.message_templates.delete({
     *   where: {
     *     // ... filter to delete one Message_templates
     *   }
     * })
     * 
     */
    delete<T extends Message_templatesDeleteArgs>(args: SelectSubset<T, Message_templatesDeleteArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Message_templates.
     * @param {Message_templatesUpdateArgs} args - Arguments to update one Message_templates.
     * @example
     * // Update one Message_templates
     * const message_templates = await prisma.message_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Message_templatesUpdateArgs>(args: SelectSubset<T, Message_templatesUpdateArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Message_templates.
     * @param {Message_templatesDeleteManyArgs} args - Arguments to filter Message_templates to delete.
     * @example
     * // Delete a few Message_templates
     * const { count } = await prisma.message_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Message_templatesDeleteManyArgs>(args?: SelectSubset<T, Message_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Message_templates
     * const message_templates = await prisma.message_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Message_templatesUpdateManyArgs>(args: SelectSubset<T, Message_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_templates and returns the data updated in the database.
     * @param {Message_templatesUpdateManyAndReturnArgs} args - Arguments to update many Message_templates.
     * @example
     * // Update many Message_templates
     * const message_templates = await prisma.message_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Message_templates and only return the `id`
     * const message_templatesWithIdOnly = await prisma.message_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Message_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, Message_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Message_templates.
     * @param {Message_templatesUpsertArgs} args - Arguments to update or create a Message_templates.
     * @example
     * // Update or create a Message_templates
     * const message_templates = await prisma.message_templates.upsert({
     *   create: {
     *     // ... data to create a Message_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message_templates we want to update
     *   }
     * })
     */
    upsert<T extends Message_templatesUpsertArgs>(args: SelectSubset<T, Message_templatesUpsertArgs<ExtArgs>>): Prisma__Message_templatesClient<$Result.GetResult<Prisma.$Message_templatesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Message_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesCountArgs} args - Arguments to filter Message_templates to count.
     * @example
     * // Count the number of Message_templates
     * const count = await prisma.message_templates.count({
     *   where: {
     *     // ... the filter for the Message_templates we want to count
     *   }
     * })
    **/
    count<T extends Message_templatesCountArgs>(
      args?: Subset<T, Message_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Message_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Message_templatesAggregateArgs>(args: Subset<T, Message_templatesAggregateArgs>): Prisma.PrismaPromise<GetMessage_templatesAggregateType<T>>

    /**
     * Group by Message_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Message_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Message_templatesGroupByArgs['orderBy'] }
        : { orderBy?: Message_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Message_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessage_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message_templates model
   */
  readonly fields: Message_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Message_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store_id<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message_templates model
   */ 
  interface Message_templatesFieldRefs {
    readonly id: FieldRef<"Message_templates", 'String'>
    readonly name: FieldRef<"Message_templates", 'String'>
    readonly content: FieldRef<"Message_templates", 'String'>
    readonly storesId: FieldRef<"Message_templates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message_templates findUnique
   */
  export type Message_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * Filter, which Message_templates to fetch.
     */
    where: Message_templatesWhereUniqueInput
  }

  /**
   * Message_templates findUniqueOrThrow
   */
  export type Message_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * Filter, which Message_templates to fetch.
     */
    where: Message_templatesWhereUniqueInput
  }

  /**
   * Message_templates findFirst
   */
  export type Message_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * Filter, which Message_templates to fetch.
     */
    where?: Message_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Message_templates to fetch.
     */
    orderBy?: Message_templatesOrderByWithRelationInput | Message_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Message_templates.
     */
    cursor?: Message_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Message_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Message_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Message_templates.
     */
    distinct?: Message_templatesScalarFieldEnum | Message_templatesScalarFieldEnum[]
  }

  /**
   * Message_templates findFirstOrThrow
   */
  export type Message_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * Filter, which Message_templates to fetch.
     */
    where?: Message_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Message_templates to fetch.
     */
    orderBy?: Message_templatesOrderByWithRelationInput | Message_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Message_templates.
     */
    cursor?: Message_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Message_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Message_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Message_templates.
     */
    distinct?: Message_templatesScalarFieldEnum | Message_templatesScalarFieldEnum[]
  }

  /**
   * Message_templates findMany
   */
  export type Message_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * Filter, which Message_templates to fetch.
     */
    where?: Message_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Message_templates to fetch.
     */
    orderBy?: Message_templatesOrderByWithRelationInput | Message_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Message_templates.
     */
    cursor?: Message_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Message_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Message_templates.
     */
    skip?: number
    distinct?: Message_templatesScalarFieldEnum | Message_templatesScalarFieldEnum[]
  }

  /**
   * Message_templates create
   */
  export type Message_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * The data needed to create a Message_templates.
     */
    data: XOR<Message_templatesCreateInput, Message_templatesUncheckedCreateInput>
  }

  /**
   * Message_templates createMany
   */
  export type Message_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Message_templates.
     */
    data: Message_templatesCreateManyInput | Message_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message_templates createManyAndReturn
   */
  export type Message_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many Message_templates.
     */
    data: Message_templatesCreateManyInput | Message_templatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message_templates update
   */
  export type Message_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * The data needed to update a Message_templates.
     */
    data: XOR<Message_templatesUpdateInput, Message_templatesUncheckedUpdateInput>
    /**
     * Choose, which Message_templates to update.
     */
    where: Message_templatesWhereUniqueInput
  }

  /**
   * Message_templates updateMany
   */
  export type Message_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Message_templates.
     */
    data: XOR<Message_templatesUpdateManyMutationInput, Message_templatesUncheckedUpdateManyInput>
    /**
     * Filter which Message_templates to update
     */
    where?: Message_templatesWhereInput
  }

  /**
   * Message_templates updateManyAndReturn
   */
  export type Message_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * The data used to update Message_templates.
     */
    data: XOR<Message_templatesUpdateManyMutationInput, Message_templatesUncheckedUpdateManyInput>
    /**
     * Filter which Message_templates to update
     */
    where?: Message_templatesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message_templates upsert
   */
  export type Message_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * The filter to search for the Message_templates to update in case it exists.
     */
    where: Message_templatesWhereUniqueInput
    /**
     * In case the Message_templates found by the `where` argument doesn't exist, create a new Message_templates with this data.
     */
    create: XOR<Message_templatesCreateInput, Message_templatesUncheckedCreateInput>
    /**
     * In case the Message_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Message_templatesUpdateInput, Message_templatesUncheckedUpdateInput>
  }

  /**
   * Message_templates delete
   */
  export type Message_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
    /**
     * Filter which Message_templates to delete.
     */
    where: Message_templatesWhereUniqueInput
  }

  /**
   * Message_templates deleteMany
   */
  export type Message_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message_templates to delete
     */
    where?: Message_templatesWhereInput
  }

  /**
   * Message_templates without action
   */
  export type Message_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message_templates
     */
    select?: Message_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message_templates
     */
    omit?: Message_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Message_templatesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone_number: 'phone_number',
    fullname: 'fullname',
    password: 'password',
    profilesId: 'profilesId',
    rolesId: 'rolesId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfilesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    locationId: 'locationId'
  };

  export type ProfilesScalarFieldEnum = (typeof ProfilesScalarFieldEnum)[keyof typeof ProfilesScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    attachments: 'attachments',
    is_active: 'is_active',
    size: 'size',
    minimum_order: 'minimum_order',
    storesId: 'storesId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const StoresScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slogan: 'slogan',
    description: 'description',
    domain: 'domain',
    logo_attachment: 'logo_attachment',
    banner_attachment: 'banner_attachment'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const Bank_accountsScalarFieldEnum: {
    id: 'id',
    bank: 'bank',
    acc_number: 'acc_number',
    acc_name: 'acc_name',
    storesId: 'storesId'
  };

  export type Bank_accountsScalarFieldEnum = (typeof Bank_accountsScalarFieldEnum)[keyof typeof Bank_accountsScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    postal_code: 'postal_code',
    city_district: 'city_district',
    is_main_location: 'is_main_location',
    longitude: 'longitude',
    latitude: 'latitude',
    storesId: 'storesId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const Variant_option_valuesScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    weight: 'weight',
    stock: 'stock',
    price: 'price',
    is_active: 'is_active',
    variant_optionsId: 'variant_optionsId'
  };

  export type Variant_option_valuesScalarFieldEnum = (typeof Variant_option_valuesScalarFieldEnum)[keyof typeof Variant_option_valuesScalarFieldEnum]


  export const Variant_optionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    variantsId: 'variantsId'
  };

  export type Variant_optionsScalarFieldEnum = (typeof Variant_optionsScalarFieldEnum)[keyof typeof Variant_optionsScalarFieldEnum]


  export const VariantsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_active: 'is_active',
    productId: 'productId'
  };

  export type VariantsScalarFieldEnum = (typeof VariantsScalarFieldEnum)[keyof typeof VariantsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    productId: 'productId'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CartsScalarFieldEnum: {
    id: 'id',
    prices: 'prices',
    discount: 'discount',
    userId: 'userId',
    storesId: 'storesId'
  };

  export type CartsScalarFieldEnum = (typeof CartsScalarFieldEnum)[keyof typeof CartsScalarFieldEnum]


  export const Cart_itemsScalarFieldEnum: {
    id: 'id',
    qty: 'qty',
    price: 'price',
    cartsId: 'cartsId',
    userId: 'userId',
    storesId: 'storesId',
    variant_option_valuesId: 'variant_option_valuesId'
  };

  export type Cart_itemsScalarFieldEnum = (typeof Cart_itemsScalarFieldEnum)[keyof typeof Cart_itemsScalarFieldEnum]


  export const InvoicesScalarFieldEnum: {
    id: 'id',
    prices: 'prices',
    status: 'status',
    receiver_longitude: 'receiver_longitude',
    receiver_latitude: 'receiver_latitude',
    receiver_district: 'receiver_district',
    receiver_phone: 'receiver_phone',
    receiver_address: 'receiver_address',
    receiver_name: 'receiver_name',
    invoice_number: 'invoice_number',
    cartsId: 'cartsId',
    userId: 'userId',
    paymentsId: 'paymentsId'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const Confirmation_paymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    bank: 'bank',
    invoicesId: 'invoicesId'
  };

  export type Confirmation_paymentScalarFieldEnum = (typeof Confirmation_paymentScalarFieldEnum)[keyof typeof Confirmation_paymentScalarFieldEnum]


  export const Invoice_historiesScalarFieldEnum: {
    id: 'id',
    status: 'status',
    created_at: 'created_at',
    invoicesId: 'invoicesId'
  };

  export type Invoice_historiesScalarFieldEnum = (typeof Invoice_historiesScalarFieldEnum)[keyof typeof Invoice_historiesScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    bank: 'bank',
    amount: 'amount',
    status: 'status',
    moota_transaction_id: 'moota_transaction_id',
    userId: 'userId',
    invoicesId: 'invoicesId'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const CouriersScalarFieldEnum: {
    id: 'id',
    courier_code: 'courier_code',
    courier_service_name: 'courier_service_name',
    courier_service_code: 'courier_service_code',
    price: 'price',
    order_id: 'order_id',
    invoicesId: 'invoicesId'
  };

  export type CouriersScalarFieldEnum = (typeof CouriersScalarFieldEnum)[keyof typeof CouriersScalarFieldEnum]


  export const DecorationScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type DecorationScalarFieldEnum = (typeof DecorationScalarFieldEnum)[keyof typeof DecorationScalarFieldEnum]


  export const Stores_on_decorationsScalarFieldEnum: {
    id: 'id',
    storesId: 'storesId'
  };

  export type Stores_on_decorationsScalarFieldEnum = (typeof Stores_on_decorationsScalarFieldEnum)[keyof typeof Stores_on_decorationsScalarFieldEnum]


  export const Operation_hoursScalarFieldEnum: {
    id: 'id',
    day: 'day',
    open_at: 'open_at',
    close_at: 'close_at',
    is_off: 'is_off',
    storesId: 'storesId'
  };

  export type Operation_hoursScalarFieldEnum = (typeof Operation_hoursScalarFieldEnum)[keyof typeof Operation_hoursScalarFieldEnum]


  export const Message_templatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    storesId: 'storesId'
  };

  export type Message_templatesScalarFieldEnum = (typeof Message_templatesScalarFieldEnum)[keyof typeof Message_templatesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    fullname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profilesId?: StringNullableFilter<"User"> | string | null
    rolesId?: StringNullableFilter<"User"> | string | null
    profile_id?: XOR<ProfilesNullableScalarRelationFilter, ProfilesWhereInput> | null
    role_id?: XOR<RolesNullableScalarRelationFilter, RolesWhereInput> | null
    Carts?: CartsListRelationFilter
    Cart_items?: Cart_itemsListRelationFilter
    Invoices?: InvoicesListRelationFilter
    Payments?: PaymentsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    fullname?: SortOrder
    password?: SortOrder
    profilesId?: SortOrderInput | SortOrder
    rolesId?: SortOrderInput | SortOrder
    profile_id?: ProfilesOrderByWithRelationInput
    role_id?: RolesOrderByWithRelationInput
    Carts?: CartsOrderByRelationAggregateInput
    Cart_items?: Cart_itemsOrderByRelationAggregateInput
    Invoices?: InvoicesOrderByRelationAggregateInput
    Payments?: PaymentsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone_number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profilesId?: StringNullableFilter<"User"> | string | null
    rolesId?: StringNullableFilter<"User"> | string | null
    profile_id?: XOR<ProfilesNullableScalarRelationFilter, ProfilesWhereInput> | null
    role_id?: XOR<RolesNullableScalarRelationFilter, RolesWhereInput> | null
    Carts?: CartsListRelationFilter
    Cart_items?: Cart_itemsListRelationFilter
    Invoices?: InvoicesListRelationFilter
    Payments?: PaymentsListRelationFilter
  }, "id" | "id" | "email" | "phone_number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    fullname?: SortOrder
    password?: SortOrder
    profilesId?: SortOrderInput | SortOrder
    rolesId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone_number?: StringWithAggregatesFilter<"User"> | string
    fullname?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    profilesId?: StringNullableWithAggregatesFilter<"User"> | string | null
    rolesId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProfilesWhereInput = {
    AND?: ProfilesWhereInput | ProfilesWhereInput[]
    OR?: ProfilesWhereInput[]
    NOT?: ProfilesWhereInput | ProfilesWhereInput[]
    id?: StringFilter<"Profiles"> | string
    user_id?: StringNullableFilter<"Profiles"> | string | null
    locationId?: StringFilter<"Profiles"> | string
    locations?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    User?: UserListRelationFilter
  }

  export type ProfilesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    locationId?: SortOrder
    locations?: LocationOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
  }

  export type ProfilesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId?: string
    AND?: ProfilesWhereInput | ProfilesWhereInput[]
    OR?: ProfilesWhereInput[]
    NOT?: ProfilesWhereInput | ProfilesWhereInput[]
    user_id?: StringNullableFilter<"Profiles"> | string | null
    locations?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    User?: UserListRelationFilter
  }, "id" | "id" | "locationId">

  export type ProfilesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    locationId?: SortOrder
    _count?: ProfilesCountOrderByAggregateInput
    _max?: ProfilesMaxOrderByAggregateInput
    _min?: ProfilesMinOrderByAggregateInput
  }

  export type ProfilesScalarWhereWithAggregatesInput = {
    AND?: ProfilesScalarWhereWithAggregatesInput | ProfilesScalarWhereWithAggregatesInput[]
    OR?: ProfilesScalarWhereWithAggregatesInput[]
    NOT?: ProfilesScalarWhereWithAggregatesInput | ProfilesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profiles"> | string
    user_id?: StringNullableWithAggregatesFilter<"Profiles"> | string | null
    locationId?: StringWithAggregatesFilter<"Profiles"> | string
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: StringFilter<"Roles"> | string
    name?: StringNullableFilter<"Roles"> | string | null
    User?: UserListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    User?: UserOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    name?: StringNullableFilter<"Roles"> | string | null
    User?: UserListRelationFilter
  }, "id" | "id">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: RolesCountOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roles"> | string
    name?: StringNullableWithAggregatesFilter<"Roles"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    attachments?: StringFilter<"Product"> | string
    is_active?: BoolNullableFilter<"Product"> | boolean | null
    size?: StringNullableFilter<"Product"> | string | null
    minimum_order?: IntNullableFilter<"Product"> | number | null
    storesId?: StringNullableFilter<"Product"> | string | null
    variants?: XOR<VariantsNullableScalarRelationFilter, VariantsWhereInput> | null
    store_id?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    Categories?: CategoriesListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    attachments?: SortOrder
    is_active?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    minimum_order?: SortOrderInput | SortOrder
    storesId?: SortOrderInput | SortOrder
    variants?: VariantsOrderByWithRelationInput
    store_id?: StoresOrderByWithRelationInput
    Categories?: CategoriesOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    attachments?: StringFilter<"Product"> | string
    is_active?: BoolNullableFilter<"Product"> | boolean | null
    size?: StringNullableFilter<"Product"> | string | null
    minimum_order?: IntNullableFilter<"Product"> | number | null
    storesId?: StringNullableFilter<"Product"> | string | null
    variants?: XOR<VariantsNullableScalarRelationFilter, VariantsWhereInput> | null
    store_id?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    Categories?: CategoriesListRelationFilter
  }, "id" | "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    attachments?: SortOrder
    is_active?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    minimum_order?: SortOrderInput | SortOrder
    storesId?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    attachments?: StringWithAggregatesFilter<"Product"> | string
    is_active?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    size?: StringNullableWithAggregatesFilter<"Product"> | string | null
    minimum_order?: IntNullableWithAggregatesFilter<"Product"> | number | null
    storesId?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type StoresWhereInput = {
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    id?: StringFilter<"Stores"> | string
    name?: StringFilter<"Stores"> | string
    slogan?: StringNullableFilter<"Stores"> | string | null
    description?: StringNullableFilter<"Stores"> | string | null
    domain?: StringNullableFilter<"Stores"> | string | null
    logo_attachment?: StringNullableFilter<"Stores"> | string | null
    banner_attachment?: StringNullableFilter<"Stores"> | string | null
    Product?: ProductListRelationFilter
    bank_accounts?: Bank_accountsListRelationFilter
    Location?: LocationListRelationFilter
    Carts?: CartsListRelationFilter
    Cart_items?: Cart_itemsListRelationFilter
    Stores_on_decorations?: Stores_on_decorationsListRelationFilter
    Operation_hours?: Operation_hoursListRelationFilter
    Message_templates?: Message_templatesListRelationFilter
  }

  export type StoresOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slogan?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    logo_attachment?: SortOrderInput | SortOrder
    banner_attachment?: SortOrderInput | SortOrder
    Product?: ProductOrderByRelationAggregateInput
    bank_accounts?: bank_accountsOrderByRelationAggregateInput
    Location?: LocationOrderByRelationAggregateInput
    Carts?: CartsOrderByRelationAggregateInput
    Cart_items?: Cart_itemsOrderByRelationAggregateInput
    Stores_on_decorations?: Stores_on_decorationsOrderByRelationAggregateInput
    Operation_hours?: Operation_hoursOrderByRelationAggregateInput
    Message_templates?: Message_templatesOrderByRelationAggregateInput
  }

  export type StoresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    slogan?: StringNullableFilter<"Stores"> | string | null
    description?: StringNullableFilter<"Stores"> | string | null
    domain?: StringNullableFilter<"Stores"> | string | null
    logo_attachment?: StringNullableFilter<"Stores"> | string | null
    banner_attachment?: StringNullableFilter<"Stores"> | string | null
    Product?: ProductListRelationFilter
    bank_accounts?: Bank_accountsListRelationFilter
    Location?: LocationListRelationFilter
    Carts?: CartsListRelationFilter
    Cart_items?: Cart_itemsListRelationFilter
    Stores_on_decorations?: Stores_on_decorationsListRelationFilter
    Operation_hours?: Operation_hoursListRelationFilter
    Message_templates?: Message_templatesListRelationFilter
  }, "id" | "id" | "name">

  export type StoresOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slogan?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    logo_attachment?: SortOrderInput | SortOrder
    banner_attachment?: SortOrderInput | SortOrder
    _count?: StoresCountOrderByAggregateInput
    _max?: StoresMaxOrderByAggregateInput
    _min?: StoresMinOrderByAggregateInput
  }

  export type StoresScalarWhereWithAggregatesInput = {
    AND?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    OR?: StoresScalarWhereWithAggregatesInput[]
    NOT?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stores"> | string
    name?: StringWithAggregatesFilter<"Stores"> | string
    slogan?: StringNullableWithAggregatesFilter<"Stores"> | string | null
    description?: StringNullableWithAggregatesFilter<"Stores"> | string | null
    domain?: StringNullableWithAggregatesFilter<"Stores"> | string | null
    logo_attachment?: StringNullableWithAggregatesFilter<"Stores"> | string | null
    banner_attachment?: StringNullableWithAggregatesFilter<"Stores"> | string | null
  }

  export type bank_accountsWhereInput = {
    AND?: bank_accountsWhereInput | bank_accountsWhereInput[]
    OR?: bank_accountsWhereInput[]
    NOT?: bank_accountsWhereInput | bank_accountsWhereInput[]
    id?: StringFilter<"bank_accounts"> | string
    bank?: StringFilter<"bank_accounts"> | string
    acc_number?: StringFilter<"bank_accounts"> | string
    acc_name?: StringFilter<"bank_accounts"> | string
    storesId?: StringNullableFilter<"bank_accounts"> | string | null
    store_id?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
  }

  export type bank_accountsOrderByWithRelationInput = {
    id?: SortOrder
    bank?: SortOrder
    acc_number?: SortOrder
    acc_name?: SortOrder
    storesId?: SortOrderInput | SortOrder
    store_id?: StoresOrderByWithRelationInput
  }

  export type bank_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bank_accountsWhereInput | bank_accountsWhereInput[]
    OR?: bank_accountsWhereInput[]
    NOT?: bank_accountsWhereInput | bank_accountsWhereInput[]
    bank?: StringFilter<"bank_accounts"> | string
    acc_number?: StringFilter<"bank_accounts"> | string
    acc_name?: StringFilter<"bank_accounts"> | string
    storesId?: StringNullableFilter<"bank_accounts"> | string | null
    store_id?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
  }, "id" | "id">

  export type bank_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    bank?: SortOrder
    acc_number?: SortOrder
    acc_name?: SortOrder
    storesId?: SortOrderInput | SortOrder
    _count?: bank_accountsCountOrderByAggregateInput
    _max?: bank_accountsMaxOrderByAggregateInput
    _min?: bank_accountsMinOrderByAggregateInput
  }

  export type bank_accountsScalarWhereWithAggregatesInput = {
    AND?: bank_accountsScalarWhereWithAggregatesInput | bank_accountsScalarWhereWithAggregatesInput[]
    OR?: bank_accountsScalarWhereWithAggregatesInput[]
    NOT?: bank_accountsScalarWhereWithAggregatesInput | bank_accountsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"bank_accounts"> | string
    bank?: StringWithAggregatesFilter<"bank_accounts"> | string
    acc_number?: StringWithAggregatesFilter<"bank_accounts"> | string
    acc_name?: StringWithAggregatesFilter<"bank_accounts"> | string
    storesId?: StringNullableWithAggregatesFilter<"bank_accounts"> | string | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    postal_code?: StringFilter<"Location"> | string
    city_district?: StringFilter<"Location"> | string
    is_main_location?: BoolNullableFilter<"Location"> | boolean | null
    longitude?: StringFilter<"Location"> | string
    latitude?: StringFilter<"Location"> | string
    storesId?: StringNullableFilter<"Location"> | string | null
    store_id?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    profile_id?: XOR<ProfilesNullableScalarRelationFilter, ProfilesWhereInput> | null
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postal_code?: SortOrder
    city_district?: SortOrder
    is_main_location?: SortOrderInput | SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    storesId?: SortOrderInput | SortOrder
    store_id?: StoresOrderByWithRelationInput
    profile_id?: ProfilesOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    postal_code?: StringFilter<"Location"> | string
    city_district?: StringFilter<"Location"> | string
    is_main_location?: BoolNullableFilter<"Location"> | boolean | null
    longitude?: StringFilter<"Location"> | string
    latitude?: StringFilter<"Location"> | string
    storesId?: StringNullableFilter<"Location"> | string | null
    store_id?: XOR<StoresNullableScalarRelationFilter, StoresWhereInput> | null
    profile_id?: XOR<ProfilesNullableScalarRelationFilter, ProfilesWhereInput> | null
  }, "id" | "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postal_code?: SortOrder
    city_district?: SortOrder
    is_main_location?: SortOrderInput | SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    storesId?: SortOrderInput | SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringWithAggregatesFilter<"Location"> | string
    postal_code?: StringWithAggregatesFilter<"Location"> | string
    city_district?: StringWithAggregatesFilter<"Location"> | string
    is_main_location?: BoolNullableWithAggregatesFilter<"Location"> | boolean | null
    longitude?: StringWithAggregatesFilter<"Location"> | string
    latitude?: StringWithAggregatesFilter<"Location"> | string
    storesId?: StringNullableWithAggregatesFilter<"Location"> | string | null
  }

  export type Variant_option_valuesWhereInput = {
    AND?: Variant_option_valuesWhereInput | Variant_option_valuesWhereInput[]
    OR?: Variant_option_valuesWhereInput[]
    NOT?: Variant_option_valuesWhereInput | Variant_option_valuesWhereInput[]
    id?: StringFilter<"Variant_option_values"> | string
    sku?: StringFilter<"Variant_option_values"> | string
    weight?: StringFilter<"Variant_option_values"> | string
    stock?: IntFilter<"Variant_option_values"> | number
    price?: IntFilter<"Variant_option_values"> | number
    is_active?: BoolFilter<"Variant_option_values"> | boolean
    variant_optionsId?: StringFilter<"Variant_option_values"> | string
    variant_option_id?: XOR<Variant_optionsScalarRelationFilter, Variant_optionsWhereInput>
    Cart_items?: Cart_itemsListRelationFilter
  }

  export type Variant_option_valuesOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    variant_optionsId?: SortOrder
    variant_option_id?: Variant_optionsOrderByWithRelationInput
    Cart_items?: Cart_itemsOrderByRelationAggregateInput
  }

  export type Variant_option_valuesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Variant_option_valuesWhereInput | Variant_option_valuesWhereInput[]
    OR?: Variant_option_valuesWhereInput[]
    NOT?: Variant_option_valuesWhereInput | Variant_option_valuesWhereInput[]
    sku?: StringFilter<"Variant_option_values"> | string
    weight?: StringFilter<"Variant_option_values"> | string
    stock?: IntFilter<"Variant_option_values"> | number
    price?: IntFilter<"Variant_option_values"> | number
    is_active?: BoolFilter<"Variant_option_values"> | boolean
    variant_optionsId?: StringFilter<"Variant_option_values"> | string
    variant_option_id?: XOR<Variant_optionsScalarRelationFilter, Variant_optionsWhereInput>
    Cart_items?: Cart_itemsListRelationFilter
  }, "id" | "id">

  export type Variant_option_valuesOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    variant_optionsId?: SortOrder
    _count?: Variant_option_valuesCountOrderByAggregateInput
    _avg?: Variant_option_valuesAvgOrderByAggregateInput
    _max?: Variant_option_valuesMaxOrderByAggregateInput
    _min?: Variant_option_valuesMinOrderByAggregateInput
    _sum?: Variant_option_valuesSumOrderByAggregateInput
  }

  export type Variant_option_valuesScalarWhereWithAggregatesInput = {
    AND?: Variant_option_valuesScalarWhereWithAggregatesInput | Variant_option_valuesScalarWhereWithAggregatesInput[]
    OR?: Variant_option_valuesScalarWhereWithAggregatesInput[]
    NOT?: Variant_option_valuesScalarWhereWithAggregatesInput | Variant_option_valuesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Variant_option_values"> | string
    sku?: StringWithAggregatesFilter<"Variant_option_values"> | string
    weight?: StringWithAggregatesFilter<"Variant_option_values"> | string
    stock?: IntWithAggregatesFilter<"Variant_option_values"> | number
    price?: IntWithAggregatesFilter<"Variant_option_values"> | number
    is_active?: BoolWithAggregatesFilter<"Variant_option_values"> | boolean
    variant_optionsId?: StringWithAggregatesFilter<"Variant_option_values"> | string
  }

  export type Variant_optionsWhereInput = {
    AND?: Variant_optionsWhereInput | Variant_optionsWhereInput[]
    OR?: Variant_optionsWhereInput[]
    NOT?: Variant_optionsWhereInput | Variant_optionsWhereInput[]
    id?: StringFilter<"Variant_options"> | string
    name?: StringFilter<"Variant_options"> | string
    variantsId?: StringFilter<"Variant_options"> | string
    variant_id?: XOR<VariantsScalarRelationFilter, VariantsWhereInput>
    Variant_option_values?: Variant_option_valuesListRelationFilter
  }

  export type Variant_optionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    variantsId?: SortOrder
    variant_id?: VariantsOrderByWithRelationInput
    Variant_option_values?: Variant_option_valuesOrderByRelationAggregateInput
  }

  export type Variant_optionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Variant_optionsWhereInput | Variant_optionsWhereInput[]
    OR?: Variant_optionsWhereInput[]
    NOT?: Variant_optionsWhereInput | Variant_optionsWhereInput[]
    name?: StringFilter<"Variant_options"> | string
    variantsId?: StringFilter<"Variant_options"> | string
    variant_id?: XOR<VariantsScalarRelationFilter, VariantsWhereInput>
    Variant_option_values?: Variant_option_valuesListRelationFilter
  }, "id" | "id">

  export type Variant_optionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    variantsId?: SortOrder
    _count?: Variant_optionsCountOrderByAggregateInput
    _max?: Variant_optionsMaxOrderByAggregateInput
    _min?: Variant_optionsMinOrderByAggregateInput
  }

  export type Variant_optionsScalarWhereWithAggregatesInput = {
    AND?: Variant_optionsScalarWhereWithAggregatesInput | Variant_optionsScalarWhereWithAggregatesInput[]
    OR?: Variant_optionsScalarWhereWithAggregatesInput[]
    NOT?: Variant_optionsScalarWhereWithAggregatesInput | Variant_optionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Variant_options"> | string
    name?: StringWithAggregatesFilter<"Variant_options"> | string
    variantsId?: StringWithAggregatesFilter<"Variant_options"> | string
  }

  export type VariantsWhereInput = {
    AND?: VariantsWhereInput | VariantsWhereInput[]
    OR?: VariantsWhereInput[]
    NOT?: VariantsWhereInput | VariantsWhereInput[]
    id?: StringFilter<"Variants"> | string
    name?: StringFilter<"Variants"> | string
    is_active?: BoolFilter<"Variants"> | boolean
    productId?: StringFilter<"Variants"> | string
    product_id?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Variant_options?: Variant_optionsListRelationFilter
  }

  export type VariantsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    productId?: SortOrder
    product_id?: ProductOrderByWithRelationInput
    Variant_options?: Variant_optionsOrderByRelationAggregateInput
  }

  export type VariantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: VariantsWhereInput | VariantsWhereInput[]
    OR?: VariantsWhereInput[]
    NOT?: VariantsWhereInput | VariantsWhereInput[]
    name?: StringFilter<"Variants"> | string
    is_active?: BoolFilter<"Variants"> | boolean
    product_id?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    Variant_options?: Variant_optionsListRelationFilter
  }, "id" | "id" | "productId">

  export type VariantsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    productId?: SortOrder
    _count?: VariantsCountOrderByAggregateInput
    _max?: VariantsMaxOrderByAggregateInput
    _min?: VariantsMinOrderByAggregateInput
  }

  export type VariantsScalarWhereWithAggregatesInput = {
    AND?: VariantsScalarWhereWithAggregatesInput | VariantsScalarWhereWithAggregatesInput[]
    OR?: VariantsScalarWhereWithAggregatesInput[]
    NOT?: VariantsScalarWhereWithAggregatesInput | VariantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Variants"> | string
    name?: StringWithAggregatesFilter<"Variants"> | string
    is_active?: BoolWithAggregatesFilter<"Variants"> | boolean
    productId?: StringWithAggregatesFilter<"Variants"> | string
  }

  export type CategoriesWhereInput = {
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    id?: StringFilter<"Categories"> | string
    name?: StringFilter<"Categories"> | string
    productId?: StringFilter<"Categories"> | string
    product_id?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CategoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    product_id?: ProductOrderByWithRelationInput
  }

  export type CategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoriesWhereInput | CategoriesWhereInput[]
    OR?: CategoriesWhereInput[]
    NOT?: CategoriesWhereInput | CategoriesWhereInput[]
    name?: StringFilter<"Categories"> | string
    productId?: StringFilter<"Categories"> | string
    product_id?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "id">

  export type CategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
    _count?: CategoriesCountOrderByAggregateInput
    _max?: CategoriesMaxOrderByAggregateInput
    _min?: CategoriesMinOrderByAggregateInput
  }

  export type CategoriesScalarWhereWithAggregatesInput = {
    AND?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    OR?: CategoriesScalarWhereWithAggregatesInput[]
    NOT?: CategoriesScalarWhereWithAggregatesInput | CategoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Categories"> | string
    name?: StringWithAggregatesFilter<"Categories"> | string
    productId?: StringWithAggregatesFilter<"Categories"> | string
  }

  export type CartsWhereInput = {
    AND?: CartsWhereInput | CartsWhereInput[]
    OR?: CartsWhereInput[]
    NOT?: CartsWhereInput | CartsWhereInput[]
    id?: StringFilter<"Carts"> | string
    prices?: IntFilter<"Carts"> | number
    discount?: StringNullableFilter<"Carts"> | string | null
    userId?: StringFilter<"Carts"> | string
    storesId?: StringFilter<"Carts"> | string
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    Cart_items?: Cart_itemsListRelationFilter
    Invoices?: InvoicesListRelationFilter
  }

  export type CartsOrderByWithRelationInput = {
    id?: SortOrder
    prices?: SortOrder
    discount?: SortOrderInput | SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    user_id?: UserOrderByWithRelationInput
    store_id?: StoresOrderByWithRelationInput
    Cart_items?: Cart_itemsOrderByRelationAggregateInput
    Invoices?: InvoicesOrderByRelationAggregateInput
  }

  export type CartsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartsWhereInput | CartsWhereInput[]
    OR?: CartsWhereInput[]
    NOT?: CartsWhereInput | CartsWhereInput[]
    prices?: IntFilter<"Carts"> | number
    discount?: StringNullableFilter<"Carts"> | string | null
    userId?: StringFilter<"Carts"> | string
    storesId?: StringFilter<"Carts"> | string
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    Cart_items?: Cart_itemsListRelationFilter
    Invoices?: InvoicesListRelationFilter
  }, "id" | "id">

  export type CartsOrderByWithAggregationInput = {
    id?: SortOrder
    prices?: SortOrder
    discount?: SortOrderInput | SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    _count?: CartsCountOrderByAggregateInput
    _avg?: CartsAvgOrderByAggregateInput
    _max?: CartsMaxOrderByAggregateInput
    _min?: CartsMinOrderByAggregateInput
    _sum?: CartsSumOrderByAggregateInput
  }

  export type CartsScalarWhereWithAggregatesInput = {
    AND?: CartsScalarWhereWithAggregatesInput | CartsScalarWhereWithAggregatesInput[]
    OR?: CartsScalarWhereWithAggregatesInput[]
    NOT?: CartsScalarWhereWithAggregatesInput | CartsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Carts"> | string
    prices?: IntWithAggregatesFilter<"Carts"> | number
    discount?: StringNullableWithAggregatesFilter<"Carts"> | string | null
    userId?: StringWithAggregatesFilter<"Carts"> | string
    storesId?: StringWithAggregatesFilter<"Carts"> | string
  }

  export type Cart_itemsWhereInput = {
    AND?: Cart_itemsWhereInput | Cart_itemsWhereInput[]
    OR?: Cart_itemsWhereInput[]
    NOT?: Cart_itemsWhereInput | Cart_itemsWhereInput[]
    id?: StringFilter<"Cart_items"> | string
    qty?: IntFilter<"Cart_items"> | number
    price?: IntFilter<"Cart_items"> | number
    cartsId?: StringFilter<"Cart_items"> | string
    userId?: StringFilter<"Cart_items"> | string
    storesId?: StringFilter<"Cart_items"> | string
    variant_option_valuesId?: StringFilter<"Cart_items"> | string
    cart_id?: XOR<CartsScalarRelationFilter, CartsWhereInput>
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    variant_option_value_id?: XOR<Variant_option_valuesScalarRelationFilter, Variant_option_valuesWhereInput>
  }

  export type Cart_itemsOrderByWithRelationInput = {
    id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    variant_option_valuesId?: SortOrder
    cart_id?: CartsOrderByWithRelationInput
    user_id?: UserOrderByWithRelationInput
    store_id?: StoresOrderByWithRelationInput
    variant_option_value_id?: Variant_option_valuesOrderByWithRelationInput
  }

  export type Cart_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Cart_itemsWhereInput | Cart_itemsWhereInput[]
    OR?: Cart_itemsWhereInput[]
    NOT?: Cart_itemsWhereInput | Cart_itemsWhereInput[]
    qty?: IntFilter<"Cart_items"> | number
    price?: IntFilter<"Cart_items"> | number
    cartsId?: StringFilter<"Cart_items"> | string
    userId?: StringFilter<"Cart_items"> | string
    storesId?: StringFilter<"Cart_items"> | string
    variant_option_valuesId?: StringFilter<"Cart_items"> | string
    cart_id?: XOR<CartsScalarRelationFilter, CartsWhereInput>
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
    variant_option_value_id?: XOR<Variant_option_valuesScalarRelationFilter, Variant_option_valuesWhereInput>
  }, "id" | "id">

  export type Cart_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    variant_option_valuesId?: SortOrder
    _count?: Cart_itemsCountOrderByAggregateInput
    _avg?: Cart_itemsAvgOrderByAggregateInput
    _max?: Cart_itemsMaxOrderByAggregateInput
    _min?: Cart_itemsMinOrderByAggregateInput
    _sum?: Cart_itemsSumOrderByAggregateInput
  }

  export type Cart_itemsScalarWhereWithAggregatesInput = {
    AND?: Cart_itemsScalarWhereWithAggregatesInput | Cart_itemsScalarWhereWithAggregatesInput[]
    OR?: Cart_itemsScalarWhereWithAggregatesInput[]
    NOT?: Cart_itemsScalarWhereWithAggregatesInput | Cart_itemsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart_items"> | string
    qty?: IntWithAggregatesFilter<"Cart_items"> | number
    price?: IntWithAggregatesFilter<"Cart_items"> | number
    cartsId?: StringWithAggregatesFilter<"Cart_items"> | string
    userId?: StringWithAggregatesFilter<"Cart_items"> | string
    storesId?: StringWithAggregatesFilter<"Cart_items"> | string
    variant_option_valuesId?: StringWithAggregatesFilter<"Cart_items"> | string
  }

  export type InvoicesWhereInput = {
    AND?: InvoicesWhereInput | InvoicesWhereInput[]
    OR?: InvoicesWhereInput[]
    NOT?: InvoicesWhereInput | InvoicesWhereInput[]
    id?: StringFilter<"Invoices"> | string
    prices?: IntFilter<"Invoices"> | number
    status?: BoolFilter<"Invoices"> | boolean
    receiver_longitude?: StringFilter<"Invoices"> | string
    receiver_latitude?: StringFilter<"Invoices"> | string
    receiver_district?: StringFilter<"Invoices"> | string
    receiver_phone?: StringFilter<"Invoices"> | string
    receiver_address?: StringFilter<"Invoices"> | string
    receiver_name?: StringFilter<"Invoices"> | string
    invoice_number?: StringFilter<"Invoices"> | string
    cartsId?: StringFilter<"Invoices"> | string
    userId?: StringFilter<"Invoices"> | string
    paymentsId?: StringFilter<"Invoices"> | string
    cart_id?: XOR<CartsScalarRelationFilter, CartsWhereInput>
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
    courier_id?: XOR<CouriersNullableScalarRelationFilter, CouriersWhereInput> | null
    payment_id?: XOR<PaymentsNullableScalarRelationFilter, PaymentsWhereInput> | null
    Confirmation_payment?: Confirmation_paymentListRelationFilter
    Invoice_histories?: Invoice_historiesListRelationFilter
  }

  export type InvoicesOrderByWithRelationInput = {
    id?: SortOrder
    prices?: SortOrder
    status?: SortOrder
    receiver_longitude?: SortOrder
    receiver_latitude?: SortOrder
    receiver_district?: SortOrder
    receiver_phone?: SortOrder
    receiver_address?: SortOrder
    receiver_name?: SortOrder
    invoice_number?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    paymentsId?: SortOrder
    cart_id?: CartsOrderByWithRelationInput
    user_id?: UserOrderByWithRelationInput
    courier_id?: CouriersOrderByWithRelationInput
    payment_id?: PaymentsOrderByWithRelationInput
    Confirmation_payment?: Confirmation_paymentOrderByRelationAggregateInput
    Invoice_histories?: Invoice_historiesOrderByRelationAggregateInput
  }

  export type InvoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentsId?: string
    AND?: InvoicesWhereInput | InvoicesWhereInput[]
    OR?: InvoicesWhereInput[]
    NOT?: InvoicesWhereInput | InvoicesWhereInput[]
    prices?: IntFilter<"Invoices"> | number
    status?: BoolFilter<"Invoices"> | boolean
    receiver_longitude?: StringFilter<"Invoices"> | string
    receiver_latitude?: StringFilter<"Invoices"> | string
    receiver_district?: StringFilter<"Invoices"> | string
    receiver_phone?: StringFilter<"Invoices"> | string
    receiver_address?: StringFilter<"Invoices"> | string
    receiver_name?: StringFilter<"Invoices"> | string
    invoice_number?: StringFilter<"Invoices"> | string
    cartsId?: StringFilter<"Invoices"> | string
    userId?: StringFilter<"Invoices"> | string
    cart_id?: XOR<CartsScalarRelationFilter, CartsWhereInput>
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
    courier_id?: XOR<CouriersNullableScalarRelationFilter, CouriersWhereInput> | null
    payment_id?: XOR<PaymentsNullableScalarRelationFilter, PaymentsWhereInput> | null
    Confirmation_payment?: Confirmation_paymentListRelationFilter
    Invoice_histories?: Invoice_historiesListRelationFilter
  }, "id" | "id" | "paymentsId">

  export type InvoicesOrderByWithAggregationInput = {
    id?: SortOrder
    prices?: SortOrder
    status?: SortOrder
    receiver_longitude?: SortOrder
    receiver_latitude?: SortOrder
    receiver_district?: SortOrder
    receiver_phone?: SortOrder
    receiver_address?: SortOrder
    receiver_name?: SortOrder
    invoice_number?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    paymentsId?: SortOrder
    _count?: InvoicesCountOrderByAggregateInput
    _avg?: InvoicesAvgOrderByAggregateInput
    _max?: InvoicesMaxOrderByAggregateInput
    _min?: InvoicesMinOrderByAggregateInput
    _sum?: InvoicesSumOrderByAggregateInput
  }

  export type InvoicesScalarWhereWithAggregatesInput = {
    AND?: InvoicesScalarWhereWithAggregatesInput | InvoicesScalarWhereWithAggregatesInput[]
    OR?: InvoicesScalarWhereWithAggregatesInput[]
    NOT?: InvoicesScalarWhereWithAggregatesInput | InvoicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoices"> | string
    prices?: IntWithAggregatesFilter<"Invoices"> | number
    status?: BoolWithAggregatesFilter<"Invoices"> | boolean
    receiver_longitude?: StringWithAggregatesFilter<"Invoices"> | string
    receiver_latitude?: StringWithAggregatesFilter<"Invoices"> | string
    receiver_district?: StringWithAggregatesFilter<"Invoices"> | string
    receiver_phone?: StringWithAggregatesFilter<"Invoices"> | string
    receiver_address?: StringWithAggregatesFilter<"Invoices"> | string
    receiver_name?: StringWithAggregatesFilter<"Invoices"> | string
    invoice_number?: StringWithAggregatesFilter<"Invoices"> | string
    cartsId?: StringWithAggregatesFilter<"Invoices"> | string
    userId?: StringWithAggregatesFilter<"Invoices"> | string
    paymentsId?: StringWithAggregatesFilter<"Invoices"> | string
  }

  export type Confirmation_paymentWhereInput = {
    AND?: Confirmation_paymentWhereInput | Confirmation_paymentWhereInput[]
    OR?: Confirmation_paymentWhereInput[]
    NOT?: Confirmation_paymentWhereInput | Confirmation_paymentWhereInput[]
    id?: StringFilter<"Confirmation_payment"> | string
    amount?: IntFilter<"Confirmation_payment"> | number
    bank?: StringFilter<"Confirmation_payment"> | string
    invoicesId?: StringFilter<"Confirmation_payment"> | string
    invoice_id?: XOR<InvoicesScalarRelationFilter, InvoicesWhereInput>
  }

  export type Confirmation_paymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    bank?: SortOrder
    invoicesId?: SortOrder
    invoice_id?: InvoicesOrderByWithRelationInput
  }

  export type Confirmation_paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Confirmation_paymentWhereInput | Confirmation_paymentWhereInput[]
    OR?: Confirmation_paymentWhereInput[]
    NOT?: Confirmation_paymentWhereInput | Confirmation_paymentWhereInput[]
    amount?: IntFilter<"Confirmation_payment"> | number
    bank?: StringFilter<"Confirmation_payment"> | string
    invoicesId?: StringFilter<"Confirmation_payment"> | string
    invoice_id?: XOR<InvoicesScalarRelationFilter, InvoicesWhereInput>
  }, "id" | "id">

  export type Confirmation_paymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    bank?: SortOrder
    invoicesId?: SortOrder
    _count?: Confirmation_paymentCountOrderByAggregateInput
    _avg?: Confirmation_paymentAvgOrderByAggregateInput
    _max?: Confirmation_paymentMaxOrderByAggregateInput
    _min?: Confirmation_paymentMinOrderByAggregateInput
    _sum?: Confirmation_paymentSumOrderByAggregateInput
  }

  export type Confirmation_paymentScalarWhereWithAggregatesInput = {
    AND?: Confirmation_paymentScalarWhereWithAggregatesInput | Confirmation_paymentScalarWhereWithAggregatesInput[]
    OR?: Confirmation_paymentScalarWhereWithAggregatesInput[]
    NOT?: Confirmation_paymentScalarWhereWithAggregatesInput | Confirmation_paymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Confirmation_payment"> | string
    amount?: IntWithAggregatesFilter<"Confirmation_payment"> | number
    bank?: StringWithAggregatesFilter<"Confirmation_payment"> | string
    invoicesId?: StringWithAggregatesFilter<"Confirmation_payment"> | string
  }

  export type Invoice_historiesWhereInput = {
    AND?: Invoice_historiesWhereInput | Invoice_historiesWhereInput[]
    OR?: Invoice_historiesWhereInput[]
    NOT?: Invoice_historiesWhereInput | Invoice_historiesWhereInput[]
    id?: StringFilter<"Invoice_histories"> | string
    status?: BoolFilter<"Invoice_histories"> | boolean
    created_at?: DateTimeNullableFilter<"Invoice_histories"> | Date | string | null
    invoicesId?: StringFilter<"Invoice_histories"> | string
    invoice_id?: XOR<InvoicesScalarRelationFilter, InvoicesWhereInput>
  }

  export type Invoice_historiesOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    invoicesId?: SortOrder
    invoice_id?: InvoicesOrderByWithRelationInput
  }

  export type Invoice_historiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Invoice_historiesWhereInput | Invoice_historiesWhereInput[]
    OR?: Invoice_historiesWhereInput[]
    NOT?: Invoice_historiesWhereInput | Invoice_historiesWhereInput[]
    status?: BoolFilter<"Invoice_histories"> | boolean
    created_at?: DateTimeNullableFilter<"Invoice_histories"> | Date | string | null
    invoicesId?: StringFilter<"Invoice_histories"> | string
    invoice_id?: XOR<InvoicesScalarRelationFilter, InvoicesWhereInput>
  }, "id" | "id">

  export type Invoice_historiesOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    invoicesId?: SortOrder
    _count?: Invoice_historiesCountOrderByAggregateInput
    _max?: Invoice_historiesMaxOrderByAggregateInput
    _min?: Invoice_historiesMinOrderByAggregateInput
  }

  export type Invoice_historiesScalarWhereWithAggregatesInput = {
    AND?: Invoice_historiesScalarWhereWithAggregatesInput | Invoice_historiesScalarWhereWithAggregatesInput[]
    OR?: Invoice_historiesScalarWhereWithAggregatesInput[]
    NOT?: Invoice_historiesScalarWhereWithAggregatesInput | Invoice_historiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice_histories"> | string
    status?: BoolWithAggregatesFilter<"Invoice_histories"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"Invoice_histories"> | Date | string | null
    invoicesId?: StringWithAggregatesFilter<"Invoice_histories"> | string
  }

  export type PaymentsWhereInput = {
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    id?: StringFilter<"Payments"> | string
    bank?: StringFilter<"Payments"> | string
    amount?: IntFilter<"Payments"> | number
    status?: BoolFilter<"Payments"> | boolean
    moota_transaction_id?: StringNullableFilter<"Payments"> | string | null
    userId?: StringFilter<"Payments"> | string
    invoicesId?: StringFilter<"Payments"> | string
    invoice_id?: XOR<InvoicesNullableScalarRelationFilter, InvoicesWhereInput> | null
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentsOrderByWithRelationInput = {
    id?: SortOrder
    bank?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    moota_transaction_id?: SortOrderInput | SortOrder
    userId?: SortOrder
    invoicesId?: SortOrder
    invoice_id?: InvoicesOrderByWithRelationInput
    user_id?: UserOrderByWithRelationInput
  }

  export type PaymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoicesId?: string
    AND?: PaymentsWhereInput | PaymentsWhereInput[]
    OR?: PaymentsWhereInput[]
    NOT?: PaymentsWhereInput | PaymentsWhereInput[]
    bank?: StringFilter<"Payments"> | string
    amount?: IntFilter<"Payments"> | number
    status?: BoolFilter<"Payments"> | boolean
    moota_transaction_id?: StringNullableFilter<"Payments"> | string | null
    userId?: StringFilter<"Payments"> | string
    invoice_id?: XOR<InvoicesNullableScalarRelationFilter, InvoicesWhereInput> | null
    user_id?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "id" | "invoicesId">

  export type PaymentsOrderByWithAggregationInput = {
    id?: SortOrder
    bank?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    moota_transaction_id?: SortOrderInput | SortOrder
    userId?: SortOrder
    invoicesId?: SortOrder
    _count?: PaymentsCountOrderByAggregateInput
    _avg?: PaymentsAvgOrderByAggregateInput
    _max?: PaymentsMaxOrderByAggregateInput
    _min?: PaymentsMinOrderByAggregateInput
    _sum?: PaymentsSumOrderByAggregateInput
  }

  export type PaymentsScalarWhereWithAggregatesInput = {
    AND?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    OR?: PaymentsScalarWhereWithAggregatesInput[]
    NOT?: PaymentsScalarWhereWithAggregatesInput | PaymentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payments"> | string
    bank?: StringWithAggregatesFilter<"Payments"> | string
    amount?: IntWithAggregatesFilter<"Payments"> | number
    status?: BoolWithAggregatesFilter<"Payments"> | boolean
    moota_transaction_id?: StringNullableWithAggregatesFilter<"Payments"> | string | null
    userId?: StringWithAggregatesFilter<"Payments"> | string
    invoicesId?: StringWithAggregatesFilter<"Payments"> | string
  }

  export type CouriersWhereInput = {
    AND?: CouriersWhereInput | CouriersWhereInput[]
    OR?: CouriersWhereInput[]
    NOT?: CouriersWhereInput | CouriersWhereInput[]
    id?: StringFilter<"Couriers"> | string
    courier_code?: StringFilter<"Couriers"> | string
    courier_service_name?: StringFilter<"Couriers"> | string
    courier_service_code?: StringFilter<"Couriers"> | string
    price?: IntFilter<"Couriers"> | number
    order_id?: StringFilter<"Couriers"> | string
    invoicesId?: StringFilter<"Couriers"> | string
    invoice_id?: XOR<InvoicesScalarRelationFilter, InvoicesWhereInput>
  }

  export type CouriersOrderByWithRelationInput = {
    id?: SortOrder
    courier_code?: SortOrder
    courier_service_name?: SortOrder
    courier_service_code?: SortOrder
    price?: SortOrder
    order_id?: SortOrder
    invoicesId?: SortOrder
    invoice_id?: InvoicesOrderByWithRelationInput
  }

  export type CouriersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoicesId?: string
    AND?: CouriersWhereInput | CouriersWhereInput[]
    OR?: CouriersWhereInput[]
    NOT?: CouriersWhereInput | CouriersWhereInput[]
    courier_code?: StringFilter<"Couriers"> | string
    courier_service_name?: StringFilter<"Couriers"> | string
    courier_service_code?: StringFilter<"Couriers"> | string
    price?: IntFilter<"Couriers"> | number
    order_id?: StringFilter<"Couriers"> | string
    invoice_id?: XOR<InvoicesScalarRelationFilter, InvoicesWhereInput>
  }, "id" | "id" | "invoicesId">

  export type CouriersOrderByWithAggregationInput = {
    id?: SortOrder
    courier_code?: SortOrder
    courier_service_name?: SortOrder
    courier_service_code?: SortOrder
    price?: SortOrder
    order_id?: SortOrder
    invoicesId?: SortOrder
    _count?: CouriersCountOrderByAggregateInput
    _avg?: CouriersAvgOrderByAggregateInput
    _max?: CouriersMaxOrderByAggregateInput
    _min?: CouriersMinOrderByAggregateInput
    _sum?: CouriersSumOrderByAggregateInput
  }

  export type CouriersScalarWhereWithAggregatesInput = {
    AND?: CouriersScalarWhereWithAggregatesInput | CouriersScalarWhereWithAggregatesInput[]
    OR?: CouriersScalarWhereWithAggregatesInput[]
    NOT?: CouriersScalarWhereWithAggregatesInput | CouriersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Couriers"> | string
    courier_code?: StringWithAggregatesFilter<"Couriers"> | string
    courier_service_name?: StringWithAggregatesFilter<"Couriers"> | string
    courier_service_code?: StringWithAggregatesFilter<"Couriers"> | string
    price?: IntWithAggregatesFilter<"Couriers"> | number
    order_id?: StringWithAggregatesFilter<"Couriers"> | string
    invoicesId?: StringWithAggregatesFilter<"Couriers"> | string
  }

  export type DecorationWhereInput = {
    AND?: DecorationWhereInput | DecorationWhereInput[]
    OR?: DecorationWhereInput[]
    NOT?: DecorationWhereInput | DecorationWhereInput[]
    id?: StringFilter<"Decoration"> | string
    type?: StringFilter<"Decoration"> | string
  }

  export type DecorationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type DecorationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DecorationWhereInput | DecorationWhereInput[]
    OR?: DecorationWhereInput[]
    NOT?: DecorationWhereInput | DecorationWhereInput[]
    type?: StringFilter<"Decoration"> | string
  }, "id" | "id">

  export type DecorationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: DecorationCountOrderByAggregateInput
    _max?: DecorationMaxOrderByAggregateInput
    _min?: DecorationMinOrderByAggregateInput
  }

  export type DecorationScalarWhereWithAggregatesInput = {
    AND?: DecorationScalarWhereWithAggregatesInput | DecorationScalarWhereWithAggregatesInput[]
    OR?: DecorationScalarWhereWithAggregatesInput[]
    NOT?: DecorationScalarWhereWithAggregatesInput | DecorationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Decoration"> | string
    type?: StringWithAggregatesFilter<"Decoration"> | string
  }

  export type Stores_on_decorationsWhereInput = {
    AND?: Stores_on_decorationsWhereInput | Stores_on_decorationsWhereInput[]
    OR?: Stores_on_decorationsWhereInput[]
    NOT?: Stores_on_decorationsWhereInput | Stores_on_decorationsWhereInput[]
    id?: StringFilter<"Stores_on_decorations"> | string
    storesId?: StringFilter<"Stores_on_decorations"> | string
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }

  export type Stores_on_decorationsOrderByWithRelationInput = {
    id?: SortOrder
    storesId?: SortOrder
    store_id?: StoresOrderByWithRelationInput
  }

  export type Stores_on_decorationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Stores_on_decorationsWhereInput | Stores_on_decorationsWhereInput[]
    OR?: Stores_on_decorationsWhereInput[]
    NOT?: Stores_on_decorationsWhereInput | Stores_on_decorationsWhereInput[]
    storesId?: StringFilter<"Stores_on_decorations"> | string
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }, "id" | "id">

  export type Stores_on_decorationsOrderByWithAggregationInput = {
    id?: SortOrder
    storesId?: SortOrder
    _count?: Stores_on_decorationsCountOrderByAggregateInput
    _max?: Stores_on_decorationsMaxOrderByAggregateInput
    _min?: Stores_on_decorationsMinOrderByAggregateInput
  }

  export type Stores_on_decorationsScalarWhereWithAggregatesInput = {
    AND?: Stores_on_decorationsScalarWhereWithAggregatesInput | Stores_on_decorationsScalarWhereWithAggregatesInput[]
    OR?: Stores_on_decorationsScalarWhereWithAggregatesInput[]
    NOT?: Stores_on_decorationsScalarWhereWithAggregatesInput | Stores_on_decorationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stores_on_decorations"> | string
    storesId?: StringWithAggregatesFilter<"Stores_on_decorations"> | string
  }

  export type Operation_hoursWhereInput = {
    AND?: Operation_hoursWhereInput | Operation_hoursWhereInput[]
    OR?: Operation_hoursWhereInput[]
    NOT?: Operation_hoursWhereInput | Operation_hoursWhereInput[]
    id?: StringFilter<"Operation_hours"> | string
    day?: StringFilter<"Operation_hours"> | string
    open_at?: StringFilter<"Operation_hours"> | string
    close_at?: StringFilter<"Operation_hours"> | string
    is_off?: BoolFilter<"Operation_hours"> | boolean
    storesId?: StringFilter<"Operation_hours"> | string
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }

  export type Operation_hoursOrderByWithRelationInput = {
    id?: SortOrder
    day?: SortOrder
    open_at?: SortOrder
    close_at?: SortOrder
    is_off?: SortOrder
    storesId?: SortOrder
    store_id?: StoresOrderByWithRelationInput
  }

  export type Operation_hoursWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Operation_hoursWhereInput | Operation_hoursWhereInput[]
    OR?: Operation_hoursWhereInput[]
    NOT?: Operation_hoursWhereInput | Operation_hoursWhereInput[]
    day?: StringFilter<"Operation_hours"> | string
    open_at?: StringFilter<"Operation_hours"> | string
    close_at?: StringFilter<"Operation_hours"> | string
    is_off?: BoolFilter<"Operation_hours"> | boolean
    storesId?: StringFilter<"Operation_hours"> | string
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }, "id" | "id">

  export type Operation_hoursOrderByWithAggregationInput = {
    id?: SortOrder
    day?: SortOrder
    open_at?: SortOrder
    close_at?: SortOrder
    is_off?: SortOrder
    storesId?: SortOrder
    _count?: Operation_hoursCountOrderByAggregateInput
    _max?: Operation_hoursMaxOrderByAggregateInput
    _min?: Operation_hoursMinOrderByAggregateInput
  }

  export type Operation_hoursScalarWhereWithAggregatesInput = {
    AND?: Operation_hoursScalarWhereWithAggregatesInput | Operation_hoursScalarWhereWithAggregatesInput[]
    OR?: Operation_hoursScalarWhereWithAggregatesInput[]
    NOT?: Operation_hoursScalarWhereWithAggregatesInput | Operation_hoursScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Operation_hours"> | string
    day?: StringWithAggregatesFilter<"Operation_hours"> | string
    open_at?: StringWithAggregatesFilter<"Operation_hours"> | string
    close_at?: StringWithAggregatesFilter<"Operation_hours"> | string
    is_off?: BoolWithAggregatesFilter<"Operation_hours"> | boolean
    storesId?: StringWithAggregatesFilter<"Operation_hours"> | string
  }

  export type Message_templatesWhereInput = {
    AND?: Message_templatesWhereInput | Message_templatesWhereInput[]
    OR?: Message_templatesWhereInput[]
    NOT?: Message_templatesWhereInput | Message_templatesWhereInput[]
    id?: StringFilter<"Message_templates"> | string
    name?: StringFilter<"Message_templates"> | string
    content?: StringFilter<"Message_templates"> | string
    storesId?: StringFilter<"Message_templates"> | string
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }

  export type Message_templatesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    storesId?: SortOrder
    store_id?: StoresOrderByWithRelationInput
  }

  export type Message_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Message_templatesWhereInput | Message_templatesWhereInput[]
    OR?: Message_templatesWhereInput[]
    NOT?: Message_templatesWhereInput | Message_templatesWhereInput[]
    name?: StringFilter<"Message_templates"> | string
    content?: StringFilter<"Message_templates"> | string
    storesId?: StringFilter<"Message_templates"> | string
    store_id?: XOR<StoresScalarRelationFilter, StoresWhereInput>
  }, "id" | "id">

  export type Message_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    storesId?: SortOrder
    _count?: Message_templatesCountOrderByAggregateInput
    _max?: Message_templatesMaxOrderByAggregateInput
    _min?: Message_templatesMinOrderByAggregateInput
  }

  export type Message_templatesScalarWhereWithAggregatesInput = {
    AND?: Message_templatesScalarWhereWithAggregatesInput | Message_templatesScalarWhereWithAggregatesInput[]
    OR?: Message_templatesScalarWhereWithAggregatesInput[]
    NOT?: Message_templatesScalarWhereWithAggregatesInput | Message_templatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message_templates"> | string
    name?: StringWithAggregatesFilter<"Message_templates"> | string
    content?: StringWithAggregatesFilter<"Message_templates"> | string
    storesId?: StringWithAggregatesFilter<"Message_templates"> | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profile_id?: ProfilesCreateNestedOneWithoutUserInput
    role_id?: RolesCreateNestedOneWithoutUserInput
    Carts?: CartsCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    rolesId?: string | null
    Carts?: CartsUncheckedCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutUserNestedInput
    role_id?: RolesUpdateOneWithoutUserNestedInput
    Carts?: CartsUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
    Carts?: CartsUncheckedUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    rolesId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfilesCreateInput = {
    id?: string
    user_id?: string | null
    locations: LocationCreateNestedOneWithoutProfile_idInput
    User?: UserCreateNestedManyWithoutProfile_idInput
  }

  export type ProfilesUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    locationId: string
    User?: UserUncheckedCreateNestedManyWithoutProfile_idInput
  }

  export type ProfilesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUpdateOneRequiredWithoutProfile_idNestedInput
    User?: UserUpdateManyWithoutProfile_idNestedInput
  }

  export type ProfilesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutProfile_idNestedInput
  }

  export type ProfilesCreateManyInput = {
    id?: string
    user_id?: string | null
    locationId: string
  }

  export type ProfilesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfilesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type RolesCreateInput = {
    id?: string
    name?: string | null
    User?: UserCreateNestedManyWithoutRole_idInput
  }

  export type RolesUncheckedCreateInput = {
    id?: string
    name?: string | null
    User?: UserUncheckedCreateNestedManyWithoutRole_idInput
  }

  export type RolesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateManyWithoutRole_idNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUncheckedUpdateManyWithoutRole_idNestedInput
  }

  export type RolesCreateManyInput = {
    id?: string
    name?: string | null
  }

  export type RolesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    variants?: VariantsCreateNestedOneWithoutProduct_idInput
    store_id?: StoresCreateNestedOneWithoutProductInput
    Categories?: CategoriesCreateNestedManyWithoutProduct_idInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    storesId?: string | null
    variants?: VariantsUncheckedCreateNestedOneWithoutProduct_idInput
    Categories?: CategoriesUncheckedCreateNestedManyWithoutProduct_idInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: VariantsUpdateOneWithoutProduct_idNestedInput
    store_id?: StoresUpdateOneWithoutProductNestedInput
    Categories?: CategoriesUpdateManyWithoutProduct_idNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: VariantsUncheckedUpdateOneWithoutProduct_idNestedInput
    Categories?: CategoriesUncheckedUpdateManyWithoutProduct_idNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    storesId?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoresCreateInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type StoresCreateManyInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
  }

  export type StoresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bank_accountsCreateInput = {
    id?: string
    bank: string
    acc_number: string
    acc_name: string
    store_id?: StoresCreateNestedOneWithoutBank_accountsInput
  }

  export type bank_accountsUncheckedCreateInput = {
    id?: string
    bank: string
    acc_number: string
    acc_name: string
    storesId?: string | null
  }

  export type bank_accountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
    store_id?: StoresUpdateOneWithoutBank_accountsNestedInput
  }

  export type bank_accountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bank_accountsCreateManyInput = {
    id?: string
    bank: string
    acc_number: string
    acc_name: string
    storesId?: string | null
  }

  export type bank_accountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
  }

  export type bank_accountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    store_id?: StoresCreateNestedOneWithoutLocationInput
    profile_id?: ProfilesCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    storesId?: string | null
    profile_id?: ProfilesUncheckedCreateNestedOneWithoutLocationsInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    store_id?: StoresUpdateOneWithoutLocationNestedInput
    profile_id?: ProfilesUpdateOneWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
    profile_id?: ProfilesUncheckedUpdateOneWithoutLocationsNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    storesId?: string | null
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Variant_option_valuesCreateInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    variant_option_id: Variant_optionsCreateNestedOneWithoutVariant_option_valuesInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutVariant_option_value_idInput
  }

  export type Variant_option_valuesUncheckedCreateInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    variant_optionsId: string
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutVariant_option_value_idInput
  }

  export type Variant_option_valuesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    variant_option_id?: Variant_optionsUpdateOneRequiredWithoutVariant_option_valuesNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutVariant_option_value_idNestedInput
  }

  export type Variant_option_valuesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    variant_optionsId?: StringFieldUpdateOperationsInput | string
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutVariant_option_value_idNestedInput
  }

  export type Variant_option_valuesCreateManyInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    variant_optionsId: string
  }

  export type Variant_option_valuesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Variant_option_valuesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    variant_optionsId?: StringFieldUpdateOperationsInput | string
  }

  export type Variant_optionsCreateInput = {
    id?: string
    name: string
    variant_id: VariantsCreateNestedOneWithoutVariant_optionsInput
    Variant_option_values?: Variant_option_valuesCreateNestedManyWithoutVariant_option_idInput
  }

  export type Variant_optionsUncheckedCreateInput = {
    id?: string
    name: string
    variantsId: string
    Variant_option_values?: Variant_option_valuesUncheckedCreateNestedManyWithoutVariant_option_idInput
  }

  export type Variant_optionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    variant_id?: VariantsUpdateOneRequiredWithoutVariant_optionsNestedInput
    Variant_option_values?: Variant_option_valuesUpdateManyWithoutVariant_option_idNestedInput
  }

  export type Variant_optionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    variantsId?: StringFieldUpdateOperationsInput | string
    Variant_option_values?: Variant_option_valuesUncheckedUpdateManyWithoutVariant_option_idNestedInput
  }

  export type Variant_optionsCreateManyInput = {
    id?: string
    name: string
    variantsId: string
  }

  export type Variant_optionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type Variant_optionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    variantsId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantsCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    product_id: ProductCreateNestedOneWithoutVariantsInput
    Variant_options?: Variant_optionsCreateNestedManyWithoutVariant_idInput
  }

  export type VariantsUncheckedCreateInput = {
    id?: string
    name: string
    is_active?: boolean
    productId: string
    Variant_options?: Variant_optionsUncheckedCreateNestedManyWithoutVariant_idInput
  }

  export type VariantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    product_id?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    Variant_options?: Variant_optionsUpdateManyWithoutVariant_idNestedInput
  }

  export type VariantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    productId?: StringFieldUpdateOperationsInput | string
    Variant_options?: Variant_optionsUncheckedUpdateManyWithoutVariant_idNestedInput
  }

  export type VariantsCreateManyInput = {
    id?: string
    name: string
    is_active?: boolean
    productId: string
  }

  export type VariantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VariantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesCreateInput = {
    id?: string
    name: string
    product_id: ProductCreateNestedOneWithoutCategoriesInput
  }

  export type CategoriesUncheckedCreateInput = {
    id?: string
    name: string
    productId: string
  }

  export type CategoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    product_id?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CategoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesCreateManyInput = {
    id?: string
    name: string
    productId: string
  }

  export type CategoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type CartsCreateInput = {
    id?: string
    prices: number
    discount?: string | null
    user_id: UserCreateNestedOneWithoutCartsInput
    store_id: StoresCreateNestedOneWithoutCartsInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutCart_idInput
    Invoices?: InvoicesCreateNestedManyWithoutCart_idInput
  }

  export type CartsUncheckedCreateInput = {
    id?: string
    prices: number
    discount?: string | null
    userId: string
    storesId: string
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutCart_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCart_idInput
  }

  export type CartsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: UserUpdateOneRequiredWithoutCartsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCartsNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutCart_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutCart_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCart_idNestedInput
  }

  export type CartsCreateManyInput = {
    id?: string
    prices: number
    discount?: string | null
    userId: string
    storesId: string
  }

  export type CartsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsCreateInput = {
    id?: string
    qty: number
    price: number
    cart_id: CartsCreateNestedOneWithoutCart_itemsInput
    user_id: UserCreateNestedOneWithoutCart_itemsInput
    store_id: StoresCreateNestedOneWithoutCart_itemsInput
    variant_option_value_id: Variant_option_valuesCreateNestedOneWithoutCart_itemsInput
  }

  export type Cart_itemsUncheckedCreateInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    userId: string
    storesId: string
    variant_option_valuesId: string
  }

  export type Cart_itemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cart_id?: CartsUpdateOneRequiredWithoutCart_itemsNestedInput
    user_id?: UserUpdateOneRequiredWithoutCart_itemsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCart_itemsNestedInput
    variant_option_value_id?: Variant_option_valuesUpdateOneRequiredWithoutCart_itemsNestedInput
  }

  export type Cart_itemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsCreateManyInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    userId: string
    storesId: string
    variant_option_valuesId: string
  }

  export type Cart_itemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
  }

  export type Cart_itemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoicesCreateInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cart_id: CartsCreateNestedOneWithoutInvoicesInput
    user_id: UserCreateNestedOneWithoutInvoicesInput
    courier_id?: CouriersCreateNestedOneWithoutInvoice_idInput
    payment_id?: PaymentsCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    paymentsId: string
    courier_id?: CouriersUncheckedCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cart_id?: CartsUpdateOneRequiredWithoutInvoicesNestedInput
    user_id?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    courier_id?: CouriersUpdateOneWithoutInvoice_idNestedInput
    payment_id?: PaymentsUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
    courier_id?: CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesCreateManyInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    paymentsId: string
  }

  export type InvoicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
  }

  export type InvoicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentCreateInput = {
    id?: string
    amount: number
    bank: string
    invoice_id: InvoicesCreateNestedOneWithoutConfirmation_paymentInput
  }

  export type Confirmation_paymentUncheckedCreateInput = {
    id?: string
    amount: number
    bank: string
    invoicesId: string
  }

  export type Confirmation_paymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    invoice_id?: InvoicesUpdateOneRequiredWithoutConfirmation_paymentNestedInput
  }

  export type Confirmation_paymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentCreateManyInput = {
    id?: string
    amount: number
    bank: string
    invoicesId: string
  }

  export type Confirmation_paymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type Invoice_historiesCreateInput = {
    id?: string
    status?: boolean
    created_at?: Date | string | null
    invoice_id: InvoicesCreateNestedOneWithoutInvoice_historiesInput
  }

  export type Invoice_historiesUncheckedCreateInput = {
    id?: string
    status?: boolean
    created_at?: Date | string | null
    invoicesId: string
  }

  export type Invoice_historiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_id?: InvoicesUpdateOneRequiredWithoutInvoice_historiesNestedInput
  }

  export type Invoice_historiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type Invoice_historiesCreateManyInput = {
    id?: string
    status?: boolean
    created_at?: Date | string | null
    invoicesId: string
  }

  export type Invoice_historiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Invoice_historiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentsCreateInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    invoicesId: string
    invoice_id?: InvoicesCreateNestedOneWithoutPayment_idInput
    user_id: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    userId: string
    invoicesId: string
    invoice_id?: InvoicesUncheckedCreateNestedOneWithoutPayment_idInput
  }

  export type PaymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
    invoice_id?: InvoicesUpdateOneWithoutPayment_idNestedInput
    user_id?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
    invoice_id?: InvoicesUncheckedUpdateOneWithoutPayment_idNestedInput
  }

  export type PaymentsCreateManyInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    userId: string
    invoicesId: string
  }

  export type PaymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type CouriersCreateInput = {
    id?: string
    courier_code: string
    courier_service_name: string
    courier_service_code: string
    price: number
    order_id: string
    invoice_id: InvoicesCreateNestedOneWithoutCourier_idInput
  }

  export type CouriersUncheckedCreateInput = {
    id?: string
    courier_code: string
    courier_service_name: string
    courier_service_code: string
    price: number
    order_id: string
    invoicesId: string
  }

  export type CouriersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier_code?: StringFieldUpdateOperationsInput | string
    courier_service_name?: StringFieldUpdateOperationsInput | string
    courier_service_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    invoice_id?: InvoicesUpdateOneRequiredWithoutCourier_idNestedInput
  }

  export type CouriersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier_code?: StringFieldUpdateOperationsInput | string
    courier_service_name?: StringFieldUpdateOperationsInput | string
    courier_service_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type CouriersCreateManyInput = {
    id?: string
    courier_code: string
    courier_service_name: string
    courier_service_code: string
    price: number
    order_id: string
    invoicesId: string
  }

  export type CouriersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier_code?: StringFieldUpdateOperationsInput | string
    courier_service_name?: StringFieldUpdateOperationsInput | string
    courier_service_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type CouriersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier_code?: StringFieldUpdateOperationsInput | string
    courier_service_name?: StringFieldUpdateOperationsInput | string
    courier_service_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type DecorationCreateInput = {
    id?: string
    type: string
  }

  export type DecorationUncheckedCreateInput = {
    id?: string
    type: string
  }

  export type DecorationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DecorationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DecorationCreateManyInput = {
    id?: string
    type: string
  }

  export type DecorationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DecorationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type Stores_on_decorationsCreateInput = {
    id?: string
    store_id: StoresCreateNestedOneWithoutStores_on_decorationsInput
  }

  export type Stores_on_decorationsUncheckedCreateInput = {
    id?: string
    storesId: string
  }

  export type Stores_on_decorationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    store_id?: StoresUpdateOneRequiredWithoutStores_on_decorationsNestedInput
  }

  export type Stores_on_decorationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Stores_on_decorationsCreateManyInput = {
    id?: string
    storesId: string
  }

  export type Stores_on_decorationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type Stores_on_decorationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Operation_hoursCreateInput = {
    id?: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
    store_id: StoresCreateNestedOneWithoutOperation_hoursInput
  }

  export type Operation_hoursUncheckedCreateInput = {
    id?: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
    storesId: string
  }

  export type Operation_hoursUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
    store_id?: StoresUpdateOneRequiredWithoutOperation_hoursNestedInput
  }

  export type Operation_hoursUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Operation_hoursCreateManyInput = {
    id?: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
    storesId: string
  }

  export type Operation_hoursUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Operation_hoursUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Message_templatesCreateInput = {
    id?: string
    name: string
    content: string
    store_id: StoresCreateNestedOneWithoutMessage_templatesInput
  }

  export type Message_templatesUncheckedCreateInput = {
    id?: string
    name: string
    content: string
    storesId: string
  }

  export type Message_templatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    store_id?: StoresUpdateOneRequiredWithoutMessage_templatesNestedInput
  }

  export type Message_templatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Message_templatesCreateManyInput = {
    id?: string
    name: string
    content: string
    storesId: string
  }

  export type Message_templatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type Message_templatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ProfilesNullableScalarRelationFilter = {
    is?: ProfilesWhereInput | null
    isNot?: ProfilesWhereInput | null
  }

  export type RolesNullableScalarRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type CartsListRelationFilter = {
    every?: CartsWhereInput
    some?: CartsWhereInput
    none?: CartsWhereInput
  }

  export type Cart_itemsListRelationFilter = {
    every?: Cart_itemsWhereInput
    some?: Cart_itemsWhereInput
    none?: Cart_itemsWhereInput
  }

  export type InvoicesListRelationFilter = {
    every?: InvoicesWhereInput
    some?: InvoicesWhereInput
    none?: InvoicesWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: PaymentsWhereInput
    some?: PaymentsWhereInput
    none?: PaymentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CartsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Cart_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    fullname?: SortOrder
    password?: SortOrder
    profilesId?: SortOrder
    rolesId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    fullname?: SortOrder
    password?: SortOrder
    profilesId?: SortOrder
    rolesId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    fullname?: SortOrder
    password?: SortOrder
    profilesId?: SortOrder
    rolesId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfilesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    locationId?: SortOrder
  }

  export type ProfilesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    locationId?: SortOrder
  }

  export type ProfilesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    locationId?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VariantsNullableScalarRelationFilter = {
    is?: VariantsWhereInput | null
    isNot?: VariantsWhereInput | null
  }

  export type StoresNullableScalarRelationFilter = {
    is?: StoresWhereInput | null
    isNot?: StoresWhereInput | null
  }

  export type CategoriesListRelationFilter = {
    every?: CategoriesWhereInput
    some?: CategoriesWhereInput
    none?: CategoriesWhereInput
  }

  export type CategoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attachments?: SortOrder
    is_active?: SortOrder
    size?: SortOrder
    minimum_order?: SortOrder
    storesId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    minimum_order?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attachments?: SortOrder
    is_active?: SortOrder
    size?: SortOrder
    minimum_order?: SortOrder
    storesId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attachments?: SortOrder
    is_active?: SortOrder
    size?: SortOrder
    minimum_order?: SortOrder
    storesId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    minimum_order?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type Bank_accountsListRelationFilter = {
    every?: bank_accountsWhereInput
    some?: bank_accountsWhereInput
    none?: bank_accountsWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type Stores_on_decorationsListRelationFilter = {
    every?: Stores_on_decorationsWhereInput
    some?: Stores_on_decorationsWhereInput
    none?: Stores_on_decorationsWhereInput
  }

  export type Operation_hoursListRelationFilter = {
    every?: Operation_hoursWhereInput
    some?: Operation_hoursWhereInput
    none?: Operation_hoursWhereInput
  }

  export type Message_templatesListRelationFilter = {
    every?: Message_templatesWhereInput
    some?: Message_templatesWhereInput
    none?: Message_templatesWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bank_accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Stores_on_decorationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Operation_hoursOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Message_templatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoresCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slogan?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    logo_attachment?: SortOrder
    banner_attachment?: SortOrder
  }

  export type StoresMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slogan?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    logo_attachment?: SortOrder
    banner_attachment?: SortOrder
  }

  export type StoresMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slogan?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    logo_attachment?: SortOrder
    banner_attachment?: SortOrder
  }

  export type bank_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    bank?: SortOrder
    acc_number?: SortOrder
    acc_name?: SortOrder
    storesId?: SortOrder
  }

  export type bank_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    bank?: SortOrder
    acc_number?: SortOrder
    acc_name?: SortOrder
    storesId?: SortOrder
  }

  export type bank_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    bank?: SortOrder
    acc_number?: SortOrder
    acc_name?: SortOrder
    storesId?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postal_code?: SortOrder
    city_district?: SortOrder
    is_main_location?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    storesId?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postal_code?: SortOrder
    city_district?: SortOrder
    is_main_location?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    storesId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    postal_code?: SortOrder
    city_district?: SortOrder
    is_main_location?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    storesId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Variant_optionsScalarRelationFilter = {
    is?: Variant_optionsWhereInput
    isNot?: Variant_optionsWhereInput
  }

  export type Variant_option_valuesCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    variant_optionsId?: SortOrder
  }

  export type Variant_option_valuesAvgOrderByAggregateInput = {
    stock?: SortOrder
    price?: SortOrder
  }

  export type Variant_option_valuesMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    variant_optionsId?: SortOrder
  }

  export type Variant_option_valuesMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    variant_optionsId?: SortOrder
  }

  export type Variant_option_valuesSumOrderByAggregateInput = {
    stock?: SortOrder
    price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type VariantsScalarRelationFilter = {
    is?: VariantsWhereInput
    isNot?: VariantsWhereInput
  }

  export type Variant_option_valuesListRelationFilter = {
    every?: Variant_option_valuesWhereInput
    some?: Variant_option_valuesWhereInput
    none?: Variant_option_valuesWhereInput
  }

  export type Variant_option_valuesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Variant_optionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    variantsId?: SortOrder
  }

  export type Variant_optionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    variantsId?: SortOrder
  }

  export type Variant_optionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    variantsId?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type Variant_optionsListRelationFilter = {
    every?: Variant_optionsWhereInput
    some?: Variant_optionsWhereInput
    none?: Variant_optionsWhereInput
  }

  export type Variant_optionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariantsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    productId?: SortOrder
  }

  export type VariantsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    productId?: SortOrder
  }

  export type VariantsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_active?: SortOrder
    productId?: SortOrder
  }

  export type CategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type CategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type CategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    productId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StoresScalarRelationFilter = {
    is?: StoresWhereInput
    isNot?: StoresWhereInput
  }

  export type CartsCountOrderByAggregateInput = {
    id?: SortOrder
    prices?: SortOrder
    discount?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
  }

  export type CartsAvgOrderByAggregateInput = {
    prices?: SortOrder
  }

  export type CartsMaxOrderByAggregateInput = {
    id?: SortOrder
    prices?: SortOrder
    discount?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
  }

  export type CartsMinOrderByAggregateInput = {
    id?: SortOrder
    prices?: SortOrder
    discount?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
  }

  export type CartsSumOrderByAggregateInput = {
    prices?: SortOrder
  }

  export type CartsScalarRelationFilter = {
    is?: CartsWhereInput
    isNot?: CartsWhereInput
  }

  export type Variant_option_valuesScalarRelationFilter = {
    is?: Variant_option_valuesWhereInput
    isNot?: Variant_option_valuesWhereInput
  }

  export type Cart_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    variant_option_valuesId?: SortOrder
  }

  export type Cart_itemsAvgOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
  }

  export type Cart_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    variant_option_valuesId?: SortOrder
  }

  export type Cart_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    storesId?: SortOrder
    variant_option_valuesId?: SortOrder
  }

  export type Cart_itemsSumOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
  }

  export type CouriersNullableScalarRelationFilter = {
    is?: CouriersWhereInput | null
    isNot?: CouriersWhereInput | null
  }

  export type PaymentsNullableScalarRelationFilter = {
    is?: PaymentsWhereInput | null
    isNot?: PaymentsWhereInput | null
  }

  export type Confirmation_paymentListRelationFilter = {
    every?: Confirmation_paymentWhereInput
    some?: Confirmation_paymentWhereInput
    none?: Confirmation_paymentWhereInput
  }

  export type Invoice_historiesListRelationFilter = {
    every?: Invoice_historiesWhereInput
    some?: Invoice_historiesWhereInput
    none?: Invoice_historiesWhereInput
  }

  export type Confirmation_paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Invoice_historiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicesCountOrderByAggregateInput = {
    id?: SortOrder
    prices?: SortOrder
    status?: SortOrder
    receiver_longitude?: SortOrder
    receiver_latitude?: SortOrder
    receiver_district?: SortOrder
    receiver_phone?: SortOrder
    receiver_address?: SortOrder
    receiver_name?: SortOrder
    invoice_number?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    paymentsId?: SortOrder
  }

  export type InvoicesAvgOrderByAggregateInput = {
    prices?: SortOrder
  }

  export type InvoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    prices?: SortOrder
    status?: SortOrder
    receiver_longitude?: SortOrder
    receiver_latitude?: SortOrder
    receiver_district?: SortOrder
    receiver_phone?: SortOrder
    receiver_address?: SortOrder
    receiver_name?: SortOrder
    invoice_number?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    paymentsId?: SortOrder
  }

  export type InvoicesMinOrderByAggregateInput = {
    id?: SortOrder
    prices?: SortOrder
    status?: SortOrder
    receiver_longitude?: SortOrder
    receiver_latitude?: SortOrder
    receiver_district?: SortOrder
    receiver_phone?: SortOrder
    receiver_address?: SortOrder
    receiver_name?: SortOrder
    invoice_number?: SortOrder
    cartsId?: SortOrder
    userId?: SortOrder
    paymentsId?: SortOrder
  }

  export type InvoicesSumOrderByAggregateInput = {
    prices?: SortOrder
  }

  export type InvoicesScalarRelationFilter = {
    is?: InvoicesWhereInput
    isNot?: InvoicesWhereInput
  }

  export type Confirmation_paymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    bank?: SortOrder
    invoicesId?: SortOrder
  }

  export type Confirmation_paymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Confirmation_paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    bank?: SortOrder
    invoicesId?: SortOrder
  }

  export type Confirmation_paymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    bank?: SortOrder
    invoicesId?: SortOrder
  }

  export type Confirmation_paymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Invoice_historiesCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    invoicesId?: SortOrder
  }

  export type Invoice_historiesMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    invoicesId?: SortOrder
  }

  export type Invoice_historiesMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    invoicesId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type InvoicesNullableScalarRelationFilter = {
    is?: InvoicesWhereInput | null
    isNot?: InvoicesWhereInput | null
  }

  export type PaymentsCountOrderByAggregateInput = {
    id?: SortOrder
    bank?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    moota_transaction_id?: SortOrder
    userId?: SortOrder
    invoicesId?: SortOrder
  }

  export type PaymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    bank?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    moota_transaction_id?: SortOrder
    userId?: SortOrder
    invoicesId?: SortOrder
  }

  export type PaymentsMinOrderByAggregateInput = {
    id?: SortOrder
    bank?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    moota_transaction_id?: SortOrder
    userId?: SortOrder
    invoicesId?: SortOrder
  }

  export type PaymentsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CouriersCountOrderByAggregateInput = {
    id?: SortOrder
    courier_code?: SortOrder
    courier_service_name?: SortOrder
    courier_service_code?: SortOrder
    price?: SortOrder
    order_id?: SortOrder
    invoicesId?: SortOrder
  }

  export type CouriersAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CouriersMaxOrderByAggregateInput = {
    id?: SortOrder
    courier_code?: SortOrder
    courier_service_name?: SortOrder
    courier_service_code?: SortOrder
    price?: SortOrder
    order_id?: SortOrder
    invoicesId?: SortOrder
  }

  export type CouriersMinOrderByAggregateInput = {
    id?: SortOrder
    courier_code?: SortOrder
    courier_service_name?: SortOrder
    courier_service_code?: SortOrder
    price?: SortOrder
    order_id?: SortOrder
    invoicesId?: SortOrder
  }

  export type CouriersSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DecorationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type DecorationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type DecorationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type Stores_on_decorationsCountOrderByAggregateInput = {
    id?: SortOrder
    storesId?: SortOrder
  }

  export type Stores_on_decorationsMaxOrderByAggregateInput = {
    id?: SortOrder
    storesId?: SortOrder
  }

  export type Stores_on_decorationsMinOrderByAggregateInput = {
    id?: SortOrder
    storesId?: SortOrder
  }

  export type Operation_hoursCountOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    open_at?: SortOrder
    close_at?: SortOrder
    is_off?: SortOrder
    storesId?: SortOrder
  }

  export type Operation_hoursMaxOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    open_at?: SortOrder
    close_at?: SortOrder
    is_off?: SortOrder
    storesId?: SortOrder
  }

  export type Operation_hoursMinOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    open_at?: SortOrder
    close_at?: SortOrder
    is_off?: SortOrder
    storesId?: SortOrder
  }

  export type Message_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    storesId?: SortOrder
  }

  export type Message_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    storesId?: SortOrder
  }

  export type Message_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    storesId?: SortOrder
  }

  export type ProfilesCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfilesCreateWithoutUserInput, ProfilesUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfilesCreateOrConnectWithoutUserInput
    connect?: ProfilesWhereUniqueInput
  }

  export type RolesCreateNestedOneWithoutUserInput = {
    create?: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserInput
    connect?: RolesWhereUniqueInput
  }

  export type CartsCreateNestedManyWithoutUser_idInput = {
    create?: XOR<CartsCreateWithoutUser_idInput, CartsUncheckedCreateWithoutUser_idInput> | CartsCreateWithoutUser_idInput[] | CartsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutUser_idInput | CartsCreateOrConnectWithoutUser_idInput[]
    createMany?: CartsCreateManyUser_idInputEnvelope
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
  }

  export type Cart_itemsCreateNestedManyWithoutUser_idInput = {
    create?: XOR<Cart_itemsCreateWithoutUser_idInput, Cart_itemsUncheckedCreateWithoutUser_idInput> | Cart_itemsCreateWithoutUser_idInput[] | Cart_itemsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutUser_idInput | Cart_itemsCreateOrConnectWithoutUser_idInput[]
    createMany?: Cart_itemsCreateManyUser_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type InvoicesCreateNestedManyWithoutUser_idInput = {
    create?: XOR<InvoicesCreateWithoutUser_idInput, InvoicesUncheckedCreateWithoutUser_idInput> | InvoicesCreateWithoutUser_idInput[] | InvoicesUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutUser_idInput | InvoicesCreateOrConnectWithoutUser_idInput[]
    createMany?: InvoicesCreateManyUser_idInputEnvelope
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
  }

  export type PaymentsCreateNestedManyWithoutUser_idInput = {
    create?: XOR<PaymentsCreateWithoutUser_idInput, PaymentsUncheckedCreateWithoutUser_idInput> | PaymentsCreateWithoutUser_idInput[] | PaymentsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUser_idInput | PaymentsCreateOrConnectWithoutUser_idInput[]
    createMany?: PaymentsCreateManyUser_idInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type CartsUncheckedCreateNestedManyWithoutUser_idInput = {
    create?: XOR<CartsCreateWithoutUser_idInput, CartsUncheckedCreateWithoutUser_idInput> | CartsCreateWithoutUser_idInput[] | CartsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutUser_idInput | CartsCreateOrConnectWithoutUser_idInput[]
    createMany?: CartsCreateManyUser_idInputEnvelope
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
  }

  export type Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput = {
    create?: XOR<Cart_itemsCreateWithoutUser_idInput, Cart_itemsUncheckedCreateWithoutUser_idInput> | Cart_itemsCreateWithoutUser_idInput[] | Cart_itemsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutUser_idInput | Cart_itemsCreateOrConnectWithoutUser_idInput[]
    createMany?: Cart_itemsCreateManyUser_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type InvoicesUncheckedCreateNestedManyWithoutUser_idInput = {
    create?: XOR<InvoicesCreateWithoutUser_idInput, InvoicesUncheckedCreateWithoutUser_idInput> | InvoicesCreateWithoutUser_idInput[] | InvoicesUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutUser_idInput | InvoicesCreateOrConnectWithoutUser_idInput[]
    createMany?: InvoicesCreateManyUser_idInputEnvelope
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
  }

  export type PaymentsUncheckedCreateNestedManyWithoutUser_idInput = {
    create?: XOR<PaymentsCreateWithoutUser_idInput, PaymentsUncheckedCreateWithoutUser_idInput> | PaymentsCreateWithoutUser_idInput[] | PaymentsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUser_idInput | PaymentsCreateOrConnectWithoutUser_idInput[]
    createMany?: PaymentsCreateManyUser_idInputEnvelope
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProfilesUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfilesCreateWithoutUserInput, ProfilesUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfilesCreateOrConnectWithoutUserInput
    upsert?: ProfilesUpsertWithoutUserInput
    disconnect?: ProfilesWhereInput | boolean
    delete?: ProfilesWhereInput | boolean
    connect?: ProfilesWhereUniqueInput
    update?: XOR<XOR<ProfilesUpdateToOneWithWhereWithoutUserInput, ProfilesUpdateWithoutUserInput>, ProfilesUncheckedUpdateWithoutUserInput>
  }

  export type RolesUpdateOneWithoutUserNestedInput = {
    create?: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserInput
    upsert?: RolesUpsertWithoutUserInput
    disconnect?: RolesWhereInput | boolean
    delete?: RolesWhereInput | boolean
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUserInput, RolesUpdateWithoutUserInput>, RolesUncheckedUpdateWithoutUserInput>
  }

  export type CartsUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<CartsCreateWithoutUser_idInput, CartsUncheckedCreateWithoutUser_idInput> | CartsCreateWithoutUser_idInput[] | CartsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutUser_idInput | CartsCreateOrConnectWithoutUser_idInput[]
    upsert?: CartsUpsertWithWhereUniqueWithoutUser_idInput | CartsUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: CartsCreateManyUser_idInputEnvelope
    set?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    disconnect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    delete?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    update?: CartsUpdateWithWhereUniqueWithoutUser_idInput | CartsUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: CartsUpdateManyWithWhereWithoutUser_idInput | CartsUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: CartsScalarWhereInput | CartsScalarWhereInput[]
  }

  export type Cart_itemsUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutUser_idInput, Cart_itemsUncheckedCreateWithoutUser_idInput> | Cart_itemsCreateWithoutUser_idInput[] | Cart_itemsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutUser_idInput | Cart_itemsCreateOrConnectWithoutUser_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutUser_idInput | Cart_itemsUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: Cart_itemsCreateManyUser_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutUser_idInput | Cart_itemsUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutUser_idInput | Cart_itemsUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type InvoicesUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutUser_idInput, InvoicesUncheckedCreateWithoutUser_idInput> | InvoicesCreateWithoutUser_idInput[] | InvoicesUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutUser_idInput | InvoicesCreateOrConnectWithoutUser_idInput[]
    upsert?: InvoicesUpsertWithWhereUniqueWithoutUser_idInput | InvoicesUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: InvoicesCreateManyUser_idInputEnvelope
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    update?: InvoicesUpdateWithWhereUniqueWithoutUser_idInput | InvoicesUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: InvoicesUpdateManyWithWhereWithoutUser_idInput | InvoicesUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
  }

  export type PaymentsUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<PaymentsCreateWithoutUser_idInput, PaymentsUncheckedCreateWithoutUser_idInput> | PaymentsCreateWithoutUser_idInput[] | PaymentsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUser_idInput | PaymentsCreateOrConnectWithoutUser_idInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUser_idInput | PaymentsUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: PaymentsCreateManyUser_idInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUser_idInput | PaymentsUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUser_idInput | PaymentsUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CartsUncheckedUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<CartsCreateWithoutUser_idInput, CartsUncheckedCreateWithoutUser_idInput> | CartsCreateWithoutUser_idInput[] | CartsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutUser_idInput | CartsCreateOrConnectWithoutUser_idInput[]
    upsert?: CartsUpsertWithWhereUniqueWithoutUser_idInput | CartsUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: CartsCreateManyUser_idInputEnvelope
    set?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    disconnect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    delete?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    update?: CartsUpdateWithWhereUniqueWithoutUser_idInput | CartsUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: CartsUpdateManyWithWhereWithoutUser_idInput | CartsUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: CartsScalarWhereInput | CartsScalarWhereInput[]
  }

  export type Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutUser_idInput, Cart_itemsUncheckedCreateWithoutUser_idInput> | Cart_itemsCreateWithoutUser_idInput[] | Cart_itemsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutUser_idInput | Cart_itemsCreateOrConnectWithoutUser_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutUser_idInput | Cart_itemsUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: Cart_itemsCreateManyUser_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutUser_idInput | Cart_itemsUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutUser_idInput | Cart_itemsUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type InvoicesUncheckedUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutUser_idInput, InvoicesUncheckedCreateWithoutUser_idInput> | InvoicesCreateWithoutUser_idInput[] | InvoicesUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutUser_idInput | InvoicesCreateOrConnectWithoutUser_idInput[]
    upsert?: InvoicesUpsertWithWhereUniqueWithoutUser_idInput | InvoicesUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: InvoicesCreateManyUser_idInputEnvelope
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    update?: InvoicesUpdateWithWhereUniqueWithoutUser_idInput | InvoicesUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: InvoicesUpdateManyWithWhereWithoutUser_idInput | InvoicesUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
  }

  export type PaymentsUncheckedUpdateManyWithoutUser_idNestedInput = {
    create?: XOR<PaymentsCreateWithoutUser_idInput, PaymentsUncheckedCreateWithoutUser_idInput> | PaymentsCreateWithoutUser_idInput[] | PaymentsUncheckedCreateWithoutUser_idInput[]
    connectOrCreate?: PaymentsCreateOrConnectWithoutUser_idInput | PaymentsCreateOrConnectWithoutUser_idInput[]
    upsert?: PaymentsUpsertWithWhereUniqueWithoutUser_idInput | PaymentsUpsertWithWhereUniqueWithoutUser_idInput[]
    createMany?: PaymentsCreateManyUser_idInputEnvelope
    set?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    disconnect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    delete?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    connect?: PaymentsWhereUniqueInput | PaymentsWhereUniqueInput[]
    update?: PaymentsUpdateWithWhereUniqueWithoutUser_idInput | PaymentsUpdateWithWhereUniqueWithoutUser_idInput[]
    updateMany?: PaymentsUpdateManyWithWhereWithoutUser_idInput | PaymentsUpdateManyWithWhereWithoutUser_idInput[]
    deleteMany?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutProfile_idInput = {
    create?: XOR<LocationCreateWithoutProfile_idInput, LocationUncheckedCreateWithoutProfile_idInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProfile_idInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutProfile_idInput = {
    create?: XOR<UserCreateWithoutProfile_idInput, UserUncheckedCreateWithoutProfile_idInput> | UserCreateWithoutProfile_idInput[] | UserUncheckedCreateWithoutProfile_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfile_idInput | UserCreateOrConnectWithoutProfile_idInput[]
    createMany?: UserCreateManyProfile_idInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProfile_idInput = {
    create?: XOR<UserCreateWithoutProfile_idInput, UserUncheckedCreateWithoutProfile_idInput> | UserCreateWithoutProfile_idInput[] | UserUncheckedCreateWithoutProfile_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfile_idInput | UserCreateOrConnectWithoutProfile_idInput[]
    createMany?: UserCreateManyProfile_idInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutProfile_idNestedInput = {
    create?: XOR<LocationCreateWithoutProfile_idInput, LocationUncheckedCreateWithoutProfile_idInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProfile_idInput
    upsert?: LocationUpsertWithoutProfile_idInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProfile_idInput, LocationUpdateWithoutProfile_idInput>, LocationUncheckedUpdateWithoutProfile_idInput>
  }

  export type UserUpdateManyWithoutProfile_idNestedInput = {
    create?: XOR<UserCreateWithoutProfile_idInput, UserUncheckedCreateWithoutProfile_idInput> | UserCreateWithoutProfile_idInput[] | UserUncheckedCreateWithoutProfile_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfile_idInput | UserCreateOrConnectWithoutProfile_idInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProfile_idInput | UserUpsertWithWhereUniqueWithoutProfile_idInput[]
    createMany?: UserCreateManyProfile_idInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProfile_idInput | UserUpdateWithWhereUniqueWithoutProfile_idInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProfile_idInput | UserUpdateManyWithWhereWithoutProfile_idInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProfile_idNestedInput = {
    create?: XOR<UserCreateWithoutProfile_idInput, UserUncheckedCreateWithoutProfile_idInput> | UserCreateWithoutProfile_idInput[] | UserUncheckedCreateWithoutProfile_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProfile_idInput | UserCreateOrConnectWithoutProfile_idInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProfile_idInput | UserUpsertWithWhereUniqueWithoutProfile_idInput[]
    createMany?: UserCreateManyProfile_idInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProfile_idInput | UserUpdateWithWhereUniqueWithoutProfile_idInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProfile_idInput | UserUpdateManyWithWhereWithoutProfile_idInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRole_idInput = {
    create?: XOR<UserCreateWithoutRole_idInput, UserUncheckedCreateWithoutRole_idInput> | UserCreateWithoutRole_idInput[] | UserUncheckedCreateWithoutRole_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRole_idInput | UserCreateOrConnectWithoutRole_idInput[]
    createMany?: UserCreateManyRole_idInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRole_idInput = {
    create?: XOR<UserCreateWithoutRole_idInput, UserUncheckedCreateWithoutRole_idInput> | UserCreateWithoutRole_idInput[] | UserUncheckedCreateWithoutRole_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRole_idInput | UserCreateOrConnectWithoutRole_idInput[]
    createMany?: UserCreateManyRole_idInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRole_idNestedInput = {
    create?: XOR<UserCreateWithoutRole_idInput, UserUncheckedCreateWithoutRole_idInput> | UserCreateWithoutRole_idInput[] | UserUncheckedCreateWithoutRole_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRole_idInput | UserCreateOrConnectWithoutRole_idInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRole_idInput | UserUpsertWithWhereUniqueWithoutRole_idInput[]
    createMany?: UserCreateManyRole_idInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRole_idInput | UserUpdateWithWhereUniqueWithoutRole_idInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRole_idInput | UserUpdateManyWithWhereWithoutRole_idInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRole_idNestedInput = {
    create?: XOR<UserCreateWithoutRole_idInput, UserUncheckedCreateWithoutRole_idInput> | UserCreateWithoutRole_idInput[] | UserUncheckedCreateWithoutRole_idInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRole_idInput | UserCreateOrConnectWithoutRole_idInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRole_idInput | UserUpsertWithWhereUniqueWithoutRole_idInput[]
    createMany?: UserCreateManyRole_idInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRole_idInput | UserUpdateWithWhereUniqueWithoutRole_idInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRole_idInput | UserUpdateManyWithWhereWithoutRole_idInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VariantsCreateNestedOneWithoutProduct_idInput = {
    create?: XOR<VariantsCreateWithoutProduct_idInput, VariantsUncheckedCreateWithoutProduct_idInput>
    connectOrCreate?: VariantsCreateOrConnectWithoutProduct_idInput
    connect?: VariantsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutProductInput = {
    create?: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProductInput
    connect?: StoresWhereUniqueInput
  }

  export type CategoriesCreateNestedManyWithoutProduct_idInput = {
    create?: XOR<CategoriesCreateWithoutProduct_idInput, CategoriesUncheckedCreateWithoutProduct_idInput> | CategoriesCreateWithoutProduct_idInput[] | CategoriesUncheckedCreateWithoutProduct_idInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutProduct_idInput | CategoriesCreateOrConnectWithoutProduct_idInput[]
    createMany?: CategoriesCreateManyProduct_idInputEnvelope
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
  }

  export type VariantsUncheckedCreateNestedOneWithoutProduct_idInput = {
    create?: XOR<VariantsCreateWithoutProduct_idInput, VariantsUncheckedCreateWithoutProduct_idInput>
    connectOrCreate?: VariantsCreateOrConnectWithoutProduct_idInput
    connect?: VariantsWhereUniqueInput
  }

  export type CategoriesUncheckedCreateNestedManyWithoutProduct_idInput = {
    create?: XOR<CategoriesCreateWithoutProduct_idInput, CategoriesUncheckedCreateWithoutProduct_idInput> | CategoriesCreateWithoutProduct_idInput[] | CategoriesUncheckedCreateWithoutProduct_idInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutProduct_idInput | CategoriesCreateOrConnectWithoutProduct_idInput[]
    createMany?: CategoriesCreateManyProduct_idInputEnvelope
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VariantsUpdateOneWithoutProduct_idNestedInput = {
    create?: XOR<VariantsCreateWithoutProduct_idInput, VariantsUncheckedCreateWithoutProduct_idInput>
    connectOrCreate?: VariantsCreateOrConnectWithoutProduct_idInput
    upsert?: VariantsUpsertWithoutProduct_idInput
    disconnect?: VariantsWhereInput | boolean
    delete?: VariantsWhereInput | boolean
    connect?: VariantsWhereUniqueInput
    update?: XOR<XOR<VariantsUpdateToOneWithWhereWithoutProduct_idInput, VariantsUpdateWithoutProduct_idInput>, VariantsUncheckedUpdateWithoutProduct_idInput>
  }

  export type StoresUpdateOneWithoutProductNestedInput = {
    create?: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProductInput
    upsert?: StoresUpsertWithoutProductInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutProductInput, StoresUpdateWithoutProductInput>, StoresUncheckedUpdateWithoutProductInput>
  }

  export type CategoriesUpdateManyWithoutProduct_idNestedInput = {
    create?: XOR<CategoriesCreateWithoutProduct_idInput, CategoriesUncheckedCreateWithoutProduct_idInput> | CategoriesCreateWithoutProduct_idInput[] | CategoriesUncheckedCreateWithoutProduct_idInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutProduct_idInput | CategoriesCreateOrConnectWithoutProduct_idInput[]
    upsert?: CategoriesUpsertWithWhereUniqueWithoutProduct_idInput | CategoriesUpsertWithWhereUniqueWithoutProduct_idInput[]
    createMany?: CategoriesCreateManyProduct_idInputEnvelope
    set?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    disconnect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    delete?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    update?: CategoriesUpdateWithWhereUniqueWithoutProduct_idInput | CategoriesUpdateWithWhereUniqueWithoutProduct_idInput[]
    updateMany?: CategoriesUpdateManyWithWhereWithoutProduct_idInput | CategoriesUpdateManyWithWhereWithoutProduct_idInput[]
    deleteMany?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
  }

  export type VariantsUncheckedUpdateOneWithoutProduct_idNestedInput = {
    create?: XOR<VariantsCreateWithoutProduct_idInput, VariantsUncheckedCreateWithoutProduct_idInput>
    connectOrCreate?: VariantsCreateOrConnectWithoutProduct_idInput
    upsert?: VariantsUpsertWithoutProduct_idInput
    disconnect?: VariantsWhereInput | boolean
    delete?: VariantsWhereInput | boolean
    connect?: VariantsWhereUniqueInput
    update?: XOR<XOR<VariantsUpdateToOneWithWhereWithoutProduct_idInput, VariantsUpdateWithoutProduct_idInput>, VariantsUncheckedUpdateWithoutProduct_idInput>
  }

  export type CategoriesUncheckedUpdateManyWithoutProduct_idNestedInput = {
    create?: XOR<CategoriesCreateWithoutProduct_idInput, CategoriesUncheckedCreateWithoutProduct_idInput> | CategoriesCreateWithoutProduct_idInput[] | CategoriesUncheckedCreateWithoutProduct_idInput[]
    connectOrCreate?: CategoriesCreateOrConnectWithoutProduct_idInput | CategoriesCreateOrConnectWithoutProduct_idInput[]
    upsert?: CategoriesUpsertWithWhereUniqueWithoutProduct_idInput | CategoriesUpsertWithWhereUniqueWithoutProduct_idInput[]
    createMany?: CategoriesCreateManyProduct_idInputEnvelope
    set?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    disconnect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    delete?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    connect?: CategoriesWhereUniqueInput | CategoriesWhereUniqueInput[]
    update?: CategoriesUpdateWithWhereUniqueWithoutProduct_idInput | CategoriesUpdateWithWhereUniqueWithoutProduct_idInput[]
    updateMany?: CategoriesUpdateManyWithWhereWithoutProduct_idInput | CategoriesUpdateManyWithWhereWithoutProduct_idInput[]
    deleteMany?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutStore_idInput = {
    create?: XOR<ProductCreateWithoutStore_idInput, ProductUncheckedCreateWithoutStore_idInput> | ProductCreateWithoutStore_idInput[] | ProductUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStore_idInput | ProductCreateOrConnectWithoutStore_idInput[]
    createMany?: ProductCreateManyStore_idInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type bank_accountsCreateNestedManyWithoutStore_idInput = {
    create?: XOR<bank_accountsCreateWithoutStore_idInput, bank_accountsUncheckedCreateWithoutStore_idInput> | bank_accountsCreateWithoutStore_idInput[] | bank_accountsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutStore_idInput | bank_accountsCreateOrConnectWithoutStore_idInput[]
    createMany?: bank_accountsCreateManyStore_idInputEnvelope
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutStore_idInput = {
    create?: XOR<LocationCreateWithoutStore_idInput, LocationUncheckedCreateWithoutStore_idInput> | LocationCreateWithoutStore_idInput[] | LocationUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStore_idInput | LocationCreateOrConnectWithoutStore_idInput[]
    createMany?: LocationCreateManyStore_idInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type CartsCreateNestedManyWithoutStore_idInput = {
    create?: XOR<CartsCreateWithoutStore_idInput, CartsUncheckedCreateWithoutStore_idInput> | CartsCreateWithoutStore_idInput[] | CartsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutStore_idInput | CartsCreateOrConnectWithoutStore_idInput[]
    createMany?: CartsCreateManyStore_idInputEnvelope
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
  }

  export type Cart_itemsCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Cart_itemsCreateWithoutStore_idInput, Cart_itemsUncheckedCreateWithoutStore_idInput> | Cart_itemsCreateWithoutStore_idInput[] | Cart_itemsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutStore_idInput | Cart_itemsCreateOrConnectWithoutStore_idInput[]
    createMany?: Cart_itemsCreateManyStore_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type Stores_on_decorationsCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Stores_on_decorationsCreateWithoutStore_idInput, Stores_on_decorationsUncheckedCreateWithoutStore_idInput> | Stores_on_decorationsCreateWithoutStore_idInput[] | Stores_on_decorationsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Stores_on_decorationsCreateOrConnectWithoutStore_idInput | Stores_on_decorationsCreateOrConnectWithoutStore_idInput[]
    createMany?: Stores_on_decorationsCreateManyStore_idInputEnvelope
    connect?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
  }

  export type Operation_hoursCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Operation_hoursCreateWithoutStore_idInput, Operation_hoursUncheckedCreateWithoutStore_idInput> | Operation_hoursCreateWithoutStore_idInput[] | Operation_hoursUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Operation_hoursCreateOrConnectWithoutStore_idInput | Operation_hoursCreateOrConnectWithoutStore_idInput[]
    createMany?: Operation_hoursCreateManyStore_idInputEnvelope
    connect?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
  }

  export type Message_templatesCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Message_templatesCreateWithoutStore_idInput, Message_templatesUncheckedCreateWithoutStore_idInput> | Message_templatesCreateWithoutStore_idInput[] | Message_templatesUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Message_templatesCreateOrConnectWithoutStore_idInput | Message_templatesCreateOrConnectWithoutStore_idInput[]
    createMany?: Message_templatesCreateManyStore_idInputEnvelope
    connect?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<ProductCreateWithoutStore_idInput, ProductUncheckedCreateWithoutStore_idInput> | ProductCreateWithoutStore_idInput[] | ProductUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStore_idInput | ProductCreateOrConnectWithoutStore_idInput[]
    createMany?: ProductCreateManyStore_idInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type bank_accountsUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<bank_accountsCreateWithoutStore_idInput, bank_accountsUncheckedCreateWithoutStore_idInput> | bank_accountsCreateWithoutStore_idInput[] | bank_accountsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutStore_idInput | bank_accountsCreateOrConnectWithoutStore_idInput[]
    createMany?: bank_accountsCreateManyStore_idInputEnvelope
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<LocationCreateWithoutStore_idInput, LocationUncheckedCreateWithoutStore_idInput> | LocationCreateWithoutStore_idInput[] | LocationUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStore_idInput | LocationCreateOrConnectWithoutStore_idInput[]
    createMany?: LocationCreateManyStore_idInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type CartsUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<CartsCreateWithoutStore_idInput, CartsUncheckedCreateWithoutStore_idInput> | CartsCreateWithoutStore_idInput[] | CartsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutStore_idInput | CartsCreateOrConnectWithoutStore_idInput[]
    createMany?: CartsCreateManyStore_idInputEnvelope
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
  }

  export type Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Cart_itemsCreateWithoutStore_idInput, Cart_itemsUncheckedCreateWithoutStore_idInput> | Cart_itemsCreateWithoutStore_idInput[] | Cart_itemsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutStore_idInput | Cart_itemsCreateOrConnectWithoutStore_idInput[]
    createMany?: Cart_itemsCreateManyStore_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Stores_on_decorationsCreateWithoutStore_idInput, Stores_on_decorationsUncheckedCreateWithoutStore_idInput> | Stores_on_decorationsCreateWithoutStore_idInput[] | Stores_on_decorationsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Stores_on_decorationsCreateOrConnectWithoutStore_idInput | Stores_on_decorationsCreateOrConnectWithoutStore_idInput[]
    createMany?: Stores_on_decorationsCreateManyStore_idInputEnvelope
    connect?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
  }

  export type Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Operation_hoursCreateWithoutStore_idInput, Operation_hoursUncheckedCreateWithoutStore_idInput> | Operation_hoursCreateWithoutStore_idInput[] | Operation_hoursUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Operation_hoursCreateOrConnectWithoutStore_idInput | Operation_hoursCreateOrConnectWithoutStore_idInput[]
    createMany?: Operation_hoursCreateManyStore_idInputEnvelope
    connect?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
  }

  export type Message_templatesUncheckedCreateNestedManyWithoutStore_idInput = {
    create?: XOR<Message_templatesCreateWithoutStore_idInput, Message_templatesUncheckedCreateWithoutStore_idInput> | Message_templatesCreateWithoutStore_idInput[] | Message_templatesUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Message_templatesCreateOrConnectWithoutStore_idInput | Message_templatesCreateOrConnectWithoutStore_idInput[]
    createMany?: Message_templatesCreateManyStore_idInputEnvelope
    connect?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<ProductCreateWithoutStore_idInput, ProductUncheckedCreateWithoutStore_idInput> | ProductCreateWithoutStore_idInput[] | ProductUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStore_idInput | ProductCreateOrConnectWithoutStore_idInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStore_idInput | ProductUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: ProductCreateManyStore_idInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStore_idInput | ProductUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStore_idInput | ProductUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type bank_accountsUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<bank_accountsCreateWithoutStore_idInput, bank_accountsUncheckedCreateWithoutStore_idInput> | bank_accountsCreateWithoutStore_idInput[] | bank_accountsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutStore_idInput | bank_accountsCreateOrConnectWithoutStore_idInput[]
    upsert?: bank_accountsUpsertWithWhereUniqueWithoutStore_idInput | bank_accountsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: bank_accountsCreateManyStore_idInputEnvelope
    set?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    disconnect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    delete?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    update?: bank_accountsUpdateWithWhereUniqueWithoutStore_idInput | bank_accountsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: bank_accountsUpdateManyWithWhereWithoutStore_idInput | bank_accountsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<LocationCreateWithoutStore_idInput, LocationUncheckedCreateWithoutStore_idInput> | LocationCreateWithoutStore_idInput[] | LocationUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStore_idInput | LocationCreateOrConnectWithoutStore_idInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutStore_idInput | LocationUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: LocationCreateManyStore_idInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutStore_idInput | LocationUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutStore_idInput | LocationUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type CartsUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<CartsCreateWithoutStore_idInput, CartsUncheckedCreateWithoutStore_idInput> | CartsCreateWithoutStore_idInput[] | CartsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutStore_idInput | CartsCreateOrConnectWithoutStore_idInput[]
    upsert?: CartsUpsertWithWhereUniqueWithoutStore_idInput | CartsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: CartsCreateManyStore_idInputEnvelope
    set?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    disconnect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    delete?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    update?: CartsUpdateWithWhereUniqueWithoutStore_idInput | CartsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: CartsUpdateManyWithWhereWithoutStore_idInput | CartsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: CartsScalarWhereInput | CartsScalarWhereInput[]
  }

  export type Cart_itemsUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutStore_idInput, Cart_itemsUncheckedCreateWithoutStore_idInput> | Cart_itemsCreateWithoutStore_idInput[] | Cart_itemsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutStore_idInput | Cart_itemsCreateOrConnectWithoutStore_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutStore_idInput | Cart_itemsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Cart_itemsCreateManyStore_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutStore_idInput | Cart_itemsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutStore_idInput | Cart_itemsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type Stores_on_decorationsUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Stores_on_decorationsCreateWithoutStore_idInput, Stores_on_decorationsUncheckedCreateWithoutStore_idInput> | Stores_on_decorationsCreateWithoutStore_idInput[] | Stores_on_decorationsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Stores_on_decorationsCreateOrConnectWithoutStore_idInput | Stores_on_decorationsCreateOrConnectWithoutStore_idInput[]
    upsert?: Stores_on_decorationsUpsertWithWhereUniqueWithoutStore_idInput | Stores_on_decorationsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Stores_on_decorationsCreateManyStore_idInputEnvelope
    set?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    disconnect?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    delete?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    connect?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    update?: Stores_on_decorationsUpdateWithWhereUniqueWithoutStore_idInput | Stores_on_decorationsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Stores_on_decorationsUpdateManyWithWhereWithoutStore_idInput | Stores_on_decorationsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Stores_on_decorationsScalarWhereInput | Stores_on_decorationsScalarWhereInput[]
  }

  export type Operation_hoursUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Operation_hoursCreateWithoutStore_idInput, Operation_hoursUncheckedCreateWithoutStore_idInput> | Operation_hoursCreateWithoutStore_idInput[] | Operation_hoursUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Operation_hoursCreateOrConnectWithoutStore_idInput | Operation_hoursCreateOrConnectWithoutStore_idInput[]
    upsert?: Operation_hoursUpsertWithWhereUniqueWithoutStore_idInput | Operation_hoursUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Operation_hoursCreateManyStore_idInputEnvelope
    set?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    disconnect?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    delete?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    connect?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    update?: Operation_hoursUpdateWithWhereUniqueWithoutStore_idInput | Operation_hoursUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Operation_hoursUpdateManyWithWhereWithoutStore_idInput | Operation_hoursUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Operation_hoursScalarWhereInput | Operation_hoursScalarWhereInput[]
  }

  export type Message_templatesUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Message_templatesCreateWithoutStore_idInput, Message_templatesUncheckedCreateWithoutStore_idInput> | Message_templatesCreateWithoutStore_idInput[] | Message_templatesUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Message_templatesCreateOrConnectWithoutStore_idInput | Message_templatesCreateOrConnectWithoutStore_idInput[]
    upsert?: Message_templatesUpsertWithWhereUniqueWithoutStore_idInput | Message_templatesUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Message_templatesCreateManyStore_idInputEnvelope
    set?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    disconnect?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    delete?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    connect?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    update?: Message_templatesUpdateWithWhereUniqueWithoutStore_idInput | Message_templatesUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Message_templatesUpdateManyWithWhereWithoutStore_idInput | Message_templatesUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Message_templatesScalarWhereInput | Message_templatesScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<ProductCreateWithoutStore_idInput, ProductUncheckedCreateWithoutStore_idInput> | ProductCreateWithoutStore_idInput[] | ProductUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutStore_idInput | ProductCreateOrConnectWithoutStore_idInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutStore_idInput | ProductUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: ProductCreateManyStore_idInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutStore_idInput | ProductUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutStore_idInput | ProductUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<bank_accountsCreateWithoutStore_idInput, bank_accountsUncheckedCreateWithoutStore_idInput> | bank_accountsCreateWithoutStore_idInput[] | bank_accountsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: bank_accountsCreateOrConnectWithoutStore_idInput | bank_accountsCreateOrConnectWithoutStore_idInput[]
    upsert?: bank_accountsUpsertWithWhereUniqueWithoutStore_idInput | bank_accountsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: bank_accountsCreateManyStore_idInputEnvelope
    set?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    disconnect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    delete?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    connect?: bank_accountsWhereUniqueInput | bank_accountsWhereUniqueInput[]
    update?: bank_accountsUpdateWithWhereUniqueWithoutStore_idInput | bank_accountsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: bank_accountsUpdateManyWithWhereWithoutStore_idInput | bank_accountsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<LocationCreateWithoutStore_idInput, LocationUncheckedCreateWithoutStore_idInput> | LocationCreateWithoutStore_idInput[] | LocationUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutStore_idInput | LocationCreateOrConnectWithoutStore_idInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutStore_idInput | LocationUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: LocationCreateManyStore_idInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutStore_idInput | LocationUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutStore_idInput | LocationUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type CartsUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<CartsCreateWithoutStore_idInput, CartsUncheckedCreateWithoutStore_idInput> | CartsCreateWithoutStore_idInput[] | CartsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: CartsCreateOrConnectWithoutStore_idInput | CartsCreateOrConnectWithoutStore_idInput[]
    upsert?: CartsUpsertWithWhereUniqueWithoutStore_idInput | CartsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: CartsCreateManyStore_idInputEnvelope
    set?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    disconnect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    delete?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    connect?: CartsWhereUniqueInput | CartsWhereUniqueInput[]
    update?: CartsUpdateWithWhereUniqueWithoutStore_idInput | CartsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: CartsUpdateManyWithWhereWithoutStore_idInput | CartsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: CartsScalarWhereInput | CartsScalarWhereInput[]
  }

  export type Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutStore_idInput, Cart_itemsUncheckedCreateWithoutStore_idInput> | Cart_itemsCreateWithoutStore_idInput[] | Cart_itemsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutStore_idInput | Cart_itemsCreateOrConnectWithoutStore_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutStore_idInput | Cart_itemsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Cart_itemsCreateManyStore_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutStore_idInput | Cart_itemsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutStore_idInput | Cart_itemsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Stores_on_decorationsCreateWithoutStore_idInput, Stores_on_decorationsUncheckedCreateWithoutStore_idInput> | Stores_on_decorationsCreateWithoutStore_idInput[] | Stores_on_decorationsUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Stores_on_decorationsCreateOrConnectWithoutStore_idInput | Stores_on_decorationsCreateOrConnectWithoutStore_idInput[]
    upsert?: Stores_on_decorationsUpsertWithWhereUniqueWithoutStore_idInput | Stores_on_decorationsUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Stores_on_decorationsCreateManyStore_idInputEnvelope
    set?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    disconnect?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    delete?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    connect?: Stores_on_decorationsWhereUniqueInput | Stores_on_decorationsWhereUniqueInput[]
    update?: Stores_on_decorationsUpdateWithWhereUniqueWithoutStore_idInput | Stores_on_decorationsUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Stores_on_decorationsUpdateManyWithWhereWithoutStore_idInput | Stores_on_decorationsUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Stores_on_decorationsScalarWhereInput | Stores_on_decorationsScalarWhereInput[]
  }

  export type Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Operation_hoursCreateWithoutStore_idInput, Operation_hoursUncheckedCreateWithoutStore_idInput> | Operation_hoursCreateWithoutStore_idInput[] | Operation_hoursUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Operation_hoursCreateOrConnectWithoutStore_idInput | Operation_hoursCreateOrConnectWithoutStore_idInput[]
    upsert?: Operation_hoursUpsertWithWhereUniqueWithoutStore_idInput | Operation_hoursUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Operation_hoursCreateManyStore_idInputEnvelope
    set?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    disconnect?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    delete?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    connect?: Operation_hoursWhereUniqueInput | Operation_hoursWhereUniqueInput[]
    update?: Operation_hoursUpdateWithWhereUniqueWithoutStore_idInput | Operation_hoursUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Operation_hoursUpdateManyWithWhereWithoutStore_idInput | Operation_hoursUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Operation_hoursScalarWhereInput | Operation_hoursScalarWhereInput[]
  }

  export type Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput = {
    create?: XOR<Message_templatesCreateWithoutStore_idInput, Message_templatesUncheckedCreateWithoutStore_idInput> | Message_templatesCreateWithoutStore_idInput[] | Message_templatesUncheckedCreateWithoutStore_idInput[]
    connectOrCreate?: Message_templatesCreateOrConnectWithoutStore_idInput | Message_templatesCreateOrConnectWithoutStore_idInput[]
    upsert?: Message_templatesUpsertWithWhereUniqueWithoutStore_idInput | Message_templatesUpsertWithWhereUniqueWithoutStore_idInput[]
    createMany?: Message_templatesCreateManyStore_idInputEnvelope
    set?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    disconnect?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    delete?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    connect?: Message_templatesWhereUniqueInput | Message_templatesWhereUniqueInput[]
    update?: Message_templatesUpdateWithWhereUniqueWithoutStore_idInput | Message_templatesUpdateWithWhereUniqueWithoutStore_idInput[]
    updateMany?: Message_templatesUpdateManyWithWhereWithoutStore_idInput | Message_templatesUpdateManyWithWhereWithoutStore_idInput[]
    deleteMany?: Message_templatesScalarWhereInput | Message_templatesScalarWhereInput[]
  }

  export type StoresCreateNestedOneWithoutBank_accountsInput = {
    create?: XOR<StoresCreateWithoutBank_accountsInput, StoresUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutBank_accountsInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUpdateOneWithoutBank_accountsNestedInput = {
    create?: XOR<StoresCreateWithoutBank_accountsInput, StoresUncheckedCreateWithoutBank_accountsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutBank_accountsInput
    upsert?: StoresUpsertWithoutBank_accountsInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutBank_accountsInput, StoresUpdateWithoutBank_accountsInput>, StoresUncheckedUpdateWithoutBank_accountsInput>
  }

  export type StoresCreateNestedOneWithoutLocationInput = {
    create?: XOR<StoresCreateWithoutLocationInput, StoresUncheckedCreateWithoutLocationInput>
    connectOrCreate?: StoresCreateOrConnectWithoutLocationInput
    connect?: StoresWhereUniqueInput
  }

  export type ProfilesCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ProfilesCreateWithoutLocationsInput, ProfilesUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ProfilesCreateOrConnectWithoutLocationsInput
    connect?: ProfilesWhereUniqueInput
  }

  export type ProfilesUncheckedCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ProfilesCreateWithoutLocationsInput, ProfilesUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ProfilesCreateOrConnectWithoutLocationsInput
    connect?: ProfilesWhereUniqueInput
  }

  export type StoresUpdateOneWithoutLocationNestedInput = {
    create?: XOR<StoresCreateWithoutLocationInput, StoresUncheckedCreateWithoutLocationInput>
    connectOrCreate?: StoresCreateOrConnectWithoutLocationInput
    upsert?: StoresUpsertWithoutLocationInput
    disconnect?: StoresWhereInput | boolean
    delete?: StoresWhereInput | boolean
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutLocationInput, StoresUpdateWithoutLocationInput>, StoresUncheckedUpdateWithoutLocationInput>
  }

  export type ProfilesUpdateOneWithoutLocationsNestedInput = {
    create?: XOR<ProfilesCreateWithoutLocationsInput, ProfilesUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ProfilesCreateOrConnectWithoutLocationsInput
    upsert?: ProfilesUpsertWithoutLocationsInput
    disconnect?: ProfilesWhereInput | boolean
    delete?: ProfilesWhereInput | boolean
    connect?: ProfilesWhereUniqueInput
    update?: XOR<XOR<ProfilesUpdateToOneWithWhereWithoutLocationsInput, ProfilesUpdateWithoutLocationsInput>, ProfilesUncheckedUpdateWithoutLocationsInput>
  }

  export type ProfilesUncheckedUpdateOneWithoutLocationsNestedInput = {
    create?: XOR<ProfilesCreateWithoutLocationsInput, ProfilesUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ProfilesCreateOrConnectWithoutLocationsInput
    upsert?: ProfilesUpsertWithoutLocationsInput
    disconnect?: ProfilesWhereInput | boolean
    delete?: ProfilesWhereInput | boolean
    connect?: ProfilesWhereUniqueInput
    update?: XOR<XOR<ProfilesUpdateToOneWithWhereWithoutLocationsInput, ProfilesUpdateWithoutLocationsInput>, ProfilesUncheckedUpdateWithoutLocationsInput>
  }

  export type Variant_optionsCreateNestedOneWithoutVariant_option_valuesInput = {
    create?: XOR<Variant_optionsCreateWithoutVariant_option_valuesInput, Variant_optionsUncheckedCreateWithoutVariant_option_valuesInput>
    connectOrCreate?: Variant_optionsCreateOrConnectWithoutVariant_option_valuesInput
    connect?: Variant_optionsWhereUniqueInput
  }

  export type Cart_itemsCreateNestedManyWithoutVariant_option_value_idInput = {
    create?: XOR<Cart_itemsCreateWithoutVariant_option_value_idInput, Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput> | Cart_itemsCreateWithoutVariant_option_value_idInput[] | Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput | Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput[]
    createMany?: Cart_itemsCreateManyVariant_option_value_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type Cart_itemsUncheckedCreateNestedManyWithoutVariant_option_value_idInput = {
    create?: XOR<Cart_itemsCreateWithoutVariant_option_value_idInput, Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput> | Cart_itemsCreateWithoutVariant_option_value_idInput[] | Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput | Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput[]
    createMany?: Cart_itemsCreateManyVariant_option_value_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Variant_optionsUpdateOneRequiredWithoutVariant_option_valuesNestedInput = {
    create?: XOR<Variant_optionsCreateWithoutVariant_option_valuesInput, Variant_optionsUncheckedCreateWithoutVariant_option_valuesInput>
    connectOrCreate?: Variant_optionsCreateOrConnectWithoutVariant_option_valuesInput
    upsert?: Variant_optionsUpsertWithoutVariant_option_valuesInput
    connect?: Variant_optionsWhereUniqueInput
    update?: XOR<XOR<Variant_optionsUpdateToOneWithWhereWithoutVariant_option_valuesInput, Variant_optionsUpdateWithoutVariant_option_valuesInput>, Variant_optionsUncheckedUpdateWithoutVariant_option_valuesInput>
  }

  export type Cart_itemsUpdateManyWithoutVariant_option_value_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutVariant_option_value_idInput, Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput> | Cart_itemsCreateWithoutVariant_option_value_idInput[] | Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput | Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutVariant_option_value_idInput | Cart_itemsUpsertWithWhereUniqueWithoutVariant_option_value_idInput[]
    createMany?: Cart_itemsCreateManyVariant_option_value_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutVariant_option_value_idInput | Cart_itemsUpdateWithWhereUniqueWithoutVariant_option_value_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutVariant_option_value_idInput | Cart_itemsUpdateManyWithWhereWithoutVariant_option_value_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type Cart_itemsUncheckedUpdateManyWithoutVariant_option_value_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutVariant_option_value_idInput, Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput> | Cart_itemsCreateWithoutVariant_option_value_idInput[] | Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput | Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutVariant_option_value_idInput | Cart_itemsUpsertWithWhereUniqueWithoutVariant_option_value_idInput[]
    createMany?: Cart_itemsCreateManyVariant_option_value_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutVariant_option_value_idInput | Cart_itemsUpdateWithWhereUniqueWithoutVariant_option_value_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutVariant_option_value_idInput | Cart_itemsUpdateManyWithWhereWithoutVariant_option_value_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type VariantsCreateNestedOneWithoutVariant_optionsInput = {
    create?: XOR<VariantsCreateWithoutVariant_optionsInput, VariantsUncheckedCreateWithoutVariant_optionsInput>
    connectOrCreate?: VariantsCreateOrConnectWithoutVariant_optionsInput
    connect?: VariantsWhereUniqueInput
  }

  export type Variant_option_valuesCreateNestedManyWithoutVariant_option_idInput = {
    create?: XOR<Variant_option_valuesCreateWithoutVariant_option_idInput, Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput> | Variant_option_valuesCreateWithoutVariant_option_idInput[] | Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput[]
    connectOrCreate?: Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput | Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput[]
    createMany?: Variant_option_valuesCreateManyVariant_option_idInputEnvelope
    connect?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
  }

  export type Variant_option_valuesUncheckedCreateNestedManyWithoutVariant_option_idInput = {
    create?: XOR<Variant_option_valuesCreateWithoutVariant_option_idInput, Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput> | Variant_option_valuesCreateWithoutVariant_option_idInput[] | Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput[]
    connectOrCreate?: Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput | Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput[]
    createMany?: Variant_option_valuesCreateManyVariant_option_idInputEnvelope
    connect?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
  }

  export type VariantsUpdateOneRequiredWithoutVariant_optionsNestedInput = {
    create?: XOR<VariantsCreateWithoutVariant_optionsInput, VariantsUncheckedCreateWithoutVariant_optionsInput>
    connectOrCreate?: VariantsCreateOrConnectWithoutVariant_optionsInput
    upsert?: VariantsUpsertWithoutVariant_optionsInput
    connect?: VariantsWhereUniqueInput
    update?: XOR<XOR<VariantsUpdateToOneWithWhereWithoutVariant_optionsInput, VariantsUpdateWithoutVariant_optionsInput>, VariantsUncheckedUpdateWithoutVariant_optionsInput>
  }

  export type Variant_option_valuesUpdateManyWithoutVariant_option_idNestedInput = {
    create?: XOR<Variant_option_valuesCreateWithoutVariant_option_idInput, Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput> | Variant_option_valuesCreateWithoutVariant_option_idInput[] | Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput[]
    connectOrCreate?: Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput | Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput[]
    upsert?: Variant_option_valuesUpsertWithWhereUniqueWithoutVariant_option_idInput | Variant_option_valuesUpsertWithWhereUniqueWithoutVariant_option_idInput[]
    createMany?: Variant_option_valuesCreateManyVariant_option_idInputEnvelope
    set?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    disconnect?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    delete?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    connect?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    update?: Variant_option_valuesUpdateWithWhereUniqueWithoutVariant_option_idInput | Variant_option_valuesUpdateWithWhereUniqueWithoutVariant_option_idInput[]
    updateMany?: Variant_option_valuesUpdateManyWithWhereWithoutVariant_option_idInput | Variant_option_valuesUpdateManyWithWhereWithoutVariant_option_idInput[]
    deleteMany?: Variant_option_valuesScalarWhereInput | Variant_option_valuesScalarWhereInput[]
  }

  export type Variant_option_valuesUncheckedUpdateManyWithoutVariant_option_idNestedInput = {
    create?: XOR<Variant_option_valuesCreateWithoutVariant_option_idInput, Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput> | Variant_option_valuesCreateWithoutVariant_option_idInput[] | Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput[]
    connectOrCreate?: Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput | Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput[]
    upsert?: Variant_option_valuesUpsertWithWhereUniqueWithoutVariant_option_idInput | Variant_option_valuesUpsertWithWhereUniqueWithoutVariant_option_idInput[]
    createMany?: Variant_option_valuesCreateManyVariant_option_idInputEnvelope
    set?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    disconnect?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    delete?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    connect?: Variant_option_valuesWhereUniqueInput | Variant_option_valuesWhereUniqueInput[]
    update?: Variant_option_valuesUpdateWithWhereUniqueWithoutVariant_option_idInput | Variant_option_valuesUpdateWithWhereUniqueWithoutVariant_option_idInput[]
    updateMany?: Variant_option_valuesUpdateManyWithWhereWithoutVariant_option_idInput | Variant_option_valuesUpdateManyWithWhereWithoutVariant_option_idInput[]
    deleteMany?: Variant_option_valuesScalarWhereInput | Variant_option_valuesScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type Variant_optionsCreateNestedManyWithoutVariant_idInput = {
    create?: XOR<Variant_optionsCreateWithoutVariant_idInput, Variant_optionsUncheckedCreateWithoutVariant_idInput> | Variant_optionsCreateWithoutVariant_idInput[] | Variant_optionsUncheckedCreateWithoutVariant_idInput[]
    connectOrCreate?: Variant_optionsCreateOrConnectWithoutVariant_idInput | Variant_optionsCreateOrConnectWithoutVariant_idInput[]
    createMany?: Variant_optionsCreateManyVariant_idInputEnvelope
    connect?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
  }

  export type Variant_optionsUncheckedCreateNestedManyWithoutVariant_idInput = {
    create?: XOR<Variant_optionsCreateWithoutVariant_idInput, Variant_optionsUncheckedCreateWithoutVariant_idInput> | Variant_optionsCreateWithoutVariant_idInput[] | Variant_optionsUncheckedCreateWithoutVariant_idInput[]
    connectOrCreate?: Variant_optionsCreateOrConnectWithoutVariant_idInput | Variant_optionsCreateOrConnectWithoutVariant_idInput[]
    createMany?: Variant_optionsCreateManyVariant_idInputEnvelope
    connect?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type Variant_optionsUpdateManyWithoutVariant_idNestedInput = {
    create?: XOR<Variant_optionsCreateWithoutVariant_idInput, Variant_optionsUncheckedCreateWithoutVariant_idInput> | Variant_optionsCreateWithoutVariant_idInput[] | Variant_optionsUncheckedCreateWithoutVariant_idInput[]
    connectOrCreate?: Variant_optionsCreateOrConnectWithoutVariant_idInput | Variant_optionsCreateOrConnectWithoutVariant_idInput[]
    upsert?: Variant_optionsUpsertWithWhereUniqueWithoutVariant_idInput | Variant_optionsUpsertWithWhereUniqueWithoutVariant_idInput[]
    createMany?: Variant_optionsCreateManyVariant_idInputEnvelope
    set?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    disconnect?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    delete?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    connect?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    update?: Variant_optionsUpdateWithWhereUniqueWithoutVariant_idInput | Variant_optionsUpdateWithWhereUniqueWithoutVariant_idInput[]
    updateMany?: Variant_optionsUpdateManyWithWhereWithoutVariant_idInput | Variant_optionsUpdateManyWithWhereWithoutVariant_idInput[]
    deleteMany?: Variant_optionsScalarWhereInput | Variant_optionsScalarWhereInput[]
  }

  export type Variant_optionsUncheckedUpdateManyWithoutVariant_idNestedInput = {
    create?: XOR<Variant_optionsCreateWithoutVariant_idInput, Variant_optionsUncheckedCreateWithoutVariant_idInput> | Variant_optionsCreateWithoutVariant_idInput[] | Variant_optionsUncheckedCreateWithoutVariant_idInput[]
    connectOrCreate?: Variant_optionsCreateOrConnectWithoutVariant_idInput | Variant_optionsCreateOrConnectWithoutVariant_idInput[]
    upsert?: Variant_optionsUpsertWithWhereUniqueWithoutVariant_idInput | Variant_optionsUpsertWithWhereUniqueWithoutVariant_idInput[]
    createMany?: Variant_optionsCreateManyVariant_idInputEnvelope
    set?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    disconnect?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    delete?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    connect?: Variant_optionsWhereUniqueInput | Variant_optionsWhereUniqueInput[]
    update?: Variant_optionsUpdateWithWhereUniqueWithoutVariant_idInput | Variant_optionsUpdateWithWhereUniqueWithoutVariant_idInput[]
    updateMany?: Variant_optionsUpdateManyWithWhereWithoutVariant_idInput | Variant_optionsUpdateManyWithWhereWithoutVariant_idInput[]
    deleteMany?: Variant_optionsScalarWhereInput | Variant_optionsScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    upsert?: ProductUpsertWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCategoriesInput, ProductUpdateWithoutCategoriesInput>, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type UserCreateNestedOneWithoutCartsInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    connect?: UserWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutCartsInput = {
    create?: XOR<StoresCreateWithoutCartsInput, StoresUncheckedCreateWithoutCartsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCartsInput
    connect?: StoresWhereUniqueInput
  }

  export type Cart_itemsCreateNestedManyWithoutCart_idInput = {
    create?: XOR<Cart_itemsCreateWithoutCart_idInput, Cart_itemsUncheckedCreateWithoutCart_idInput> | Cart_itemsCreateWithoutCart_idInput[] | Cart_itemsUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutCart_idInput | Cart_itemsCreateOrConnectWithoutCart_idInput[]
    createMany?: Cart_itemsCreateManyCart_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type InvoicesCreateNestedManyWithoutCart_idInput = {
    create?: XOR<InvoicesCreateWithoutCart_idInput, InvoicesUncheckedCreateWithoutCart_idInput> | InvoicesCreateWithoutCart_idInput[] | InvoicesUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCart_idInput | InvoicesCreateOrConnectWithoutCart_idInput[]
    createMany?: InvoicesCreateManyCart_idInputEnvelope
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
  }

  export type Cart_itemsUncheckedCreateNestedManyWithoutCart_idInput = {
    create?: XOR<Cart_itemsCreateWithoutCart_idInput, Cart_itemsUncheckedCreateWithoutCart_idInput> | Cart_itemsCreateWithoutCart_idInput[] | Cart_itemsUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutCart_idInput | Cart_itemsCreateOrConnectWithoutCart_idInput[]
    createMany?: Cart_itemsCreateManyCart_idInputEnvelope
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
  }

  export type InvoicesUncheckedCreateNestedManyWithoutCart_idInput = {
    create?: XOR<InvoicesCreateWithoutCart_idInput, InvoicesUncheckedCreateWithoutCart_idInput> | InvoicesCreateWithoutCart_idInput[] | InvoicesUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCart_idInput | InvoicesCreateOrConnectWithoutCart_idInput[]
    createMany?: InvoicesCreateManyCart_idInputEnvelope
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCartsNestedInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    upsert?: UserUpsertWithoutCartsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartsInput, UserUpdateWithoutCartsInput>, UserUncheckedUpdateWithoutCartsInput>
  }

  export type StoresUpdateOneRequiredWithoutCartsNestedInput = {
    create?: XOR<StoresCreateWithoutCartsInput, StoresUncheckedCreateWithoutCartsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCartsInput
    upsert?: StoresUpsertWithoutCartsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutCartsInput, StoresUpdateWithoutCartsInput>, StoresUncheckedUpdateWithoutCartsInput>
  }

  export type Cart_itemsUpdateManyWithoutCart_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutCart_idInput, Cart_itemsUncheckedCreateWithoutCart_idInput> | Cart_itemsCreateWithoutCart_idInput[] | Cart_itemsUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutCart_idInput | Cart_itemsCreateOrConnectWithoutCart_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutCart_idInput | Cart_itemsUpsertWithWhereUniqueWithoutCart_idInput[]
    createMany?: Cart_itemsCreateManyCart_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutCart_idInput | Cart_itemsUpdateWithWhereUniqueWithoutCart_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutCart_idInput | Cart_itemsUpdateManyWithWhereWithoutCart_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type InvoicesUpdateManyWithoutCart_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutCart_idInput, InvoicesUncheckedCreateWithoutCart_idInput> | InvoicesCreateWithoutCart_idInput[] | InvoicesUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCart_idInput | InvoicesCreateOrConnectWithoutCart_idInput[]
    upsert?: InvoicesUpsertWithWhereUniqueWithoutCart_idInput | InvoicesUpsertWithWhereUniqueWithoutCart_idInput[]
    createMany?: InvoicesCreateManyCart_idInputEnvelope
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    update?: InvoicesUpdateWithWhereUniqueWithoutCart_idInput | InvoicesUpdateWithWhereUniqueWithoutCart_idInput[]
    updateMany?: InvoicesUpdateManyWithWhereWithoutCart_idInput | InvoicesUpdateManyWithWhereWithoutCart_idInput[]
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
  }

  export type Cart_itemsUncheckedUpdateManyWithoutCart_idNestedInput = {
    create?: XOR<Cart_itemsCreateWithoutCart_idInput, Cart_itemsUncheckedCreateWithoutCart_idInput> | Cart_itemsCreateWithoutCart_idInput[] | Cart_itemsUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: Cart_itemsCreateOrConnectWithoutCart_idInput | Cart_itemsCreateOrConnectWithoutCart_idInput[]
    upsert?: Cart_itemsUpsertWithWhereUniqueWithoutCart_idInput | Cart_itemsUpsertWithWhereUniqueWithoutCart_idInput[]
    createMany?: Cart_itemsCreateManyCart_idInputEnvelope
    set?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    disconnect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    delete?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    connect?: Cart_itemsWhereUniqueInput | Cart_itemsWhereUniqueInput[]
    update?: Cart_itemsUpdateWithWhereUniqueWithoutCart_idInput | Cart_itemsUpdateWithWhereUniqueWithoutCart_idInput[]
    updateMany?: Cart_itemsUpdateManyWithWhereWithoutCart_idInput | Cart_itemsUpdateManyWithWhereWithoutCart_idInput[]
    deleteMany?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
  }

  export type InvoicesUncheckedUpdateManyWithoutCart_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutCart_idInput, InvoicesUncheckedCreateWithoutCart_idInput> | InvoicesCreateWithoutCart_idInput[] | InvoicesUncheckedCreateWithoutCart_idInput[]
    connectOrCreate?: InvoicesCreateOrConnectWithoutCart_idInput | InvoicesCreateOrConnectWithoutCart_idInput[]
    upsert?: InvoicesUpsertWithWhereUniqueWithoutCart_idInput | InvoicesUpsertWithWhereUniqueWithoutCart_idInput[]
    createMany?: InvoicesCreateManyCart_idInputEnvelope
    set?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    disconnect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    delete?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    connect?: InvoicesWhereUniqueInput | InvoicesWhereUniqueInput[]
    update?: InvoicesUpdateWithWhereUniqueWithoutCart_idInput | InvoicesUpdateWithWhereUniqueWithoutCart_idInput[]
    updateMany?: InvoicesUpdateManyWithWhereWithoutCart_idInput | InvoicesUpdateManyWithWhereWithoutCart_idInput[]
    deleteMany?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
  }

  export type CartsCreateNestedOneWithoutCart_itemsInput = {
    create?: XOR<CartsCreateWithoutCart_itemsInput, CartsUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: CartsCreateOrConnectWithoutCart_itemsInput
    connect?: CartsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCart_itemsInput = {
    create?: XOR<UserCreateWithoutCart_itemsInput, UserUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCart_itemsInput
    connect?: UserWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutCart_itemsInput = {
    create?: XOR<StoresCreateWithoutCart_itemsInput, StoresUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCart_itemsInput
    connect?: StoresWhereUniqueInput
  }

  export type Variant_option_valuesCreateNestedOneWithoutCart_itemsInput = {
    create?: XOR<Variant_option_valuesCreateWithoutCart_itemsInput, Variant_option_valuesUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: Variant_option_valuesCreateOrConnectWithoutCart_itemsInput
    connect?: Variant_option_valuesWhereUniqueInput
  }

  export type CartsUpdateOneRequiredWithoutCart_itemsNestedInput = {
    create?: XOR<CartsCreateWithoutCart_itemsInput, CartsUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: CartsCreateOrConnectWithoutCart_itemsInput
    upsert?: CartsUpsertWithoutCart_itemsInput
    connect?: CartsWhereUniqueInput
    update?: XOR<XOR<CartsUpdateToOneWithWhereWithoutCart_itemsInput, CartsUpdateWithoutCart_itemsInput>, CartsUncheckedUpdateWithoutCart_itemsInput>
  }

  export type UserUpdateOneRequiredWithoutCart_itemsNestedInput = {
    create?: XOR<UserCreateWithoutCart_itemsInput, UserUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCart_itemsInput
    upsert?: UserUpsertWithoutCart_itemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCart_itemsInput, UserUpdateWithoutCart_itemsInput>, UserUncheckedUpdateWithoutCart_itemsInput>
  }

  export type StoresUpdateOneRequiredWithoutCart_itemsNestedInput = {
    create?: XOR<StoresCreateWithoutCart_itemsInput, StoresUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCart_itemsInput
    upsert?: StoresUpsertWithoutCart_itemsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutCart_itemsInput, StoresUpdateWithoutCart_itemsInput>, StoresUncheckedUpdateWithoutCart_itemsInput>
  }

  export type Variant_option_valuesUpdateOneRequiredWithoutCart_itemsNestedInput = {
    create?: XOR<Variant_option_valuesCreateWithoutCart_itemsInput, Variant_option_valuesUncheckedCreateWithoutCart_itemsInput>
    connectOrCreate?: Variant_option_valuesCreateOrConnectWithoutCart_itemsInput
    upsert?: Variant_option_valuesUpsertWithoutCart_itemsInput
    connect?: Variant_option_valuesWhereUniqueInput
    update?: XOR<XOR<Variant_option_valuesUpdateToOneWithWhereWithoutCart_itemsInput, Variant_option_valuesUpdateWithoutCart_itemsInput>, Variant_option_valuesUncheckedUpdateWithoutCart_itemsInput>
  }

  export type CartsCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CartsCreateWithoutInvoicesInput, CartsUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CartsCreateOrConnectWithoutInvoicesInput
    connect?: CartsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type CouriersCreateNestedOneWithoutInvoice_idInput = {
    create?: XOR<CouriersCreateWithoutInvoice_idInput, CouriersUncheckedCreateWithoutInvoice_idInput>
    connectOrCreate?: CouriersCreateOrConnectWithoutInvoice_idInput
    connect?: CouriersWhereUniqueInput
  }

  export type PaymentsCreateNestedOneWithoutInvoice_idInput = {
    create?: XOR<PaymentsCreateWithoutInvoice_idInput, PaymentsUncheckedCreateWithoutInvoice_idInput>
    connectOrCreate?: PaymentsCreateOrConnectWithoutInvoice_idInput
    connect?: PaymentsWhereUniqueInput
  }

  export type Confirmation_paymentCreateNestedManyWithoutInvoice_idInput = {
    create?: XOR<Confirmation_paymentCreateWithoutInvoice_idInput, Confirmation_paymentUncheckedCreateWithoutInvoice_idInput> | Confirmation_paymentCreateWithoutInvoice_idInput[] | Confirmation_paymentUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Confirmation_paymentCreateOrConnectWithoutInvoice_idInput | Confirmation_paymentCreateOrConnectWithoutInvoice_idInput[]
    createMany?: Confirmation_paymentCreateManyInvoice_idInputEnvelope
    connect?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
  }

  export type Invoice_historiesCreateNestedManyWithoutInvoice_idInput = {
    create?: XOR<Invoice_historiesCreateWithoutInvoice_idInput, Invoice_historiesUncheckedCreateWithoutInvoice_idInput> | Invoice_historiesCreateWithoutInvoice_idInput[] | Invoice_historiesUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Invoice_historiesCreateOrConnectWithoutInvoice_idInput | Invoice_historiesCreateOrConnectWithoutInvoice_idInput[]
    createMany?: Invoice_historiesCreateManyInvoice_idInputEnvelope
    connect?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
  }

  export type CouriersUncheckedCreateNestedOneWithoutInvoice_idInput = {
    create?: XOR<CouriersCreateWithoutInvoice_idInput, CouriersUncheckedCreateWithoutInvoice_idInput>
    connectOrCreate?: CouriersCreateOrConnectWithoutInvoice_idInput
    connect?: CouriersWhereUniqueInput
  }

  export type Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput = {
    create?: XOR<Confirmation_paymentCreateWithoutInvoice_idInput, Confirmation_paymentUncheckedCreateWithoutInvoice_idInput> | Confirmation_paymentCreateWithoutInvoice_idInput[] | Confirmation_paymentUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Confirmation_paymentCreateOrConnectWithoutInvoice_idInput | Confirmation_paymentCreateOrConnectWithoutInvoice_idInput[]
    createMany?: Confirmation_paymentCreateManyInvoice_idInputEnvelope
    connect?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
  }

  export type Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput = {
    create?: XOR<Invoice_historiesCreateWithoutInvoice_idInput, Invoice_historiesUncheckedCreateWithoutInvoice_idInput> | Invoice_historiesCreateWithoutInvoice_idInput[] | Invoice_historiesUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Invoice_historiesCreateOrConnectWithoutInvoice_idInput | Invoice_historiesCreateOrConnectWithoutInvoice_idInput[]
    createMany?: Invoice_historiesCreateManyInvoice_idInputEnvelope
    connect?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
  }

  export type CartsUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CartsCreateWithoutInvoicesInput, CartsUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CartsCreateOrConnectWithoutInvoicesInput
    upsert?: CartsUpsertWithoutInvoicesInput
    connect?: CartsWhereUniqueInput
    update?: XOR<XOR<CartsUpdateToOneWithWhereWithoutInvoicesInput, CartsUpdateWithoutInvoicesInput>, CartsUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type CouriersUpdateOneWithoutInvoice_idNestedInput = {
    create?: XOR<CouriersCreateWithoutInvoice_idInput, CouriersUncheckedCreateWithoutInvoice_idInput>
    connectOrCreate?: CouriersCreateOrConnectWithoutInvoice_idInput
    upsert?: CouriersUpsertWithoutInvoice_idInput
    disconnect?: CouriersWhereInput | boolean
    delete?: CouriersWhereInput | boolean
    connect?: CouriersWhereUniqueInput
    update?: XOR<XOR<CouriersUpdateToOneWithWhereWithoutInvoice_idInput, CouriersUpdateWithoutInvoice_idInput>, CouriersUncheckedUpdateWithoutInvoice_idInput>
  }

  export type PaymentsUpdateOneWithoutInvoice_idNestedInput = {
    create?: XOR<PaymentsCreateWithoutInvoice_idInput, PaymentsUncheckedCreateWithoutInvoice_idInput>
    connectOrCreate?: PaymentsCreateOrConnectWithoutInvoice_idInput
    upsert?: PaymentsUpsertWithoutInvoice_idInput
    disconnect?: PaymentsWhereInput | boolean
    delete?: PaymentsWhereInput | boolean
    connect?: PaymentsWhereUniqueInput
    update?: XOR<XOR<PaymentsUpdateToOneWithWhereWithoutInvoice_idInput, PaymentsUpdateWithoutInvoice_idInput>, PaymentsUncheckedUpdateWithoutInvoice_idInput>
  }

  export type Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput = {
    create?: XOR<Confirmation_paymentCreateWithoutInvoice_idInput, Confirmation_paymentUncheckedCreateWithoutInvoice_idInput> | Confirmation_paymentCreateWithoutInvoice_idInput[] | Confirmation_paymentUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Confirmation_paymentCreateOrConnectWithoutInvoice_idInput | Confirmation_paymentCreateOrConnectWithoutInvoice_idInput[]
    upsert?: Confirmation_paymentUpsertWithWhereUniqueWithoutInvoice_idInput | Confirmation_paymentUpsertWithWhereUniqueWithoutInvoice_idInput[]
    createMany?: Confirmation_paymentCreateManyInvoice_idInputEnvelope
    set?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    disconnect?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    delete?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    connect?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    update?: Confirmation_paymentUpdateWithWhereUniqueWithoutInvoice_idInput | Confirmation_paymentUpdateWithWhereUniqueWithoutInvoice_idInput[]
    updateMany?: Confirmation_paymentUpdateManyWithWhereWithoutInvoice_idInput | Confirmation_paymentUpdateManyWithWhereWithoutInvoice_idInput[]
    deleteMany?: Confirmation_paymentScalarWhereInput | Confirmation_paymentScalarWhereInput[]
  }

  export type Invoice_historiesUpdateManyWithoutInvoice_idNestedInput = {
    create?: XOR<Invoice_historiesCreateWithoutInvoice_idInput, Invoice_historiesUncheckedCreateWithoutInvoice_idInput> | Invoice_historiesCreateWithoutInvoice_idInput[] | Invoice_historiesUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Invoice_historiesCreateOrConnectWithoutInvoice_idInput | Invoice_historiesCreateOrConnectWithoutInvoice_idInput[]
    upsert?: Invoice_historiesUpsertWithWhereUniqueWithoutInvoice_idInput | Invoice_historiesUpsertWithWhereUniqueWithoutInvoice_idInput[]
    createMany?: Invoice_historiesCreateManyInvoice_idInputEnvelope
    set?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    disconnect?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    delete?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    connect?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    update?: Invoice_historiesUpdateWithWhereUniqueWithoutInvoice_idInput | Invoice_historiesUpdateWithWhereUniqueWithoutInvoice_idInput[]
    updateMany?: Invoice_historiesUpdateManyWithWhereWithoutInvoice_idInput | Invoice_historiesUpdateManyWithWhereWithoutInvoice_idInput[]
    deleteMany?: Invoice_historiesScalarWhereInput | Invoice_historiesScalarWhereInput[]
  }

  export type CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput = {
    create?: XOR<CouriersCreateWithoutInvoice_idInput, CouriersUncheckedCreateWithoutInvoice_idInput>
    connectOrCreate?: CouriersCreateOrConnectWithoutInvoice_idInput
    upsert?: CouriersUpsertWithoutInvoice_idInput
    disconnect?: CouriersWhereInput | boolean
    delete?: CouriersWhereInput | boolean
    connect?: CouriersWhereUniqueInput
    update?: XOR<XOR<CouriersUpdateToOneWithWhereWithoutInvoice_idInput, CouriersUpdateWithoutInvoice_idInput>, CouriersUncheckedUpdateWithoutInvoice_idInput>
  }

  export type Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput = {
    create?: XOR<Confirmation_paymentCreateWithoutInvoice_idInput, Confirmation_paymentUncheckedCreateWithoutInvoice_idInput> | Confirmation_paymentCreateWithoutInvoice_idInput[] | Confirmation_paymentUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Confirmation_paymentCreateOrConnectWithoutInvoice_idInput | Confirmation_paymentCreateOrConnectWithoutInvoice_idInput[]
    upsert?: Confirmation_paymentUpsertWithWhereUniqueWithoutInvoice_idInput | Confirmation_paymentUpsertWithWhereUniqueWithoutInvoice_idInput[]
    createMany?: Confirmation_paymentCreateManyInvoice_idInputEnvelope
    set?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    disconnect?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    delete?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    connect?: Confirmation_paymentWhereUniqueInput | Confirmation_paymentWhereUniqueInput[]
    update?: Confirmation_paymentUpdateWithWhereUniqueWithoutInvoice_idInput | Confirmation_paymentUpdateWithWhereUniqueWithoutInvoice_idInput[]
    updateMany?: Confirmation_paymentUpdateManyWithWhereWithoutInvoice_idInput | Confirmation_paymentUpdateManyWithWhereWithoutInvoice_idInput[]
    deleteMany?: Confirmation_paymentScalarWhereInput | Confirmation_paymentScalarWhereInput[]
  }

  export type Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput = {
    create?: XOR<Invoice_historiesCreateWithoutInvoice_idInput, Invoice_historiesUncheckedCreateWithoutInvoice_idInput> | Invoice_historiesCreateWithoutInvoice_idInput[] | Invoice_historiesUncheckedCreateWithoutInvoice_idInput[]
    connectOrCreate?: Invoice_historiesCreateOrConnectWithoutInvoice_idInput | Invoice_historiesCreateOrConnectWithoutInvoice_idInput[]
    upsert?: Invoice_historiesUpsertWithWhereUniqueWithoutInvoice_idInput | Invoice_historiesUpsertWithWhereUniqueWithoutInvoice_idInput[]
    createMany?: Invoice_historiesCreateManyInvoice_idInputEnvelope
    set?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    disconnect?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    delete?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    connect?: Invoice_historiesWhereUniqueInput | Invoice_historiesWhereUniqueInput[]
    update?: Invoice_historiesUpdateWithWhereUniqueWithoutInvoice_idInput | Invoice_historiesUpdateWithWhereUniqueWithoutInvoice_idInput[]
    updateMany?: Invoice_historiesUpdateManyWithWhereWithoutInvoice_idInput | Invoice_historiesUpdateManyWithWhereWithoutInvoice_idInput[]
    deleteMany?: Invoice_historiesScalarWhereInput | Invoice_historiesScalarWhereInput[]
  }

  export type InvoicesCreateNestedOneWithoutConfirmation_paymentInput = {
    create?: XOR<InvoicesCreateWithoutConfirmation_paymentInput, InvoicesUncheckedCreateWithoutConfirmation_paymentInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutConfirmation_paymentInput
    connect?: InvoicesWhereUniqueInput
  }

  export type InvoicesUpdateOneRequiredWithoutConfirmation_paymentNestedInput = {
    create?: XOR<InvoicesCreateWithoutConfirmation_paymentInput, InvoicesUncheckedCreateWithoutConfirmation_paymentInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutConfirmation_paymentInput
    upsert?: InvoicesUpsertWithoutConfirmation_paymentInput
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutConfirmation_paymentInput, InvoicesUpdateWithoutConfirmation_paymentInput>, InvoicesUncheckedUpdateWithoutConfirmation_paymentInput>
  }

  export type InvoicesCreateNestedOneWithoutInvoice_historiesInput = {
    create?: XOR<InvoicesCreateWithoutInvoice_historiesInput, InvoicesUncheckedCreateWithoutInvoice_historiesInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutInvoice_historiesInput
    connect?: InvoicesWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InvoicesUpdateOneRequiredWithoutInvoice_historiesNestedInput = {
    create?: XOR<InvoicesCreateWithoutInvoice_historiesInput, InvoicesUncheckedCreateWithoutInvoice_historiesInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutInvoice_historiesInput
    upsert?: InvoicesUpsertWithoutInvoice_historiesInput
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutInvoice_historiesInput, InvoicesUpdateWithoutInvoice_historiesInput>, InvoicesUncheckedUpdateWithoutInvoice_historiesInput>
  }

  export type InvoicesCreateNestedOneWithoutPayment_idInput = {
    create?: XOR<InvoicesCreateWithoutPayment_idInput, InvoicesUncheckedCreateWithoutPayment_idInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutPayment_idInput
    connect?: InvoicesWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoicesUncheckedCreateNestedOneWithoutPayment_idInput = {
    create?: XOR<InvoicesCreateWithoutPayment_idInput, InvoicesUncheckedCreateWithoutPayment_idInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutPayment_idInput
    connect?: InvoicesWhereUniqueInput
  }

  export type InvoicesUpdateOneWithoutPayment_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutPayment_idInput, InvoicesUncheckedCreateWithoutPayment_idInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutPayment_idInput
    upsert?: InvoicesUpsertWithoutPayment_idInput
    disconnect?: InvoicesWhereInput | boolean
    delete?: InvoicesWhereInput | boolean
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutPayment_idInput, InvoicesUpdateWithoutPayment_idInput>, InvoicesUncheckedUpdateWithoutPayment_idInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoicesUncheckedUpdateOneWithoutPayment_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutPayment_idInput, InvoicesUncheckedCreateWithoutPayment_idInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutPayment_idInput
    upsert?: InvoicesUpsertWithoutPayment_idInput
    disconnect?: InvoicesWhereInput | boolean
    delete?: InvoicesWhereInput | boolean
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutPayment_idInput, InvoicesUpdateWithoutPayment_idInput>, InvoicesUncheckedUpdateWithoutPayment_idInput>
  }

  export type InvoicesCreateNestedOneWithoutCourier_idInput = {
    create?: XOR<InvoicesCreateWithoutCourier_idInput, InvoicesUncheckedCreateWithoutCourier_idInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutCourier_idInput
    connect?: InvoicesWhereUniqueInput
  }

  export type InvoicesUpdateOneRequiredWithoutCourier_idNestedInput = {
    create?: XOR<InvoicesCreateWithoutCourier_idInput, InvoicesUncheckedCreateWithoutCourier_idInput>
    connectOrCreate?: InvoicesCreateOrConnectWithoutCourier_idInput
    upsert?: InvoicesUpsertWithoutCourier_idInput
    connect?: InvoicesWhereUniqueInput
    update?: XOR<XOR<InvoicesUpdateToOneWithWhereWithoutCourier_idInput, InvoicesUpdateWithoutCourier_idInput>, InvoicesUncheckedUpdateWithoutCourier_idInput>
  }

  export type StoresCreateNestedOneWithoutStores_on_decorationsInput = {
    create?: XOR<StoresCreateWithoutStores_on_decorationsInput, StoresUncheckedCreateWithoutStores_on_decorationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutStores_on_decorationsInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUpdateOneRequiredWithoutStores_on_decorationsNestedInput = {
    create?: XOR<StoresCreateWithoutStores_on_decorationsInput, StoresUncheckedCreateWithoutStores_on_decorationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutStores_on_decorationsInput
    upsert?: StoresUpsertWithoutStores_on_decorationsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutStores_on_decorationsInput, StoresUpdateWithoutStores_on_decorationsInput>, StoresUncheckedUpdateWithoutStores_on_decorationsInput>
  }

  export type StoresCreateNestedOneWithoutOperation_hoursInput = {
    create?: XOR<StoresCreateWithoutOperation_hoursInput, StoresUncheckedCreateWithoutOperation_hoursInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOperation_hoursInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUpdateOneRequiredWithoutOperation_hoursNestedInput = {
    create?: XOR<StoresCreateWithoutOperation_hoursInput, StoresUncheckedCreateWithoutOperation_hoursInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOperation_hoursInput
    upsert?: StoresUpsertWithoutOperation_hoursInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutOperation_hoursInput, StoresUpdateWithoutOperation_hoursInput>, StoresUncheckedUpdateWithoutOperation_hoursInput>
  }

  export type StoresCreateNestedOneWithoutMessage_templatesInput = {
    create?: XOR<StoresCreateWithoutMessage_templatesInput, StoresUncheckedCreateWithoutMessage_templatesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutMessage_templatesInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUpdateOneRequiredWithoutMessage_templatesNestedInput = {
    create?: XOR<StoresCreateWithoutMessage_templatesInput, StoresUncheckedCreateWithoutMessage_templatesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutMessage_templatesInput
    upsert?: StoresUpsertWithoutMessage_templatesInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutMessage_templatesInput, StoresUpdateWithoutMessage_templatesInput>, StoresUncheckedUpdateWithoutMessage_templatesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProfilesCreateWithoutUserInput = {
    id?: string
    user_id?: string | null
    locations: LocationCreateNestedOneWithoutProfile_idInput
  }

  export type ProfilesUncheckedCreateWithoutUserInput = {
    id?: string
    user_id?: string | null
    locationId: string
  }

  export type ProfilesCreateOrConnectWithoutUserInput = {
    where: ProfilesWhereUniqueInput
    create: XOR<ProfilesCreateWithoutUserInput, ProfilesUncheckedCreateWithoutUserInput>
  }

  export type RolesCreateWithoutUserInput = {
    id?: string
    name?: string | null
  }

  export type RolesUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
  }

  export type RolesCreateOrConnectWithoutUserInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
  }

  export type CartsCreateWithoutUser_idInput = {
    id?: string
    prices: number
    discount?: string | null
    store_id: StoresCreateNestedOneWithoutCartsInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutCart_idInput
    Invoices?: InvoicesCreateNestedManyWithoutCart_idInput
  }

  export type CartsUncheckedCreateWithoutUser_idInput = {
    id?: string
    prices: number
    discount?: string | null
    storesId: string
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutCart_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCart_idInput
  }

  export type CartsCreateOrConnectWithoutUser_idInput = {
    where: CartsWhereUniqueInput
    create: XOR<CartsCreateWithoutUser_idInput, CartsUncheckedCreateWithoutUser_idInput>
  }

  export type CartsCreateManyUser_idInputEnvelope = {
    data: CartsCreateManyUser_idInput | CartsCreateManyUser_idInput[]
    skipDuplicates?: boolean
  }

  export type Cart_itemsCreateWithoutUser_idInput = {
    id?: string
    qty: number
    price: number
    cart_id: CartsCreateNestedOneWithoutCart_itemsInput
    store_id: StoresCreateNestedOneWithoutCart_itemsInput
    variant_option_value_id: Variant_option_valuesCreateNestedOneWithoutCart_itemsInput
  }

  export type Cart_itemsUncheckedCreateWithoutUser_idInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    storesId: string
    variant_option_valuesId: string
  }

  export type Cart_itemsCreateOrConnectWithoutUser_idInput = {
    where: Cart_itemsWhereUniqueInput
    create: XOR<Cart_itemsCreateWithoutUser_idInput, Cart_itemsUncheckedCreateWithoutUser_idInput>
  }

  export type Cart_itemsCreateManyUser_idInputEnvelope = {
    data: Cart_itemsCreateManyUser_idInput | Cart_itemsCreateManyUser_idInput[]
    skipDuplicates?: boolean
  }

  export type InvoicesCreateWithoutUser_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cart_id: CartsCreateNestedOneWithoutInvoicesInput
    courier_id?: CouriersCreateNestedOneWithoutInvoice_idInput
    payment_id?: PaymentsCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateWithoutUser_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    paymentsId: string
    courier_id?: CouriersUncheckedCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesCreateOrConnectWithoutUser_idInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutUser_idInput, InvoicesUncheckedCreateWithoutUser_idInput>
  }

  export type InvoicesCreateManyUser_idInputEnvelope = {
    data: InvoicesCreateManyUser_idInput | InvoicesCreateManyUser_idInput[]
    skipDuplicates?: boolean
  }

  export type PaymentsCreateWithoutUser_idInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    invoicesId: string
    invoice_id?: InvoicesCreateNestedOneWithoutPayment_idInput
  }

  export type PaymentsUncheckedCreateWithoutUser_idInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    invoicesId: string
    invoice_id?: InvoicesUncheckedCreateNestedOneWithoutPayment_idInput
  }

  export type PaymentsCreateOrConnectWithoutUser_idInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutUser_idInput, PaymentsUncheckedCreateWithoutUser_idInput>
  }

  export type PaymentsCreateManyUser_idInputEnvelope = {
    data: PaymentsCreateManyUser_idInput | PaymentsCreateManyUser_idInput[]
    skipDuplicates?: boolean
  }

  export type ProfilesUpsertWithoutUserInput = {
    update: XOR<ProfilesUpdateWithoutUserInput, ProfilesUncheckedUpdateWithoutUserInput>
    create: XOR<ProfilesCreateWithoutUserInput, ProfilesUncheckedCreateWithoutUserInput>
    where?: ProfilesWhereInput
  }

  export type ProfilesUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfilesWhereInput
    data: XOR<ProfilesUpdateWithoutUserInput, ProfilesUncheckedUpdateWithoutUserInput>
  }

  export type ProfilesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUpdateOneRequiredWithoutProfile_idNestedInput
  }

  export type ProfilesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUpsertWithoutUserInput = {
    update: XOR<RolesUpdateWithoutUserInput, RolesUncheckedUpdateWithoutUserInput>
    create: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUserInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUserInput, RolesUncheckedUpdateWithoutUserInput>
  }

  export type RolesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartsUpsertWithWhereUniqueWithoutUser_idInput = {
    where: CartsWhereUniqueInput
    update: XOR<CartsUpdateWithoutUser_idInput, CartsUncheckedUpdateWithoutUser_idInput>
    create: XOR<CartsCreateWithoutUser_idInput, CartsUncheckedCreateWithoutUser_idInput>
  }

  export type CartsUpdateWithWhereUniqueWithoutUser_idInput = {
    where: CartsWhereUniqueInput
    data: XOR<CartsUpdateWithoutUser_idInput, CartsUncheckedUpdateWithoutUser_idInput>
  }

  export type CartsUpdateManyWithWhereWithoutUser_idInput = {
    where: CartsScalarWhereInput
    data: XOR<CartsUpdateManyMutationInput, CartsUncheckedUpdateManyWithoutUser_idInput>
  }

  export type CartsScalarWhereInput = {
    AND?: CartsScalarWhereInput | CartsScalarWhereInput[]
    OR?: CartsScalarWhereInput[]
    NOT?: CartsScalarWhereInput | CartsScalarWhereInput[]
    id?: StringFilter<"Carts"> | string
    prices?: IntFilter<"Carts"> | number
    discount?: StringNullableFilter<"Carts"> | string | null
    userId?: StringFilter<"Carts"> | string
    storesId?: StringFilter<"Carts"> | string
  }

  export type Cart_itemsUpsertWithWhereUniqueWithoutUser_idInput = {
    where: Cart_itemsWhereUniqueInput
    update: XOR<Cart_itemsUpdateWithoutUser_idInput, Cart_itemsUncheckedUpdateWithoutUser_idInput>
    create: XOR<Cart_itemsCreateWithoutUser_idInput, Cart_itemsUncheckedCreateWithoutUser_idInput>
  }

  export type Cart_itemsUpdateWithWhereUniqueWithoutUser_idInput = {
    where: Cart_itemsWhereUniqueInput
    data: XOR<Cart_itemsUpdateWithoutUser_idInput, Cart_itemsUncheckedUpdateWithoutUser_idInput>
  }

  export type Cart_itemsUpdateManyWithWhereWithoutUser_idInput = {
    where: Cart_itemsScalarWhereInput
    data: XOR<Cart_itemsUpdateManyMutationInput, Cart_itemsUncheckedUpdateManyWithoutUser_idInput>
  }

  export type Cart_itemsScalarWhereInput = {
    AND?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
    OR?: Cart_itemsScalarWhereInput[]
    NOT?: Cart_itemsScalarWhereInput | Cart_itemsScalarWhereInput[]
    id?: StringFilter<"Cart_items"> | string
    qty?: IntFilter<"Cart_items"> | number
    price?: IntFilter<"Cart_items"> | number
    cartsId?: StringFilter<"Cart_items"> | string
    userId?: StringFilter<"Cart_items"> | string
    storesId?: StringFilter<"Cart_items"> | string
    variant_option_valuesId?: StringFilter<"Cart_items"> | string
  }

  export type InvoicesUpsertWithWhereUniqueWithoutUser_idInput = {
    where: InvoicesWhereUniqueInput
    update: XOR<InvoicesUpdateWithoutUser_idInput, InvoicesUncheckedUpdateWithoutUser_idInput>
    create: XOR<InvoicesCreateWithoutUser_idInput, InvoicesUncheckedCreateWithoutUser_idInput>
  }

  export type InvoicesUpdateWithWhereUniqueWithoutUser_idInput = {
    where: InvoicesWhereUniqueInput
    data: XOR<InvoicesUpdateWithoutUser_idInput, InvoicesUncheckedUpdateWithoutUser_idInput>
  }

  export type InvoicesUpdateManyWithWhereWithoutUser_idInput = {
    where: InvoicesScalarWhereInput
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyWithoutUser_idInput>
  }

  export type InvoicesScalarWhereInput = {
    AND?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
    OR?: InvoicesScalarWhereInput[]
    NOT?: InvoicesScalarWhereInput | InvoicesScalarWhereInput[]
    id?: StringFilter<"Invoices"> | string
    prices?: IntFilter<"Invoices"> | number
    status?: BoolFilter<"Invoices"> | boolean
    receiver_longitude?: StringFilter<"Invoices"> | string
    receiver_latitude?: StringFilter<"Invoices"> | string
    receiver_district?: StringFilter<"Invoices"> | string
    receiver_phone?: StringFilter<"Invoices"> | string
    receiver_address?: StringFilter<"Invoices"> | string
    receiver_name?: StringFilter<"Invoices"> | string
    invoice_number?: StringFilter<"Invoices"> | string
    cartsId?: StringFilter<"Invoices"> | string
    userId?: StringFilter<"Invoices"> | string
    paymentsId?: StringFilter<"Invoices"> | string
  }

  export type PaymentsUpsertWithWhereUniqueWithoutUser_idInput = {
    where: PaymentsWhereUniqueInput
    update: XOR<PaymentsUpdateWithoutUser_idInput, PaymentsUncheckedUpdateWithoutUser_idInput>
    create: XOR<PaymentsCreateWithoutUser_idInput, PaymentsUncheckedCreateWithoutUser_idInput>
  }

  export type PaymentsUpdateWithWhereUniqueWithoutUser_idInput = {
    where: PaymentsWhereUniqueInput
    data: XOR<PaymentsUpdateWithoutUser_idInput, PaymentsUncheckedUpdateWithoutUser_idInput>
  }

  export type PaymentsUpdateManyWithWhereWithoutUser_idInput = {
    where: PaymentsScalarWhereInput
    data: XOR<PaymentsUpdateManyMutationInput, PaymentsUncheckedUpdateManyWithoutUser_idInput>
  }

  export type PaymentsScalarWhereInput = {
    AND?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    OR?: PaymentsScalarWhereInput[]
    NOT?: PaymentsScalarWhereInput | PaymentsScalarWhereInput[]
    id?: StringFilter<"Payments"> | string
    bank?: StringFilter<"Payments"> | string
    amount?: IntFilter<"Payments"> | number
    status?: BoolFilter<"Payments"> | boolean
    moota_transaction_id?: StringNullableFilter<"Payments"> | string | null
    userId?: StringFilter<"Payments"> | string
    invoicesId?: StringFilter<"Payments"> | string
  }

  export type LocationCreateWithoutProfile_idInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    store_id?: StoresCreateNestedOneWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutProfile_idInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    storesId?: string | null
  }

  export type LocationCreateOrConnectWithoutProfile_idInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProfile_idInput, LocationUncheckedCreateWithoutProfile_idInput>
  }

  export type UserCreateWithoutProfile_idInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    role_id?: RolesCreateNestedOneWithoutUserInput
    Carts?: CartsCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateWithoutProfile_idInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    rolesId?: string | null
    Carts?: CartsUncheckedCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserCreateOrConnectWithoutProfile_idInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfile_idInput, UserUncheckedCreateWithoutProfile_idInput>
  }

  export type UserCreateManyProfile_idInputEnvelope = {
    data: UserCreateManyProfile_idInput | UserCreateManyProfile_idInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutProfile_idInput = {
    update: XOR<LocationUpdateWithoutProfile_idInput, LocationUncheckedUpdateWithoutProfile_idInput>
    create: XOR<LocationCreateWithoutProfile_idInput, LocationUncheckedCreateWithoutProfile_idInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProfile_idInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProfile_idInput, LocationUncheckedUpdateWithoutProfile_idInput>
  }

  export type LocationUpdateWithoutProfile_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    store_id?: StoresUpdateOneWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutProfile_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutProfile_idInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProfile_idInput, UserUncheckedUpdateWithoutProfile_idInput>
    create: XOR<UserCreateWithoutProfile_idInput, UserUncheckedCreateWithoutProfile_idInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProfile_idInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProfile_idInput, UserUncheckedUpdateWithoutProfile_idInput>
  }

  export type UserUpdateManyWithWhereWithoutProfile_idInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProfile_idInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone_number?: StringFilter<"User"> | string
    fullname?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profilesId?: StringNullableFilter<"User"> | string | null
    rolesId?: StringNullableFilter<"User"> | string | null
  }

  export type UserCreateWithoutRole_idInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profile_id?: ProfilesCreateNestedOneWithoutUserInput
    Carts?: CartsCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateWithoutRole_idInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    Carts?: CartsUncheckedCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserCreateOrConnectWithoutRole_idInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRole_idInput, UserUncheckedCreateWithoutRole_idInput>
  }

  export type UserCreateManyRole_idInputEnvelope = {
    data: UserCreateManyRole_idInput | UserCreateManyRole_idInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRole_idInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRole_idInput, UserUncheckedUpdateWithoutRole_idInput>
    create: XOR<UserCreateWithoutRole_idInput, UserUncheckedCreateWithoutRole_idInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRole_idInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRole_idInput, UserUncheckedUpdateWithoutRole_idInput>
  }

  export type UserUpdateManyWithWhereWithoutRole_idInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRole_idInput>
  }

  export type VariantsCreateWithoutProduct_idInput = {
    id?: string
    name: string
    is_active?: boolean
    Variant_options?: Variant_optionsCreateNestedManyWithoutVariant_idInput
  }

  export type VariantsUncheckedCreateWithoutProduct_idInput = {
    id?: string
    name: string
    is_active?: boolean
    Variant_options?: Variant_optionsUncheckedCreateNestedManyWithoutVariant_idInput
  }

  export type VariantsCreateOrConnectWithoutProduct_idInput = {
    where: VariantsWhereUniqueInput
    create: XOR<VariantsCreateWithoutProduct_idInput, VariantsUncheckedCreateWithoutProduct_idInput>
  }

  export type StoresCreateWithoutProductInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutProductInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
  }

  export type CategoriesCreateWithoutProduct_idInput = {
    id?: string
    name: string
  }

  export type CategoriesUncheckedCreateWithoutProduct_idInput = {
    id?: string
    name: string
  }

  export type CategoriesCreateOrConnectWithoutProduct_idInput = {
    where: CategoriesWhereUniqueInput
    create: XOR<CategoriesCreateWithoutProduct_idInput, CategoriesUncheckedCreateWithoutProduct_idInput>
  }

  export type CategoriesCreateManyProduct_idInputEnvelope = {
    data: CategoriesCreateManyProduct_idInput | CategoriesCreateManyProduct_idInput[]
    skipDuplicates?: boolean
  }

  export type VariantsUpsertWithoutProduct_idInput = {
    update: XOR<VariantsUpdateWithoutProduct_idInput, VariantsUncheckedUpdateWithoutProduct_idInput>
    create: XOR<VariantsCreateWithoutProduct_idInput, VariantsUncheckedCreateWithoutProduct_idInput>
    where?: VariantsWhereInput
  }

  export type VariantsUpdateToOneWithWhereWithoutProduct_idInput = {
    where?: VariantsWhereInput
    data: XOR<VariantsUpdateWithoutProduct_idInput, VariantsUncheckedUpdateWithoutProduct_idInput>
  }

  export type VariantsUpdateWithoutProduct_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    Variant_options?: Variant_optionsUpdateManyWithoutVariant_idNestedInput
  }

  export type VariantsUncheckedUpdateWithoutProduct_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    Variant_options?: Variant_optionsUncheckedUpdateManyWithoutVariant_idNestedInput
  }

  export type StoresUpsertWithoutProductInput = {
    update: XOR<StoresUpdateWithoutProductInput, StoresUncheckedUpdateWithoutProductInput>
    create: XOR<StoresCreateWithoutProductInput, StoresUncheckedCreateWithoutProductInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutProductInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutProductInput, StoresUncheckedUpdateWithoutProductInput>
  }

  export type StoresUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type CategoriesUpsertWithWhereUniqueWithoutProduct_idInput = {
    where: CategoriesWhereUniqueInput
    update: XOR<CategoriesUpdateWithoutProduct_idInput, CategoriesUncheckedUpdateWithoutProduct_idInput>
    create: XOR<CategoriesCreateWithoutProduct_idInput, CategoriesUncheckedCreateWithoutProduct_idInput>
  }

  export type CategoriesUpdateWithWhereUniqueWithoutProduct_idInput = {
    where: CategoriesWhereUniqueInput
    data: XOR<CategoriesUpdateWithoutProduct_idInput, CategoriesUncheckedUpdateWithoutProduct_idInput>
  }

  export type CategoriesUpdateManyWithWhereWithoutProduct_idInput = {
    where: CategoriesScalarWhereInput
    data: XOR<CategoriesUpdateManyMutationInput, CategoriesUncheckedUpdateManyWithoutProduct_idInput>
  }

  export type CategoriesScalarWhereInput = {
    AND?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
    OR?: CategoriesScalarWhereInput[]
    NOT?: CategoriesScalarWhereInput | CategoriesScalarWhereInput[]
    id?: StringFilter<"Categories"> | string
    name?: StringFilter<"Categories"> | string
    productId?: StringFilter<"Categories"> | string
  }

  export type ProductCreateWithoutStore_idInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    variants?: VariantsCreateNestedOneWithoutProduct_idInput
    Categories?: CategoriesCreateNestedManyWithoutProduct_idInput
  }

  export type ProductUncheckedCreateWithoutStore_idInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    variants?: VariantsUncheckedCreateNestedOneWithoutProduct_idInput
    Categories?: CategoriesUncheckedCreateNestedManyWithoutProduct_idInput
  }

  export type ProductCreateOrConnectWithoutStore_idInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStore_idInput, ProductUncheckedCreateWithoutStore_idInput>
  }

  export type ProductCreateManyStore_idInputEnvelope = {
    data: ProductCreateManyStore_idInput | ProductCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type bank_accountsCreateWithoutStore_idInput = {
    id?: string
    bank: string
    acc_number: string
    acc_name: string
  }

  export type bank_accountsUncheckedCreateWithoutStore_idInput = {
    id?: string
    bank: string
    acc_number: string
    acc_name: string
  }

  export type bank_accountsCreateOrConnectWithoutStore_idInput = {
    where: bank_accountsWhereUniqueInput
    create: XOR<bank_accountsCreateWithoutStore_idInput, bank_accountsUncheckedCreateWithoutStore_idInput>
  }

  export type bank_accountsCreateManyStore_idInputEnvelope = {
    data: bank_accountsCreateManyStore_idInput | bank_accountsCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutStore_idInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    profile_id?: ProfilesCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateWithoutStore_idInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
    profile_id?: ProfilesUncheckedCreateNestedOneWithoutLocationsInput
  }

  export type LocationCreateOrConnectWithoutStore_idInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStore_idInput, LocationUncheckedCreateWithoutStore_idInput>
  }

  export type LocationCreateManyStore_idInputEnvelope = {
    data: LocationCreateManyStore_idInput | LocationCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type CartsCreateWithoutStore_idInput = {
    id?: string
    prices: number
    discount?: string | null
    user_id: UserCreateNestedOneWithoutCartsInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutCart_idInput
    Invoices?: InvoicesCreateNestedManyWithoutCart_idInput
  }

  export type CartsUncheckedCreateWithoutStore_idInput = {
    id?: string
    prices: number
    discount?: string | null
    userId: string
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutCart_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCart_idInput
  }

  export type CartsCreateOrConnectWithoutStore_idInput = {
    where: CartsWhereUniqueInput
    create: XOR<CartsCreateWithoutStore_idInput, CartsUncheckedCreateWithoutStore_idInput>
  }

  export type CartsCreateManyStore_idInputEnvelope = {
    data: CartsCreateManyStore_idInput | CartsCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type Cart_itemsCreateWithoutStore_idInput = {
    id?: string
    qty: number
    price: number
    cart_id: CartsCreateNestedOneWithoutCart_itemsInput
    user_id: UserCreateNestedOneWithoutCart_itemsInput
    variant_option_value_id: Variant_option_valuesCreateNestedOneWithoutCart_itemsInput
  }

  export type Cart_itemsUncheckedCreateWithoutStore_idInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    userId: string
    variant_option_valuesId: string
  }

  export type Cart_itemsCreateOrConnectWithoutStore_idInput = {
    where: Cart_itemsWhereUniqueInput
    create: XOR<Cart_itemsCreateWithoutStore_idInput, Cart_itemsUncheckedCreateWithoutStore_idInput>
  }

  export type Cart_itemsCreateManyStore_idInputEnvelope = {
    data: Cart_itemsCreateManyStore_idInput | Cart_itemsCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type Stores_on_decorationsCreateWithoutStore_idInput = {
    id?: string
  }

  export type Stores_on_decorationsUncheckedCreateWithoutStore_idInput = {
    id?: string
  }

  export type Stores_on_decorationsCreateOrConnectWithoutStore_idInput = {
    where: Stores_on_decorationsWhereUniqueInput
    create: XOR<Stores_on_decorationsCreateWithoutStore_idInput, Stores_on_decorationsUncheckedCreateWithoutStore_idInput>
  }

  export type Stores_on_decorationsCreateManyStore_idInputEnvelope = {
    data: Stores_on_decorationsCreateManyStore_idInput | Stores_on_decorationsCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type Operation_hoursCreateWithoutStore_idInput = {
    id?: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
  }

  export type Operation_hoursUncheckedCreateWithoutStore_idInput = {
    id?: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
  }

  export type Operation_hoursCreateOrConnectWithoutStore_idInput = {
    where: Operation_hoursWhereUniqueInput
    create: XOR<Operation_hoursCreateWithoutStore_idInput, Operation_hoursUncheckedCreateWithoutStore_idInput>
  }

  export type Operation_hoursCreateManyStore_idInputEnvelope = {
    data: Operation_hoursCreateManyStore_idInput | Operation_hoursCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type Message_templatesCreateWithoutStore_idInput = {
    id?: string
    name: string
    content: string
  }

  export type Message_templatesUncheckedCreateWithoutStore_idInput = {
    id?: string
    name: string
    content: string
  }

  export type Message_templatesCreateOrConnectWithoutStore_idInput = {
    where: Message_templatesWhereUniqueInput
    create: XOR<Message_templatesCreateWithoutStore_idInput, Message_templatesUncheckedCreateWithoutStore_idInput>
  }

  export type Message_templatesCreateManyStore_idInputEnvelope = {
    data: Message_templatesCreateManyStore_idInput | Message_templatesCreateManyStore_idInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutStore_idInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutStore_idInput, ProductUncheckedUpdateWithoutStore_idInput>
    create: XOR<ProductCreateWithoutStore_idInput, ProductUncheckedCreateWithoutStore_idInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutStore_idInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutStore_idInput, ProductUncheckedUpdateWithoutStore_idInput>
  }

  export type ProductUpdateManyWithWhereWithoutStore_idInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutStore_idInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    attachments?: StringFilter<"Product"> | string
    is_active?: BoolNullableFilter<"Product"> | boolean | null
    size?: StringNullableFilter<"Product"> | string | null
    minimum_order?: IntNullableFilter<"Product"> | number | null
    storesId?: StringNullableFilter<"Product"> | string | null
  }

  export type bank_accountsUpsertWithWhereUniqueWithoutStore_idInput = {
    where: bank_accountsWhereUniqueInput
    update: XOR<bank_accountsUpdateWithoutStore_idInput, bank_accountsUncheckedUpdateWithoutStore_idInput>
    create: XOR<bank_accountsCreateWithoutStore_idInput, bank_accountsUncheckedCreateWithoutStore_idInput>
  }

  export type bank_accountsUpdateWithWhereUniqueWithoutStore_idInput = {
    where: bank_accountsWhereUniqueInput
    data: XOR<bank_accountsUpdateWithoutStore_idInput, bank_accountsUncheckedUpdateWithoutStore_idInput>
  }

  export type bank_accountsUpdateManyWithWhereWithoutStore_idInput = {
    where: bank_accountsScalarWhereInput
    data: XOR<bank_accountsUpdateManyMutationInput, bank_accountsUncheckedUpdateManyWithoutStore_idInput>
  }

  export type bank_accountsScalarWhereInput = {
    AND?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
    OR?: bank_accountsScalarWhereInput[]
    NOT?: bank_accountsScalarWhereInput | bank_accountsScalarWhereInput[]
    id?: StringFilter<"bank_accounts"> | string
    bank?: StringFilter<"bank_accounts"> | string
    acc_number?: StringFilter<"bank_accounts"> | string
    acc_name?: StringFilter<"bank_accounts"> | string
    storesId?: StringNullableFilter<"bank_accounts"> | string | null
  }

  export type LocationUpsertWithWhereUniqueWithoutStore_idInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutStore_idInput, LocationUncheckedUpdateWithoutStore_idInput>
    create: XOR<LocationCreateWithoutStore_idInput, LocationUncheckedCreateWithoutStore_idInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutStore_idInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutStore_idInput, LocationUncheckedUpdateWithoutStore_idInput>
  }

  export type LocationUpdateManyWithWhereWithoutStore_idInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutStore_idInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    postal_code?: StringFilter<"Location"> | string
    city_district?: StringFilter<"Location"> | string
    is_main_location?: BoolNullableFilter<"Location"> | boolean | null
    longitude?: StringFilter<"Location"> | string
    latitude?: StringFilter<"Location"> | string
    storesId?: StringNullableFilter<"Location"> | string | null
  }

  export type CartsUpsertWithWhereUniqueWithoutStore_idInput = {
    where: CartsWhereUniqueInput
    update: XOR<CartsUpdateWithoutStore_idInput, CartsUncheckedUpdateWithoutStore_idInput>
    create: XOR<CartsCreateWithoutStore_idInput, CartsUncheckedCreateWithoutStore_idInput>
  }

  export type CartsUpdateWithWhereUniqueWithoutStore_idInput = {
    where: CartsWhereUniqueInput
    data: XOR<CartsUpdateWithoutStore_idInput, CartsUncheckedUpdateWithoutStore_idInput>
  }

  export type CartsUpdateManyWithWhereWithoutStore_idInput = {
    where: CartsScalarWhereInput
    data: XOR<CartsUpdateManyMutationInput, CartsUncheckedUpdateManyWithoutStore_idInput>
  }

  export type Cart_itemsUpsertWithWhereUniqueWithoutStore_idInput = {
    where: Cart_itemsWhereUniqueInput
    update: XOR<Cart_itemsUpdateWithoutStore_idInput, Cart_itemsUncheckedUpdateWithoutStore_idInput>
    create: XOR<Cart_itemsCreateWithoutStore_idInput, Cart_itemsUncheckedCreateWithoutStore_idInput>
  }

  export type Cart_itemsUpdateWithWhereUniqueWithoutStore_idInput = {
    where: Cart_itemsWhereUniqueInput
    data: XOR<Cart_itemsUpdateWithoutStore_idInput, Cart_itemsUncheckedUpdateWithoutStore_idInput>
  }

  export type Cart_itemsUpdateManyWithWhereWithoutStore_idInput = {
    where: Cart_itemsScalarWhereInput
    data: XOR<Cart_itemsUpdateManyMutationInput, Cart_itemsUncheckedUpdateManyWithoutStore_idInput>
  }

  export type Stores_on_decorationsUpsertWithWhereUniqueWithoutStore_idInput = {
    where: Stores_on_decorationsWhereUniqueInput
    update: XOR<Stores_on_decorationsUpdateWithoutStore_idInput, Stores_on_decorationsUncheckedUpdateWithoutStore_idInput>
    create: XOR<Stores_on_decorationsCreateWithoutStore_idInput, Stores_on_decorationsUncheckedCreateWithoutStore_idInput>
  }

  export type Stores_on_decorationsUpdateWithWhereUniqueWithoutStore_idInput = {
    where: Stores_on_decorationsWhereUniqueInput
    data: XOR<Stores_on_decorationsUpdateWithoutStore_idInput, Stores_on_decorationsUncheckedUpdateWithoutStore_idInput>
  }

  export type Stores_on_decorationsUpdateManyWithWhereWithoutStore_idInput = {
    where: Stores_on_decorationsScalarWhereInput
    data: XOR<Stores_on_decorationsUpdateManyMutationInput, Stores_on_decorationsUncheckedUpdateManyWithoutStore_idInput>
  }

  export type Stores_on_decorationsScalarWhereInput = {
    AND?: Stores_on_decorationsScalarWhereInput | Stores_on_decorationsScalarWhereInput[]
    OR?: Stores_on_decorationsScalarWhereInput[]
    NOT?: Stores_on_decorationsScalarWhereInput | Stores_on_decorationsScalarWhereInput[]
    id?: StringFilter<"Stores_on_decorations"> | string
    storesId?: StringFilter<"Stores_on_decorations"> | string
  }

  export type Operation_hoursUpsertWithWhereUniqueWithoutStore_idInput = {
    where: Operation_hoursWhereUniqueInput
    update: XOR<Operation_hoursUpdateWithoutStore_idInput, Operation_hoursUncheckedUpdateWithoutStore_idInput>
    create: XOR<Operation_hoursCreateWithoutStore_idInput, Operation_hoursUncheckedCreateWithoutStore_idInput>
  }

  export type Operation_hoursUpdateWithWhereUniqueWithoutStore_idInput = {
    where: Operation_hoursWhereUniqueInput
    data: XOR<Operation_hoursUpdateWithoutStore_idInput, Operation_hoursUncheckedUpdateWithoutStore_idInput>
  }

  export type Operation_hoursUpdateManyWithWhereWithoutStore_idInput = {
    where: Operation_hoursScalarWhereInput
    data: XOR<Operation_hoursUpdateManyMutationInput, Operation_hoursUncheckedUpdateManyWithoutStore_idInput>
  }

  export type Operation_hoursScalarWhereInput = {
    AND?: Operation_hoursScalarWhereInput | Operation_hoursScalarWhereInput[]
    OR?: Operation_hoursScalarWhereInput[]
    NOT?: Operation_hoursScalarWhereInput | Operation_hoursScalarWhereInput[]
    id?: StringFilter<"Operation_hours"> | string
    day?: StringFilter<"Operation_hours"> | string
    open_at?: StringFilter<"Operation_hours"> | string
    close_at?: StringFilter<"Operation_hours"> | string
    is_off?: BoolFilter<"Operation_hours"> | boolean
    storesId?: StringFilter<"Operation_hours"> | string
  }

  export type Message_templatesUpsertWithWhereUniqueWithoutStore_idInput = {
    where: Message_templatesWhereUniqueInput
    update: XOR<Message_templatesUpdateWithoutStore_idInput, Message_templatesUncheckedUpdateWithoutStore_idInput>
    create: XOR<Message_templatesCreateWithoutStore_idInput, Message_templatesUncheckedCreateWithoutStore_idInput>
  }

  export type Message_templatesUpdateWithWhereUniqueWithoutStore_idInput = {
    where: Message_templatesWhereUniqueInput
    data: XOR<Message_templatesUpdateWithoutStore_idInput, Message_templatesUncheckedUpdateWithoutStore_idInput>
  }

  export type Message_templatesUpdateManyWithWhereWithoutStore_idInput = {
    where: Message_templatesScalarWhereInput
    data: XOR<Message_templatesUpdateManyMutationInput, Message_templatesUncheckedUpdateManyWithoutStore_idInput>
  }

  export type Message_templatesScalarWhereInput = {
    AND?: Message_templatesScalarWhereInput | Message_templatesScalarWhereInput[]
    OR?: Message_templatesScalarWhereInput[]
    NOT?: Message_templatesScalarWhereInput | Message_templatesScalarWhereInput[]
    id?: StringFilter<"Message_templates"> | string
    name?: StringFilter<"Message_templates"> | string
    content?: StringFilter<"Message_templates"> | string
    storesId?: StringFilter<"Message_templates"> | string
  }

  export type StoresCreateWithoutBank_accountsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutBank_accountsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutBank_accountsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutBank_accountsInput, StoresUncheckedCreateWithoutBank_accountsInput>
  }

  export type StoresUpsertWithoutBank_accountsInput = {
    update: XOR<StoresUpdateWithoutBank_accountsInput, StoresUncheckedUpdateWithoutBank_accountsInput>
    create: XOR<StoresCreateWithoutBank_accountsInput, StoresUncheckedCreateWithoutBank_accountsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutBank_accountsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutBank_accountsInput, StoresUncheckedUpdateWithoutBank_accountsInput>
  }

  export type StoresUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutBank_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type StoresCreateWithoutLocationInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutLocationInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutLocationInput, StoresUncheckedCreateWithoutLocationInput>
  }

  export type ProfilesCreateWithoutLocationsInput = {
    id?: string
    user_id?: string | null
    User?: UserCreateNestedManyWithoutProfile_idInput
  }

  export type ProfilesUncheckedCreateWithoutLocationsInput = {
    id?: string
    user_id?: string | null
    User?: UserUncheckedCreateNestedManyWithoutProfile_idInput
  }

  export type ProfilesCreateOrConnectWithoutLocationsInput = {
    where: ProfilesWhereUniqueInput
    create: XOR<ProfilesCreateWithoutLocationsInput, ProfilesUncheckedCreateWithoutLocationsInput>
  }

  export type StoresUpsertWithoutLocationInput = {
    update: XOR<StoresUpdateWithoutLocationInput, StoresUncheckedUpdateWithoutLocationInput>
    create: XOR<StoresCreateWithoutLocationInput, StoresUncheckedCreateWithoutLocationInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutLocationInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutLocationInput, StoresUncheckedUpdateWithoutLocationInput>
  }

  export type StoresUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type ProfilesUpsertWithoutLocationsInput = {
    update: XOR<ProfilesUpdateWithoutLocationsInput, ProfilesUncheckedUpdateWithoutLocationsInput>
    create: XOR<ProfilesCreateWithoutLocationsInput, ProfilesUncheckedCreateWithoutLocationsInput>
    where?: ProfilesWhereInput
  }

  export type ProfilesUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ProfilesWhereInput
    data: XOR<ProfilesUpdateWithoutLocationsInput, ProfilesUncheckedUpdateWithoutLocationsInput>
  }

  export type ProfilesUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateManyWithoutProfile_idNestedInput
  }

  export type ProfilesUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUncheckedUpdateManyWithoutProfile_idNestedInput
  }

  export type Variant_optionsCreateWithoutVariant_option_valuesInput = {
    id?: string
    name: string
    variant_id: VariantsCreateNestedOneWithoutVariant_optionsInput
  }

  export type Variant_optionsUncheckedCreateWithoutVariant_option_valuesInput = {
    id?: string
    name: string
    variantsId: string
  }

  export type Variant_optionsCreateOrConnectWithoutVariant_option_valuesInput = {
    where: Variant_optionsWhereUniqueInput
    create: XOR<Variant_optionsCreateWithoutVariant_option_valuesInput, Variant_optionsUncheckedCreateWithoutVariant_option_valuesInput>
  }

  export type Cart_itemsCreateWithoutVariant_option_value_idInput = {
    id?: string
    qty: number
    price: number
    cart_id: CartsCreateNestedOneWithoutCart_itemsInput
    user_id: UserCreateNestedOneWithoutCart_itemsInput
    store_id: StoresCreateNestedOneWithoutCart_itemsInput
  }

  export type Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    userId: string
    storesId: string
  }

  export type Cart_itemsCreateOrConnectWithoutVariant_option_value_idInput = {
    where: Cart_itemsWhereUniqueInput
    create: XOR<Cart_itemsCreateWithoutVariant_option_value_idInput, Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput>
  }

  export type Cart_itemsCreateManyVariant_option_value_idInputEnvelope = {
    data: Cart_itemsCreateManyVariant_option_value_idInput | Cart_itemsCreateManyVariant_option_value_idInput[]
    skipDuplicates?: boolean
  }

  export type Variant_optionsUpsertWithoutVariant_option_valuesInput = {
    update: XOR<Variant_optionsUpdateWithoutVariant_option_valuesInput, Variant_optionsUncheckedUpdateWithoutVariant_option_valuesInput>
    create: XOR<Variant_optionsCreateWithoutVariant_option_valuesInput, Variant_optionsUncheckedCreateWithoutVariant_option_valuesInput>
    where?: Variant_optionsWhereInput
  }

  export type Variant_optionsUpdateToOneWithWhereWithoutVariant_option_valuesInput = {
    where?: Variant_optionsWhereInput
    data: XOR<Variant_optionsUpdateWithoutVariant_option_valuesInput, Variant_optionsUncheckedUpdateWithoutVariant_option_valuesInput>
  }

  export type Variant_optionsUpdateWithoutVariant_option_valuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    variant_id?: VariantsUpdateOneRequiredWithoutVariant_optionsNestedInput
  }

  export type Variant_optionsUncheckedUpdateWithoutVariant_option_valuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    variantsId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUpsertWithWhereUniqueWithoutVariant_option_value_idInput = {
    where: Cart_itemsWhereUniqueInput
    update: XOR<Cart_itemsUpdateWithoutVariant_option_value_idInput, Cart_itemsUncheckedUpdateWithoutVariant_option_value_idInput>
    create: XOR<Cart_itemsCreateWithoutVariant_option_value_idInput, Cart_itemsUncheckedCreateWithoutVariant_option_value_idInput>
  }

  export type Cart_itemsUpdateWithWhereUniqueWithoutVariant_option_value_idInput = {
    where: Cart_itemsWhereUniqueInput
    data: XOR<Cart_itemsUpdateWithoutVariant_option_value_idInput, Cart_itemsUncheckedUpdateWithoutVariant_option_value_idInput>
  }

  export type Cart_itemsUpdateManyWithWhereWithoutVariant_option_value_idInput = {
    where: Cart_itemsScalarWhereInput
    data: XOR<Cart_itemsUpdateManyMutationInput, Cart_itemsUncheckedUpdateManyWithoutVariant_option_value_idInput>
  }

  export type VariantsCreateWithoutVariant_optionsInput = {
    id?: string
    name: string
    is_active?: boolean
    product_id: ProductCreateNestedOneWithoutVariantsInput
  }

  export type VariantsUncheckedCreateWithoutVariant_optionsInput = {
    id?: string
    name: string
    is_active?: boolean
    productId: string
  }

  export type VariantsCreateOrConnectWithoutVariant_optionsInput = {
    where: VariantsWhereUniqueInput
    create: XOR<VariantsCreateWithoutVariant_optionsInput, VariantsUncheckedCreateWithoutVariant_optionsInput>
  }

  export type Variant_option_valuesCreateWithoutVariant_option_idInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    Cart_items?: Cart_itemsCreateNestedManyWithoutVariant_option_value_idInput
  }

  export type Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutVariant_option_value_idInput
  }

  export type Variant_option_valuesCreateOrConnectWithoutVariant_option_idInput = {
    where: Variant_option_valuesWhereUniqueInput
    create: XOR<Variant_option_valuesCreateWithoutVariant_option_idInput, Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput>
  }

  export type Variant_option_valuesCreateManyVariant_option_idInputEnvelope = {
    data: Variant_option_valuesCreateManyVariant_option_idInput | Variant_option_valuesCreateManyVariant_option_idInput[]
    skipDuplicates?: boolean
  }

  export type VariantsUpsertWithoutVariant_optionsInput = {
    update: XOR<VariantsUpdateWithoutVariant_optionsInput, VariantsUncheckedUpdateWithoutVariant_optionsInput>
    create: XOR<VariantsCreateWithoutVariant_optionsInput, VariantsUncheckedCreateWithoutVariant_optionsInput>
    where?: VariantsWhereInput
  }

  export type VariantsUpdateToOneWithWhereWithoutVariant_optionsInput = {
    where?: VariantsWhereInput
    data: XOR<VariantsUpdateWithoutVariant_optionsInput, VariantsUncheckedUpdateWithoutVariant_optionsInput>
  }

  export type VariantsUpdateWithoutVariant_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    product_id?: ProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type VariantsUncheckedUpdateWithoutVariant_optionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type Variant_option_valuesUpsertWithWhereUniqueWithoutVariant_option_idInput = {
    where: Variant_option_valuesWhereUniqueInput
    update: XOR<Variant_option_valuesUpdateWithoutVariant_option_idInput, Variant_option_valuesUncheckedUpdateWithoutVariant_option_idInput>
    create: XOR<Variant_option_valuesCreateWithoutVariant_option_idInput, Variant_option_valuesUncheckedCreateWithoutVariant_option_idInput>
  }

  export type Variant_option_valuesUpdateWithWhereUniqueWithoutVariant_option_idInput = {
    where: Variant_option_valuesWhereUniqueInput
    data: XOR<Variant_option_valuesUpdateWithoutVariant_option_idInput, Variant_option_valuesUncheckedUpdateWithoutVariant_option_idInput>
  }

  export type Variant_option_valuesUpdateManyWithWhereWithoutVariant_option_idInput = {
    where: Variant_option_valuesScalarWhereInput
    data: XOR<Variant_option_valuesUpdateManyMutationInput, Variant_option_valuesUncheckedUpdateManyWithoutVariant_option_idInput>
  }

  export type Variant_option_valuesScalarWhereInput = {
    AND?: Variant_option_valuesScalarWhereInput | Variant_option_valuesScalarWhereInput[]
    OR?: Variant_option_valuesScalarWhereInput[]
    NOT?: Variant_option_valuesScalarWhereInput | Variant_option_valuesScalarWhereInput[]
    id?: StringFilter<"Variant_option_values"> | string
    sku?: StringFilter<"Variant_option_values"> | string
    weight?: StringFilter<"Variant_option_values"> | string
    stock?: IntFilter<"Variant_option_values"> | number
    price?: IntFilter<"Variant_option_values"> | number
    is_active?: BoolFilter<"Variant_option_values"> | boolean
    variant_optionsId?: StringFilter<"Variant_option_values"> | string
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    store_id?: StoresCreateNestedOneWithoutProductInput
    Categories?: CategoriesCreateNestedManyWithoutProduct_idInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    storesId?: string | null
    Categories?: CategoriesUncheckedCreateNestedManyWithoutProduct_idInput
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type Variant_optionsCreateWithoutVariant_idInput = {
    id?: string
    name: string
    Variant_option_values?: Variant_option_valuesCreateNestedManyWithoutVariant_option_idInput
  }

  export type Variant_optionsUncheckedCreateWithoutVariant_idInput = {
    id?: string
    name: string
    Variant_option_values?: Variant_option_valuesUncheckedCreateNestedManyWithoutVariant_option_idInput
  }

  export type Variant_optionsCreateOrConnectWithoutVariant_idInput = {
    where: Variant_optionsWhereUniqueInput
    create: XOR<Variant_optionsCreateWithoutVariant_idInput, Variant_optionsUncheckedCreateWithoutVariant_idInput>
  }

  export type Variant_optionsCreateManyVariant_idInputEnvelope = {
    data: Variant_optionsCreateManyVariant_idInput | Variant_optionsCreateManyVariant_idInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    store_id?: StoresUpdateOneWithoutProductNestedInput
    Categories?: CategoriesUpdateManyWithoutProduct_idNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
    Categories?: CategoriesUncheckedUpdateManyWithoutProduct_idNestedInput
  }

  export type Variant_optionsUpsertWithWhereUniqueWithoutVariant_idInput = {
    where: Variant_optionsWhereUniqueInput
    update: XOR<Variant_optionsUpdateWithoutVariant_idInput, Variant_optionsUncheckedUpdateWithoutVariant_idInput>
    create: XOR<Variant_optionsCreateWithoutVariant_idInput, Variant_optionsUncheckedCreateWithoutVariant_idInput>
  }

  export type Variant_optionsUpdateWithWhereUniqueWithoutVariant_idInput = {
    where: Variant_optionsWhereUniqueInput
    data: XOR<Variant_optionsUpdateWithoutVariant_idInput, Variant_optionsUncheckedUpdateWithoutVariant_idInput>
  }

  export type Variant_optionsUpdateManyWithWhereWithoutVariant_idInput = {
    where: Variant_optionsScalarWhereInput
    data: XOR<Variant_optionsUpdateManyMutationInput, Variant_optionsUncheckedUpdateManyWithoutVariant_idInput>
  }

  export type Variant_optionsScalarWhereInput = {
    AND?: Variant_optionsScalarWhereInput | Variant_optionsScalarWhereInput[]
    OR?: Variant_optionsScalarWhereInput[]
    NOT?: Variant_optionsScalarWhereInput | Variant_optionsScalarWhereInput[]
    id?: StringFilter<"Variant_options"> | string
    name?: StringFilter<"Variant_options"> | string
    variantsId?: StringFilter<"Variant_options"> | string
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    variants?: VariantsCreateNestedOneWithoutProduct_idInput
    store_id?: StoresCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
    storesId?: string | null
    variants?: VariantsUncheckedCreateNestedOneWithoutProduct_idInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductUpsertWithoutCategoriesInput = {
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: VariantsUpdateOneWithoutProduct_idNestedInput
    store_id?: StoresUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    storesId?: NullableStringFieldUpdateOperationsInput | string | null
    variants?: VariantsUncheckedUpdateOneWithoutProduct_idNestedInput
  }

  export type UserCreateWithoutCartsInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profile_id?: ProfilesCreateNestedOneWithoutUserInput
    role_id?: RolesCreateNestedOneWithoutUserInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateWithoutCartsInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    rolesId?: string | null
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserCreateOrConnectWithoutCartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
  }

  export type StoresCreateWithoutCartsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutCartsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutCartsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutCartsInput, StoresUncheckedCreateWithoutCartsInput>
  }

  export type Cart_itemsCreateWithoutCart_idInput = {
    id?: string
    qty: number
    price: number
    user_id: UserCreateNestedOneWithoutCart_itemsInput
    store_id: StoresCreateNestedOneWithoutCart_itemsInput
    variant_option_value_id: Variant_option_valuesCreateNestedOneWithoutCart_itemsInput
  }

  export type Cart_itemsUncheckedCreateWithoutCart_idInput = {
    id?: string
    qty: number
    price: number
    userId: string
    storesId: string
    variant_option_valuesId: string
  }

  export type Cart_itemsCreateOrConnectWithoutCart_idInput = {
    where: Cart_itemsWhereUniqueInput
    create: XOR<Cart_itemsCreateWithoutCart_idInput, Cart_itemsUncheckedCreateWithoutCart_idInput>
  }

  export type Cart_itemsCreateManyCart_idInputEnvelope = {
    data: Cart_itemsCreateManyCart_idInput | Cart_itemsCreateManyCart_idInput[]
    skipDuplicates?: boolean
  }

  export type InvoicesCreateWithoutCart_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    user_id: UserCreateNestedOneWithoutInvoicesInput
    courier_id?: CouriersCreateNestedOneWithoutInvoice_idInput
    payment_id?: PaymentsCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateWithoutCart_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    userId: string
    paymentsId: string
    courier_id?: CouriersUncheckedCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesCreateOrConnectWithoutCart_idInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutCart_idInput, InvoicesUncheckedCreateWithoutCart_idInput>
  }

  export type InvoicesCreateManyCart_idInputEnvelope = {
    data: InvoicesCreateManyCart_idInput | InvoicesCreateManyCart_idInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartsInput = {
    update: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
  }

  export type UserUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutUserNestedInput
    role_id?: RolesUpdateOneWithoutUserNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type StoresUpsertWithoutCartsInput = {
    update: XOR<StoresUpdateWithoutCartsInput, StoresUncheckedUpdateWithoutCartsInput>
    create: XOR<StoresCreateWithoutCartsInput, StoresUncheckedCreateWithoutCartsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutCartsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutCartsInput, StoresUncheckedUpdateWithoutCartsInput>
  }

  export type StoresUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type Cart_itemsUpsertWithWhereUniqueWithoutCart_idInput = {
    where: Cart_itemsWhereUniqueInput
    update: XOR<Cart_itemsUpdateWithoutCart_idInput, Cart_itemsUncheckedUpdateWithoutCart_idInput>
    create: XOR<Cart_itemsCreateWithoutCart_idInput, Cart_itemsUncheckedCreateWithoutCart_idInput>
  }

  export type Cart_itemsUpdateWithWhereUniqueWithoutCart_idInput = {
    where: Cart_itemsWhereUniqueInput
    data: XOR<Cart_itemsUpdateWithoutCart_idInput, Cart_itemsUncheckedUpdateWithoutCart_idInput>
  }

  export type Cart_itemsUpdateManyWithWhereWithoutCart_idInput = {
    where: Cart_itemsScalarWhereInput
    data: XOR<Cart_itemsUpdateManyMutationInput, Cart_itemsUncheckedUpdateManyWithoutCart_idInput>
  }

  export type InvoicesUpsertWithWhereUniqueWithoutCart_idInput = {
    where: InvoicesWhereUniqueInput
    update: XOR<InvoicesUpdateWithoutCart_idInput, InvoicesUncheckedUpdateWithoutCart_idInput>
    create: XOR<InvoicesCreateWithoutCart_idInput, InvoicesUncheckedCreateWithoutCart_idInput>
  }

  export type InvoicesUpdateWithWhereUniqueWithoutCart_idInput = {
    where: InvoicesWhereUniqueInput
    data: XOR<InvoicesUpdateWithoutCart_idInput, InvoicesUncheckedUpdateWithoutCart_idInput>
  }

  export type InvoicesUpdateManyWithWhereWithoutCart_idInput = {
    where: InvoicesScalarWhereInput
    data: XOR<InvoicesUpdateManyMutationInput, InvoicesUncheckedUpdateManyWithoutCart_idInput>
  }

  export type CartsCreateWithoutCart_itemsInput = {
    id?: string
    prices: number
    discount?: string | null
    user_id: UserCreateNestedOneWithoutCartsInput
    store_id: StoresCreateNestedOneWithoutCartsInput
    Invoices?: InvoicesCreateNestedManyWithoutCart_idInput
  }

  export type CartsUncheckedCreateWithoutCart_itemsInput = {
    id?: string
    prices: number
    discount?: string | null
    userId: string
    storesId: string
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutCart_idInput
  }

  export type CartsCreateOrConnectWithoutCart_itemsInput = {
    where: CartsWhereUniqueInput
    create: XOR<CartsCreateWithoutCart_itemsInput, CartsUncheckedCreateWithoutCart_itemsInput>
  }

  export type UserCreateWithoutCart_itemsInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profile_id?: ProfilesCreateNestedOneWithoutUserInput
    role_id?: RolesCreateNestedOneWithoutUserInput
    Carts?: CartsCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateWithoutCart_itemsInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    rolesId?: string | null
    Carts?: CartsUncheckedCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserCreateOrConnectWithoutCart_itemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCart_itemsInput, UserUncheckedCreateWithoutCart_itemsInput>
  }

  export type StoresCreateWithoutCart_itemsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutCart_itemsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutCart_itemsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutCart_itemsInput, StoresUncheckedCreateWithoutCart_itemsInput>
  }

  export type Variant_option_valuesCreateWithoutCart_itemsInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    variant_option_id: Variant_optionsCreateNestedOneWithoutVariant_option_valuesInput
  }

  export type Variant_option_valuesUncheckedCreateWithoutCart_itemsInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
    variant_optionsId: string
  }

  export type Variant_option_valuesCreateOrConnectWithoutCart_itemsInput = {
    where: Variant_option_valuesWhereUniqueInput
    create: XOR<Variant_option_valuesCreateWithoutCart_itemsInput, Variant_option_valuesUncheckedCreateWithoutCart_itemsInput>
  }

  export type CartsUpsertWithoutCart_itemsInput = {
    update: XOR<CartsUpdateWithoutCart_itemsInput, CartsUncheckedUpdateWithoutCart_itemsInput>
    create: XOR<CartsCreateWithoutCart_itemsInput, CartsUncheckedCreateWithoutCart_itemsInput>
    where?: CartsWhereInput
  }

  export type CartsUpdateToOneWithWhereWithoutCart_itemsInput = {
    where?: CartsWhereInput
    data: XOR<CartsUpdateWithoutCart_itemsInput, CartsUncheckedUpdateWithoutCart_itemsInput>
  }

  export type CartsUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: UserUpdateOneRequiredWithoutCartsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCartsNestedInput
    Invoices?: InvoicesUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    Invoices?: InvoicesUncheckedUpdateManyWithoutCart_idNestedInput
  }

  export type UserUpsertWithoutCart_itemsInput = {
    update: XOR<UserUpdateWithoutCart_itemsInput, UserUncheckedUpdateWithoutCart_itemsInput>
    create: XOR<UserCreateWithoutCart_itemsInput, UserUncheckedCreateWithoutCart_itemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCart_itemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCart_itemsInput, UserUncheckedUpdateWithoutCart_itemsInput>
  }

  export type UserUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutUserNestedInput
    role_id?: RolesUpdateOneWithoutUserNestedInput
    Carts?: CartsUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
    Carts?: CartsUncheckedUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type StoresUpsertWithoutCart_itemsInput = {
    update: XOR<StoresUpdateWithoutCart_itemsInput, StoresUncheckedUpdateWithoutCart_itemsInput>
    create: XOR<StoresCreateWithoutCart_itemsInput, StoresUncheckedCreateWithoutCart_itemsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutCart_itemsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutCart_itemsInput, StoresUncheckedUpdateWithoutCart_itemsInput>
  }

  export type StoresUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type Variant_option_valuesUpsertWithoutCart_itemsInput = {
    update: XOR<Variant_option_valuesUpdateWithoutCart_itemsInput, Variant_option_valuesUncheckedUpdateWithoutCart_itemsInput>
    create: XOR<Variant_option_valuesCreateWithoutCart_itemsInput, Variant_option_valuesUncheckedCreateWithoutCart_itemsInput>
    where?: Variant_option_valuesWhereInput
  }

  export type Variant_option_valuesUpdateToOneWithWhereWithoutCart_itemsInput = {
    where?: Variant_option_valuesWhereInput
    data: XOR<Variant_option_valuesUpdateWithoutCart_itemsInput, Variant_option_valuesUncheckedUpdateWithoutCart_itemsInput>
  }

  export type Variant_option_valuesUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    variant_option_id?: Variant_optionsUpdateOneRequiredWithoutVariant_option_valuesNestedInput
  }

  export type Variant_option_valuesUncheckedUpdateWithoutCart_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    variant_optionsId?: StringFieldUpdateOperationsInput | string
  }

  export type CartsCreateWithoutInvoicesInput = {
    id?: string
    prices: number
    discount?: string | null
    user_id: UserCreateNestedOneWithoutCartsInput
    store_id: StoresCreateNestedOneWithoutCartsInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutCart_idInput
  }

  export type CartsUncheckedCreateWithoutInvoicesInput = {
    id?: string
    prices: number
    discount?: string | null
    userId: string
    storesId: string
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutCart_idInput
  }

  export type CartsCreateOrConnectWithoutInvoicesInput = {
    where: CartsWhereUniqueInput
    create: XOR<CartsCreateWithoutInvoicesInput, CartsUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutInvoicesInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profile_id?: ProfilesCreateNestedOneWithoutUserInput
    role_id?: RolesCreateNestedOneWithoutUserInput
    Carts?: CartsCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    rolesId?: string | null
    Carts?: CartsUncheckedCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput
    Payments?: PaymentsUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type CouriersCreateWithoutInvoice_idInput = {
    id?: string
    courier_code: string
    courier_service_name: string
    courier_service_code: string
    price: number
    order_id: string
  }

  export type CouriersUncheckedCreateWithoutInvoice_idInput = {
    id?: string
    courier_code: string
    courier_service_name: string
    courier_service_code: string
    price: number
    order_id: string
  }

  export type CouriersCreateOrConnectWithoutInvoice_idInput = {
    where: CouriersWhereUniqueInput
    create: XOR<CouriersCreateWithoutInvoice_idInput, CouriersUncheckedCreateWithoutInvoice_idInput>
  }

  export type PaymentsCreateWithoutInvoice_idInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    invoicesId: string
    user_id: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentsUncheckedCreateWithoutInvoice_idInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    userId: string
    invoicesId: string
  }

  export type PaymentsCreateOrConnectWithoutInvoice_idInput = {
    where: PaymentsWhereUniqueInput
    create: XOR<PaymentsCreateWithoutInvoice_idInput, PaymentsUncheckedCreateWithoutInvoice_idInput>
  }

  export type Confirmation_paymentCreateWithoutInvoice_idInput = {
    id?: string
    amount: number
    bank: string
  }

  export type Confirmation_paymentUncheckedCreateWithoutInvoice_idInput = {
    id?: string
    amount: number
    bank: string
  }

  export type Confirmation_paymentCreateOrConnectWithoutInvoice_idInput = {
    where: Confirmation_paymentWhereUniqueInput
    create: XOR<Confirmation_paymentCreateWithoutInvoice_idInput, Confirmation_paymentUncheckedCreateWithoutInvoice_idInput>
  }

  export type Confirmation_paymentCreateManyInvoice_idInputEnvelope = {
    data: Confirmation_paymentCreateManyInvoice_idInput | Confirmation_paymentCreateManyInvoice_idInput[]
    skipDuplicates?: boolean
  }

  export type Invoice_historiesCreateWithoutInvoice_idInput = {
    id?: string
    status?: boolean
    created_at?: Date | string | null
  }

  export type Invoice_historiesUncheckedCreateWithoutInvoice_idInput = {
    id?: string
    status?: boolean
    created_at?: Date | string | null
  }

  export type Invoice_historiesCreateOrConnectWithoutInvoice_idInput = {
    where: Invoice_historiesWhereUniqueInput
    create: XOR<Invoice_historiesCreateWithoutInvoice_idInput, Invoice_historiesUncheckedCreateWithoutInvoice_idInput>
  }

  export type Invoice_historiesCreateManyInvoice_idInputEnvelope = {
    data: Invoice_historiesCreateManyInvoice_idInput | Invoice_historiesCreateManyInvoice_idInput[]
    skipDuplicates?: boolean
  }

  export type CartsUpsertWithoutInvoicesInput = {
    update: XOR<CartsUpdateWithoutInvoicesInput, CartsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CartsCreateWithoutInvoicesInput, CartsUncheckedCreateWithoutInvoicesInput>
    where?: CartsWhereInput
  }

  export type CartsUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CartsWhereInput
    data: XOR<CartsUpdateWithoutInvoicesInput, CartsUncheckedUpdateWithoutInvoicesInput>
  }

  export type CartsUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: UserUpdateOneRequiredWithoutCartsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCartsNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutCart_idNestedInput
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutUserNestedInput
    role_id?: RolesUpdateOneWithoutUserNestedInput
    Carts?: CartsUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
    Carts?: CartsUncheckedUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type CouriersUpsertWithoutInvoice_idInput = {
    update: XOR<CouriersUpdateWithoutInvoice_idInput, CouriersUncheckedUpdateWithoutInvoice_idInput>
    create: XOR<CouriersCreateWithoutInvoice_idInput, CouriersUncheckedCreateWithoutInvoice_idInput>
    where?: CouriersWhereInput
  }

  export type CouriersUpdateToOneWithWhereWithoutInvoice_idInput = {
    where?: CouriersWhereInput
    data: XOR<CouriersUpdateWithoutInvoice_idInput, CouriersUncheckedUpdateWithoutInvoice_idInput>
  }

  export type CouriersUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier_code?: StringFieldUpdateOperationsInput | string
    courier_service_name?: StringFieldUpdateOperationsInput | string
    courier_service_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type CouriersUncheckedUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    courier_code?: StringFieldUpdateOperationsInput | string
    courier_service_name?: StringFieldUpdateOperationsInput | string
    courier_service_code?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    order_id?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentsUpsertWithoutInvoice_idInput = {
    update: XOR<PaymentsUpdateWithoutInvoice_idInput, PaymentsUncheckedUpdateWithoutInvoice_idInput>
    create: XOR<PaymentsCreateWithoutInvoice_idInput, PaymentsUncheckedCreateWithoutInvoice_idInput>
    where?: PaymentsWhereInput
  }

  export type PaymentsUpdateToOneWithWhereWithoutInvoice_idInput = {
    where?: PaymentsWhereInput
    data: XOR<PaymentsUpdateWithoutInvoice_idInput, PaymentsUncheckedUpdateWithoutInvoice_idInput>
  }

  export type PaymentsUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
    user_id?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentUpsertWithWhereUniqueWithoutInvoice_idInput = {
    where: Confirmation_paymentWhereUniqueInput
    update: XOR<Confirmation_paymentUpdateWithoutInvoice_idInput, Confirmation_paymentUncheckedUpdateWithoutInvoice_idInput>
    create: XOR<Confirmation_paymentCreateWithoutInvoice_idInput, Confirmation_paymentUncheckedCreateWithoutInvoice_idInput>
  }

  export type Confirmation_paymentUpdateWithWhereUniqueWithoutInvoice_idInput = {
    where: Confirmation_paymentWhereUniqueInput
    data: XOR<Confirmation_paymentUpdateWithoutInvoice_idInput, Confirmation_paymentUncheckedUpdateWithoutInvoice_idInput>
  }

  export type Confirmation_paymentUpdateManyWithWhereWithoutInvoice_idInput = {
    where: Confirmation_paymentScalarWhereInput
    data: XOR<Confirmation_paymentUpdateManyMutationInput, Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idInput>
  }

  export type Confirmation_paymentScalarWhereInput = {
    AND?: Confirmation_paymentScalarWhereInput | Confirmation_paymentScalarWhereInput[]
    OR?: Confirmation_paymentScalarWhereInput[]
    NOT?: Confirmation_paymentScalarWhereInput | Confirmation_paymentScalarWhereInput[]
    id?: StringFilter<"Confirmation_payment"> | string
    amount?: IntFilter<"Confirmation_payment"> | number
    bank?: StringFilter<"Confirmation_payment"> | string
    invoicesId?: StringFilter<"Confirmation_payment"> | string
  }

  export type Invoice_historiesUpsertWithWhereUniqueWithoutInvoice_idInput = {
    where: Invoice_historiesWhereUniqueInput
    update: XOR<Invoice_historiesUpdateWithoutInvoice_idInput, Invoice_historiesUncheckedUpdateWithoutInvoice_idInput>
    create: XOR<Invoice_historiesCreateWithoutInvoice_idInput, Invoice_historiesUncheckedCreateWithoutInvoice_idInput>
  }

  export type Invoice_historiesUpdateWithWhereUniqueWithoutInvoice_idInput = {
    where: Invoice_historiesWhereUniqueInput
    data: XOR<Invoice_historiesUpdateWithoutInvoice_idInput, Invoice_historiesUncheckedUpdateWithoutInvoice_idInput>
  }

  export type Invoice_historiesUpdateManyWithWhereWithoutInvoice_idInput = {
    where: Invoice_historiesScalarWhereInput
    data: XOR<Invoice_historiesUpdateManyMutationInput, Invoice_historiesUncheckedUpdateManyWithoutInvoice_idInput>
  }

  export type Invoice_historiesScalarWhereInput = {
    AND?: Invoice_historiesScalarWhereInput | Invoice_historiesScalarWhereInput[]
    OR?: Invoice_historiesScalarWhereInput[]
    NOT?: Invoice_historiesScalarWhereInput | Invoice_historiesScalarWhereInput[]
    id?: StringFilter<"Invoice_histories"> | string
    status?: BoolFilter<"Invoice_histories"> | boolean
    created_at?: DateTimeNullableFilter<"Invoice_histories"> | Date | string | null
    invoicesId?: StringFilter<"Invoice_histories"> | string
  }

  export type InvoicesCreateWithoutConfirmation_paymentInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cart_id: CartsCreateNestedOneWithoutInvoicesInput
    user_id: UserCreateNestedOneWithoutInvoicesInput
    courier_id?: CouriersCreateNestedOneWithoutInvoice_idInput
    payment_id?: PaymentsCreateNestedOneWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateWithoutConfirmation_paymentInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    paymentsId: string
    courier_id?: CouriersUncheckedCreateNestedOneWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesCreateOrConnectWithoutConfirmation_paymentInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutConfirmation_paymentInput, InvoicesUncheckedCreateWithoutConfirmation_paymentInput>
  }

  export type InvoicesUpsertWithoutConfirmation_paymentInput = {
    update: XOR<InvoicesUpdateWithoutConfirmation_paymentInput, InvoicesUncheckedUpdateWithoutConfirmation_paymentInput>
    create: XOR<InvoicesCreateWithoutConfirmation_paymentInput, InvoicesUncheckedCreateWithoutConfirmation_paymentInput>
    where?: InvoicesWhereInput
  }

  export type InvoicesUpdateToOneWithWhereWithoutConfirmation_paymentInput = {
    where?: InvoicesWhereInput
    data: XOR<InvoicesUpdateWithoutConfirmation_paymentInput, InvoicesUncheckedUpdateWithoutConfirmation_paymentInput>
  }

  export type InvoicesUpdateWithoutConfirmation_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cart_id?: CartsUpdateOneRequiredWithoutInvoicesNestedInput
    user_id?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    courier_id?: CouriersUpdateOneWithoutInvoice_idNestedInput
    payment_id?: PaymentsUpdateOneWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutConfirmation_paymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
    courier_id?: CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesCreateWithoutInvoice_historiesInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cart_id: CartsCreateNestedOneWithoutInvoicesInput
    user_id: UserCreateNestedOneWithoutInvoicesInput
    courier_id?: CouriersCreateNestedOneWithoutInvoice_idInput
    payment_id?: PaymentsCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateWithoutInvoice_historiesInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    paymentsId: string
    courier_id?: CouriersUncheckedCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesCreateOrConnectWithoutInvoice_historiesInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutInvoice_historiesInput, InvoicesUncheckedCreateWithoutInvoice_historiesInput>
  }

  export type InvoicesUpsertWithoutInvoice_historiesInput = {
    update: XOR<InvoicesUpdateWithoutInvoice_historiesInput, InvoicesUncheckedUpdateWithoutInvoice_historiesInput>
    create: XOR<InvoicesCreateWithoutInvoice_historiesInput, InvoicesUncheckedCreateWithoutInvoice_historiesInput>
    where?: InvoicesWhereInput
  }

  export type InvoicesUpdateToOneWithWhereWithoutInvoice_historiesInput = {
    where?: InvoicesWhereInput
    data: XOR<InvoicesUpdateWithoutInvoice_historiesInput, InvoicesUncheckedUpdateWithoutInvoice_historiesInput>
  }

  export type InvoicesUpdateWithoutInvoice_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cart_id?: CartsUpdateOneRequiredWithoutInvoicesNestedInput
    user_id?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    courier_id?: CouriersUpdateOneWithoutInvoice_idNestedInput
    payment_id?: PaymentsUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutInvoice_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
    courier_id?: CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesCreateWithoutPayment_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cart_id: CartsCreateNestedOneWithoutInvoicesInput
    user_id: UserCreateNestedOneWithoutInvoicesInput
    courier_id?: CouriersCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateWithoutPayment_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    courier_id?: CouriersUncheckedCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesCreateOrConnectWithoutPayment_idInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutPayment_idInput, InvoicesUncheckedCreateWithoutPayment_idInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profile_id?: ProfilesCreateNestedOneWithoutUserInput
    role_id?: RolesCreateNestedOneWithoutUserInput
    Carts?: CartsCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesCreateNestedManyWithoutUser_idInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
    rolesId?: string | null
    Carts?: CartsUncheckedCreateNestedManyWithoutUser_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutUser_idInput
    Invoices?: InvoicesUncheckedCreateNestedManyWithoutUser_idInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoicesUpsertWithoutPayment_idInput = {
    update: XOR<InvoicesUpdateWithoutPayment_idInput, InvoicesUncheckedUpdateWithoutPayment_idInput>
    create: XOR<InvoicesCreateWithoutPayment_idInput, InvoicesUncheckedCreateWithoutPayment_idInput>
    where?: InvoicesWhereInput
  }

  export type InvoicesUpdateToOneWithWhereWithoutPayment_idInput = {
    where?: InvoicesWhereInput
    data: XOR<InvoicesUpdateWithoutPayment_idInput, InvoicesUncheckedUpdateWithoutPayment_idInput>
  }

  export type InvoicesUpdateWithoutPayment_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cart_id?: CartsUpdateOneRequiredWithoutInvoicesNestedInput
    user_id?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    courier_id?: CouriersUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutPayment_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courier_id?: CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutUserNestedInput
    role_id?: RolesUpdateOneWithoutUserNestedInput
    Carts?: CartsUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
    Carts?: CartsUncheckedUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type InvoicesCreateWithoutCourier_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cart_id: CartsCreateNestedOneWithoutInvoicesInput
    user_id: UserCreateNestedOneWithoutInvoicesInput
    payment_id?: PaymentsCreateNestedOneWithoutInvoice_idInput
    Confirmation_payment?: Confirmation_paymentCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesUncheckedCreateWithoutCourier_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    userId: string
    paymentsId: string
    Confirmation_payment?: Confirmation_paymentUncheckedCreateNestedManyWithoutInvoice_idInput
    Invoice_histories?: Invoice_historiesUncheckedCreateNestedManyWithoutInvoice_idInput
  }

  export type InvoicesCreateOrConnectWithoutCourier_idInput = {
    where: InvoicesWhereUniqueInput
    create: XOR<InvoicesCreateWithoutCourier_idInput, InvoicesUncheckedCreateWithoutCourier_idInput>
  }

  export type InvoicesUpsertWithoutCourier_idInput = {
    update: XOR<InvoicesUpdateWithoutCourier_idInput, InvoicesUncheckedUpdateWithoutCourier_idInput>
    create: XOR<InvoicesCreateWithoutCourier_idInput, InvoicesUncheckedCreateWithoutCourier_idInput>
    where?: InvoicesWhereInput
  }

  export type InvoicesUpdateToOneWithWhereWithoutCourier_idInput = {
    where?: InvoicesWhereInput
    data: XOR<InvoicesUpdateWithoutCourier_idInput, InvoicesUncheckedUpdateWithoutCourier_idInput>
  }

  export type InvoicesUpdateWithoutCourier_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cart_id?: CartsUpdateOneRequiredWithoutInvoicesNestedInput
    user_id?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    payment_id?: PaymentsUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutCourier_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
    Confirmation_payment?: Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type StoresCreateWithoutStores_on_decorationsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutStores_on_decorationsInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutStores_on_decorationsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutStores_on_decorationsInput, StoresUncheckedCreateWithoutStores_on_decorationsInput>
  }

  export type StoresUpsertWithoutStores_on_decorationsInput = {
    update: XOR<StoresUpdateWithoutStores_on_decorationsInput, StoresUncheckedUpdateWithoutStores_on_decorationsInput>
    create: XOR<StoresCreateWithoutStores_on_decorationsInput, StoresUncheckedCreateWithoutStores_on_decorationsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutStores_on_decorationsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutStores_on_decorationsInput, StoresUncheckedUpdateWithoutStores_on_decorationsInput>
  }

  export type StoresUpdateWithoutStores_on_decorationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutStores_on_decorationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type StoresCreateWithoutOperation_hoursInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutOperation_hoursInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Message_templates?: Message_templatesUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutOperation_hoursInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutOperation_hoursInput, StoresUncheckedCreateWithoutOperation_hoursInput>
  }

  export type StoresUpsertWithoutOperation_hoursInput = {
    update: XOR<StoresUpdateWithoutOperation_hoursInput, StoresUncheckedUpdateWithoutOperation_hoursInput>
    create: XOR<StoresCreateWithoutOperation_hoursInput, StoresUncheckedCreateWithoutOperation_hoursInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutOperation_hoursInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutOperation_hoursInput, StoresUncheckedUpdateWithoutOperation_hoursInput>
  }

  export type StoresUpdateWithoutOperation_hoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutOperation_hoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Message_templates?: Message_templatesUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type StoresCreateWithoutMessage_templatesInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsCreateNestedManyWithoutStore_idInput
    Location?: LocationCreateNestedManyWithoutStore_idInput
    Carts?: CartsCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursCreateNestedManyWithoutStore_idInput
  }

  export type StoresUncheckedCreateWithoutMessage_templatesInput = {
    id?: string
    name: string
    slogan?: string | null
    description?: string | null
    domain?: string | null
    logo_attachment?: string | null
    banner_attachment?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutStore_idInput
    bank_accounts?: bank_accountsUncheckedCreateNestedManyWithoutStore_idInput
    Location?: LocationUncheckedCreateNestedManyWithoutStore_idInput
    Carts?: CartsUncheckedCreateNestedManyWithoutStore_idInput
    Cart_items?: Cart_itemsUncheckedCreateNestedManyWithoutStore_idInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedCreateNestedManyWithoutStore_idInput
    Operation_hours?: Operation_hoursUncheckedCreateNestedManyWithoutStore_idInput
  }

  export type StoresCreateOrConnectWithoutMessage_templatesInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutMessage_templatesInput, StoresUncheckedCreateWithoutMessage_templatesInput>
  }

  export type StoresUpsertWithoutMessage_templatesInput = {
    update: XOR<StoresUpdateWithoutMessage_templatesInput, StoresUncheckedUpdateWithoutMessage_templatesInput>
    create: XOR<StoresCreateWithoutMessage_templatesInput, StoresUncheckedCreateWithoutMessage_templatesInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutMessage_templatesInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutMessage_templatesInput, StoresUncheckedUpdateWithoutMessage_templatesInput>
  }

  export type StoresUpdateWithoutMessage_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUpdateManyWithoutStore_idNestedInput
    Location?: LocationUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUpdateManyWithoutStore_idNestedInput
  }

  export type StoresUncheckedUpdateWithoutMessage_templatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slogan?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    logo_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    banner_attachment?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutStore_idNestedInput
    bank_accounts?: bank_accountsUncheckedUpdateManyWithoutStore_idNestedInput
    Location?: LocationUncheckedUpdateManyWithoutStore_idNestedInput
    Carts?: CartsUncheckedUpdateManyWithoutStore_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutStore_idNestedInput
    Stores_on_decorations?: Stores_on_decorationsUncheckedUpdateManyWithoutStore_idNestedInput
    Operation_hours?: Operation_hoursUncheckedUpdateManyWithoutStore_idNestedInput
  }

  export type CartsCreateManyUser_idInput = {
    id?: string
    prices: number
    discount?: string | null
    storesId: string
  }

  export type Cart_itemsCreateManyUser_idInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    storesId: string
    variant_option_valuesId: string
  }

  export type InvoicesCreateManyUser_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    cartsId: string
    paymentsId: string
  }

  export type PaymentsCreateManyUser_idInput = {
    id?: string
    bank: string
    amount: number
    status?: boolean
    moota_transaction_id?: string | null
    invoicesId: string
  }

  export type CartsUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: StoresUpdateOneRequiredWithoutCartsNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutCart_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    storesId?: StringFieldUpdateOperationsInput | string
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutCart_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateManyWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cart_id?: CartsUpdateOneRequiredWithoutCart_itemsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCart_itemsNestedInput
    variant_option_value_id?: Variant_option_valuesUpdateOneRequiredWithoutCart_itemsNestedInput
  }

  export type Cart_itemsUncheckedUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUncheckedUpdateManyWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoicesUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cart_id?: CartsUpdateOneRequiredWithoutInvoicesNestedInput
    courier_id?: CouriersUpdateOneWithoutInvoice_idNestedInput
    payment_id?: PaymentsUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
    courier_id?: CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateManyWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    cartsId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentsUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
    invoice_id?: InvoicesUpdateOneWithoutPayment_idNestedInput
  }

  export type PaymentsUncheckedUpdateWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
    invoice_id?: InvoicesUncheckedUpdateOneWithoutPayment_idNestedInput
  }

  export type PaymentsUncheckedUpdateManyWithoutUser_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    moota_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoicesId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyProfile_idInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    rolesId?: string | null
  }

  export type UserUpdateWithoutProfile_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role_id?: RolesUpdateOneWithoutUserNestedInput
    Carts?: CartsUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateWithoutProfile_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
    Carts?: CartsUncheckedUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProfile_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    rolesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyRole_idInput = {
    id: string
    email: string
    phone_number: string
    fullname: string
    password: string
    profilesId?: string | null
  }

  export type UserUpdateWithoutRole_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutUserNestedInput
    Carts?: CartsUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateWithoutRole_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
    Carts?: CartsUncheckedUpdateManyWithoutUser_idNestedInput
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutUser_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutUser_idNestedInput
    Payments?: PaymentsUncheckedUpdateManyWithoutUser_idNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRole_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profilesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoriesCreateManyProduct_idInput = {
    id?: string
    name: string
  }

  export type CategoriesUpdateWithoutProduct_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateWithoutProduct_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriesUncheckedUpdateManyWithoutProduct_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyStore_idInput = {
    id?: string
    name: string
    description?: string | null
    attachments: string
    is_active?: boolean | null
    size?: string | null
    minimum_order?: number | null
  }

  export type bank_accountsCreateManyStore_idInput = {
    id?: string
    bank: string
    acc_number: string
    acc_name: string
  }

  export type LocationCreateManyStore_idInput = {
    id?: string
    name: string
    address: string
    postal_code: string
    city_district: string
    is_main_location?: boolean | null
    longitude: string
    latitude: string
  }

  export type CartsCreateManyStore_idInput = {
    id?: string
    prices: number
    discount?: string | null
    userId: string
  }

  export type Cart_itemsCreateManyStore_idInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    userId: string
    variant_option_valuesId: string
  }

  export type Stores_on_decorationsCreateManyStore_idInput = {
    id?: string
  }

  export type Operation_hoursCreateManyStore_idInput = {
    id?: string
    day: string
    open_at: string
    close_at: string
    is_off: boolean
  }

  export type Message_templatesCreateManyStore_idInput = {
    id?: string
    name: string
    content: string
  }

  export type ProductUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: VariantsUpdateOneWithoutProduct_idNestedInput
    Categories?: CategoriesUpdateManyWithoutProduct_idNestedInput
  }

  export type ProductUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
    variants?: VariantsUncheckedUpdateOneWithoutProduct_idNestedInput
    Categories?: CategoriesUncheckedUpdateManyWithoutProduct_idNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: StringFieldUpdateOperationsInput | string
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    minimum_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bank_accountsUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
  }

  export type bank_accountsUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
  }

  export type bank_accountsUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank?: StringFieldUpdateOperationsInput | string
    acc_number?: StringFieldUpdateOperationsInput | string
    acc_name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUpdateOneWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
    profile_id?: ProfilesUncheckedUpdateOneWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    city_district?: StringFieldUpdateOperationsInput | string
    is_main_location?: NullableBoolFieldUpdateOperationsInput | boolean | null
    longitude?: StringFieldUpdateOperationsInput | string
    latitude?: StringFieldUpdateOperationsInput | string
  }

  export type CartsUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: UserUpdateOneRequiredWithoutCartsNestedInput
    Cart_items?: Cart_itemsUpdateManyWithoutCart_idNestedInput
    Invoices?: InvoicesUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutCart_idNestedInput
    Invoices?: InvoicesUncheckedUpdateManyWithoutCart_idNestedInput
  }

  export type CartsUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cart_id?: CartsUpdateOneRequiredWithoutCart_itemsNestedInput
    user_id?: UserUpdateOneRequiredWithoutCart_itemsNestedInput
    variant_option_value_id?: Variant_option_valuesUpdateOneRequiredWithoutCart_itemsNestedInput
  }

  export type Cart_itemsUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type Stores_on_decorationsUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type Stores_on_decorationsUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type Stores_on_decorationsUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type Operation_hoursUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Operation_hoursUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Operation_hoursUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    open_at?: StringFieldUpdateOperationsInput | string
    close_at?: StringFieldUpdateOperationsInput | string
    is_off?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Message_templatesUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type Message_templatesUncheckedUpdateWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type Message_templatesUncheckedUpdateManyWithoutStore_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsCreateManyVariant_option_value_idInput = {
    id?: string
    qty: number
    price: number
    cartsId: string
    userId: string
    storesId: string
  }

  export type Cart_itemsUpdateWithoutVariant_option_value_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cart_id?: CartsUpdateOneRequiredWithoutCart_itemsNestedInput
    user_id?: UserUpdateOneRequiredWithoutCart_itemsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCart_itemsNestedInput
  }

  export type Cart_itemsUncheckedUpdateWithoutVariant_option_value_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUncheckedUpdateManyWithoutVariant_option_value_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    cartsId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
  }

  export type Variant_option_valuesCreateManyVariant_option_idInput = {
    id?: string
    sku: string
    weight: string
    stock: number
    price: number
    is_active?: boolean
  }

  export type Variant_option_valuesUpdateWithoutVariant_option_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    Cart_items?: Cart_itemsUpdateManyWithoutVariant_option_value_idNestedInput
  }

  export type Variant_option_valuesUncheckedUpdateWithoutVariant_option_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    Cart_items?: Cart_itemsUncheckedUpdateManyWithoutVariant_option_value_idNestedInput
  }

  export type Variant_option_valuesUncheckedUpdateManyWithoutVariant_option_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    weight?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Variant_optionsCreateManyVariant_idInput = {
    id?: string
    name: string
  }

  export type Variant_optionsUpdateWithoutVariant_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Variant_option_values?: Variant_option_valuesUpdateManyWithoutVariant_option_idNestedInput
  }

  export type Variant_optionsUncheckedUpdateWithoutVariant_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Variant_option_values?: Variant_option_valuesUncheckedUpdateManyWithoutVariant_option_idNestedInput
  }

  export type Variant_optionsUncheckedUpdateManyWithoutVariant_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsCreateManyCart_idInput = {
    id?: string
    qty: number
    price: number
    userId: string
    storesId: string
    variant_option_valuesId: string
  }

  export type InvoicesCreateManyCart_idInput = {
    id?: string
    prices: number
    status?: boolean
    receiver_longitude: string
    receiver_latitude: string
    receiver_district: string
    receiver_phone: string
    receiver_address: string
    receiver_name: string
    invoice_number: string
    userId: string
    paymentsId: string
  }

  export type Cart_itemsUpdateWithoutCart_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    user_id?: UserUpdateOneRequiredWithoutCart_itemsNestedInput
    store_id?: StoresUpdateOneRequiredWithoutCart_itemsNestedInput
    variant_option_value_id?: Variant_option_valuesUpdateOneRequiredWithoutCart_itemsNestedInput
  }

  export type Cart_itemsUncheckedUpdateWithoutCart_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type Cart_itemsUncheckedUpdateManyWithoutCart_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    storesId?: StringFieldUpdateOperationsInput | string
    variant_option_valuesId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoicesUpdateWithoutCart_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    user_id?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    courier_id?: CouriersUpdateOneWithoutInvoice_idNestedInput
    payment_id?: PaymentsUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateWithoutCart_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
    courier_id?: CouriersUncheckedUpdateOneWithoutInvoice_idNestedInput
    Confirmation_payment?: Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idNestedInput
    Invoice_histories?: Invoice_historiesUncheckedUpdateManyWithoutInvoice_idNestedInput
  }

  export type InvoicesUncheckedUpdateManyWithoutCart_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    prices?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    receiver_longitude?: StringFieldUpdateOperationsInput | string
    receiver_latitude?: StringFieldUpdateOperationsInput | string
    receiver_district?: StringFieldUpdateOperationsInput | string
    receiver_phone?: StringFieldUpdateOperationsInput | string
    receiver_address?: StringFieldUpdateOperationsInput | string
    receiver_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentsId?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentCreateManyInvoice_idInput = {
    id?: string
    amount: number
    bank: string
  }

  export type Invoice_historiesCreateManyInvoice_idInput = {
    id?: string
    status?: boolean
    created_at?: Date | string | null
  }

  export type Confirmation_paymentUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentUncheckedUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
  }

  export type Confirmation_paymentUncheckedUpdateManyWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
  }

  export type Invoice_historiesUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Invoice_historiesUncheckedUpdateWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Invoice_historiesUncheckedUpdateManyWithoutInvoice_idInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}